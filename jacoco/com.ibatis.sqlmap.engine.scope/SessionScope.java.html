<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SessionScope.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.scope</a> &gt; <span class="el_source">SessionScope.java</span></div><h1>SessionScope.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2004-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.scope;

import com.ibatis.sqlmap.client.SqlMapClient;
import com.ibatis.sqlmap.client.SqlMapException;
import com.ibatis.sqlmap.client.SqlMapExecutor;
import com.ibatis.sqlmap.client.SqlMapTransactionManager;
import com.ibatis.sqlmap.engine.transaction.Transaction;
import com.ibatis.sqlmap.engine.transaction.TransactionState;
import com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;

/**
 * A Session based implementation of the Scope interface
 */
public class SessionScope {
  private static long nextId;
  private long id;
  // Used by Any
  private SqlMapClient sqlMapClient;
  private SqlMapExecutor sqlMapExecutor;
  private SqlMapTransactionManager sqlMapTxMgr;
  private int requestStackDepth;
  // Used by TransactionManager
  private Transaction transaction;
  private TransactionState transactionState;
  // Used by SqlMapExecutorDelegate.setUserProvidedTransaction()
  private TransactionState savedTransactionState;
  // Used by StandardSqlMapClient and GeneralStatement
  private boolean inBatch;
  // Used by SqlExecutor
  private Object batch;
  private boolean commitRequired;
  private Map preparedStatements;

<span class="fc" id="L55">  /**</span>
<span class="fc" id="L56">   * Default constructor</span>
<span class="fc" id="L57">   */</span>
<span class="fc" id="L58">  public SessionScope() {</span>
<span class="fc" id="L59">    this.preparedStatements = new HashMap();</span>
<span class="fc" id="L60">    this.inBatch = false;</span>
    this.requestStackDepth = 0;
    this.id = getNextId();
  }

  /**
   * Get the SqlMapClient for the session
   *
<span class="fc" id="L68">   * @return - the SqlMapClient</span>
   */
  public SqlMapClient getSqlMapClient() {
    return sqlMapClient;
  }

  /**
   * Set the SqlMapClient for the session
   *
   * @param sqlMapClient
<span class="fc" id="L78">   *          - the SqlMapClient</span>
<span class="fc" id="L79">   */</span>
  public void setSqlMapClient(SqlMapClient sqlMapClient) {
    this.sqlMapClient = sqlMapClient;
  }

  /**
   * Get the SQL executor for the session
   *
<span class="fc" id="L87">   * @return - the SQL executor</span>
   */
  public SqlMapExecutor getSqlMapExecutor() {
    return sqlMapExecutor;
  }

  /**
   * Get the SQL executor for the session
   *
   * @param sqlMapExecutor
<span class="fc" id="L97">   *          - the SQL executor</span>
<span class="fc" id="L98">   */</span>
  public void setSqlMapExecutor(SqlMapExecutor sqlMapExecutor) {
    this.sqlMapExecutor = sqlMapExecutor;
  }

  /**
   * Get the transaction manager
   *
<span class="fc" id="L106">   * @return - the transaction manager</span>
   */
  public SqlMapTransactionManager getSqlMapTxMgr() {
    return sqlMapTxMgr;
  }

  /**
   * Set the transaction manager
   *
   * @param sqlMapTxMgr
<span class="fc" id="L116">   *          - the transaction manager</span>
<span class="fc" id="L117">   */</span>
  public void setSqlMapTxMgr(SqlMapTransactionManager sqlMapTxMgr) {
    this.sqlMapTxMgr = sqlMapTxMgr;
  }

  /**
   * Tells us if we are in batch mode or not
   *
<span class="fc" id="L125">   * @return - true if we are working with a batch</span>
   */
  public boolean isInBatch() {
    return inBatch;
  }

  /**
   * Turn batch mode on or off
   *
   * @param inBatch
<span class="fc" id="L135">   *          - the switch</span>
<span class="fc" id="L136">   */</span>
  public void setInBatch(boolean inBatch) {
    this.inBatch = inBatch;
  }

  /**
   * Getter for the session transaction
   *
<span class="fc" id="L144">   * @return - the transaction</span>
   */
  public Transaction getTransaction() {
    return transaction;
  }

  /**
   * Setter for the session transaction
   *
   * @param transaction
<span class="fc" id="L154">   *          - the transaction</span>
<span class="fc" id="L155">   */</span>
  public void setTransaction(Transaction transaction) {
    this.transaction = transaction;
  }

  /**
   * Getter for the transaction state of the session
   *
<span class="fc" id="L163">   * @return - the state</span>
   */
  public TransactionState getTransactionState() {
    return transactionState;
  }

  /**
   * Setter for the transaction state of the session
   *
   * @param transactionState
<span class="fc" id="L173">   *          - the new transaction state</span>
<span class="fc" id="L174">   */</span>
  public void setTransactionState(TransactionState transactionState) {
    this.transactionState = transactionState;
  }

  /**
   * Getter for the batch of the session
   *
<span class="fc" id="L182">   * @return - the batch</span>
   */
  public Object getBatch() {
    return batch;
  }

  /**
   * Stter for the batch of the session
   *
   * @param batch
<span class="fc" id="L192">   *          the new batch</span>
<span class="fc" id="L193">   */</span>
  public void setBatch(Object batch) {
    this.batch = batch;
  }

  /**
   * Get the request stack depth
   *
<span class="fc" id="L201">   * @return - the stack depth</span>
   */
  public int getRequestStackDepth() {
    return requestStackDepth;
  }

  /**
<span class="fc" id="L208">   * Increment the stack depth by one.</span>
<span class="fc" id="L209">   */</span>
  public void incrementRequestStackDepth() {
    requestStackDepth++;
  }

  /**
<span class="fc" id="L215">   * Decrement the stack depth by one.</span>
<span class="fc" id="L216">   */</span>
  public void decrementRequestStackDepth() {
    requestStackDepth--;
  }

  /**
   * Getter to tell if a commit is required for the session
   *
<span class="fc" id="L224">   * @return - true if a commit is required</span>
   */
  public boolean isCommitRequired() {
    return commitRequired;
  }

  /**
   * Setter to tell the session that a commit is required for the session
   *
   * @param commitRequired
<span class="fc" id="L234">   *          - the flag</span>
<span class="fc" id="L235">   */</span>
  public void setCommitRequired(boolean commitRequired) {
    this.commitRequired = commitRequired;
<span class="fc" id="L238">  }</span>

  public boolean hasPreparedStatementFor(String sql) {
    return preparedStatements.containsKey(sql);
<span class="fc" id="L242">  }</span>

  public boolean hasPreparedStatement(PreparedStatement ps) {
    return preparedStatements.containsValue(ps);
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">  }</span>
<span class="nc" id="L247"></span>
<span class="fc" id="L248">  public PreparedStatement getPreparedStatement(String sql) throws SQLException {</span>
<span class="fc" id="L249">    if (!hasPreparedStatementFor(sql))</span>
      throw new SqlMapException(&quot;Could not get prepared statement.  This is likely a bug.&quot;);
    PreparedStatement ps = (PreparedStatement) preparedStatements.get(sql);
    return ps;
<span class="fc bfc" id="L253" title="All 2 branches covered.">  }</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed."></span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">  public void putPreparedStatement(SqlMapExecutorDelegate delegate, String sql, PreparedStatement ps) {</span>
<span class="nc" id="L256">    if (delegate.isStatementCacheEnabled()) {</span>
<span class="fc" id="L257">      if (!isInBatch()) {</span>
        if (hasPreparedStatementFor(sql))
          throw new SqlMapException(&quot;Duplicate prepared statement found.  This is likely a bug.&quot;);
<span class="fc" id="L260">        preparedStatements.put(sql, ps);</span>
      }
    }
<span class="fc" id="L263">  }</span>
<span class="fc bfc" id="L264" title="All 2 branches covered."></span>
<span class="fc" id="L265">  public void closePreparedStatements() {</span>
    Iterator keys = preparedStatements.keySet().iterator();
<span class="fc" id="L267">    while (keys.hasNext()) {</span>
<span class="nc" id="L268">      PreparedStatement ps = (PreparedStatement) preparedStatements.get(keys.next());</span>
      try {
<span class="fc" id="L270">        ps.close();</span>
<span class="fc" id="L271">      } catch (Exception e) {</span>
<span class="fc" id="L272">        // ignore -- we don't care if this fails at this point.</span>
<span class="fc" id="L273">      }</span>
    }
    preparedStatements.clear();
<span class="fc" id="L276">  }</span>
<span class="fc" id="L277"></span>
<span class="fc" id="L278">  public void cleanup() {</span>
    closePreparedStatements();
    preparedStatements.clear();
  }
<span class="nc bnc" id="L282" title="All 2 branches missed."></span>
<span class="nc" id="L283">  @Override</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">  public boolean equals(Object parameterObject) {</span>
<span class="nc" id="L285">    if (this == parameterObject)</span>
<span class="nc" id="L286">      return true;</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">    if (!(parameterObject instanceof SessionScope))</span>
<span class="nc" id="L288">      return false;</span>
<span class="nc" id="L289">    final SessionScope sessionScope = (SessionScope) parameterObject;</span>
    if (id != sessionScope.id)
      return false;
    return true;
  }
<span class="nc" id="L294"></span>
  @Override
  public int hashCode() {
    return (int) (id ^ (id &gt;&gt;&gt; 32));
  }

  /**
   * Method to get a unique ID
   *
<span class="fc" id="L303">   * @return - the new ID</span>
   */
  public synchronized static long getNextId() {
    return nextId++;
  }

  /**
<span class="fc" id="L310">   * Saves the current transaction state</span>
<span class="fc" id="L311">   */</span>
  public void saveTransactionState() {
    savedTransactionState = transactionState;
  }

  /**
<span class="nc" id="L317">   * Restores the previously saved transaction state</span>
<span class="nc" id="L318">   */</span>
  public void recallTransactionState() {
    transactionState = savedTransactionState;
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>