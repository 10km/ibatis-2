<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ClassInfo.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.common.beans</a> &gt; <span class="el_source">ClassInfo.java</span></div><h1>ClassInfo.java</h1><pre class="source lang-java linenums">/**
 *    Copyright 2004-2015 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.ibatis.common.beans;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ReflectPermission;
import java.lang.reflect.UndeclaredThrowableException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.util.concurrent.ConcurrentHashMap;

/**
 * This class represents a cached set of class definition information that
 * allows for easy mapping between property names and getter/setter methods.
 */
public class ClassInfo {

<span class="fc" id="L50">  private static boolean cacheEnabled = true;</span>
<span class="fc" id="L51">  private static final String[] EMPTY_STRING_ARRAY = new String[0];</span>
<span class="fc" id="L52">  private static final Set SIMPLE_TYPE_SET = new HashSet();</span>
<span class="fc" id="L53">  private static final Map&lt;Class, ClassInfo&gt; CLASS_INFO_MAP = new ConcurrentHashMap&lt;Class, ClassInfo&gt;();</span>

  private String className;
<span class="fc" id="L56">  private String[] readablePropertyNames = EMPTY_STRING_ARRAY;</span>
<span class="fc" id="L57">  private String[] writeablePropertyNames = EMPTY_STRING_ARRAY;</span>
<span class="fc" id="L58">  private HashMap setMethods = new HashMap();</span>
<span class="fc" id="L59">  private HashMap getMethods = new HashMap();</span>
<span class="fc" id="L60">  private HashMap setTypes = new HashMap();</span>
<span class="fc" id="L61">  private HashMap getTypes = new HashMap();</span>
  private Constructor defaultConstructor;

  static {
<span class="fc" id="L65">    SIMPLE_TYPE_SET.add(String.class);</span>
<span class="fc" id="L66">    SIMPLE_TYPE_SET.add(Byte.class);</span>
<span class="fc" id="L67">    SIMPLE_TYPE_SET.add(Short.class);</span>
<span class="fc" id="L68">    SIMPLE_TYPE_SET.add(Character.class);</span>
<span class="fc" id="L69">    SIMPLE_TYPE_SET.add(Integer.class);</span>
<span class="fc" id="L70">    SIMPLE_TYPE_SET.add(Long.class);</span>
<span class="fc" id="L71">    SIMPLE_TYPE_SET.add(Float.class);</span>
<span class="fc" id="L72">    SIMPLE_TYPE_SET.add(Double.class);</span>
<span class="fc" id="L73">    SIMPLE_TYPE_SET.add(Boolean.class);</span>
<span class="fc" id="L74">    SIMPLE_TYPE_SET.add(Date.class);</span>
<span class="fc" id="L75">    SIMPLE_TYPE_SET.add(Class.class);</span>
<span class="fc" id="L76">    SIMPLE_TYPE_SET.add(BigInteger.class);</span>
<span class="fc" id="L77">    SIMPLE_TYPE_SET.add(BigDecimal.class);</span>

<span class="fc" id="L79">    SIMPLE_TYPE_SET.add(Collection.class);</span>
<span class="fc" id="L80">    SIMPLE_TYPE_SET.add(Set.class);</span>
<span class="fc" id="L81">    SIMPLE_TYPE_SET.add(Map.class);</span>
<span class="fc" id="L82">    SIMPLE_TYPE_SET.add(List.class);</span>
<span class="fc" id="L83">    SIMPLE_TYPE_SET.add(HashMap.class);</span>
<span class="fc" id="L84">    SIMPLE_TYPE_SET.add(TreeMap.class);</span>
<span class="fc" id="L85">    SIMPLE_TYPE_SET.add(ArrayList.class);</span>
<span class="fc" id="L86">    SIMPLE_TYPE_SET.add(LinkedList.class);</span>
<span class="fc" id="L87">    SIMPLE_TYPE_SET.add(HashSet.class);</span>
<span class="fc" id="L88">    SIMPLE_TYPE_SET.add(TreeSet.class);</span>
<span class="fc" id="L89">    SIMPLE_TYPE_SET.add(Vector.class);</span>
<span class="fc" id="L90">    SIMPLE_TYPE_SET.add(Hashtable.class);</span>
<span class="fc" id="L91">    SIMPLE_TYPE_SET.add(Enumeration.class);</span>
<span class="fc" id="L92">  }</span>

<span class="fc" id="L94">  private ClassInfo(Class clazz) {</span>
<span class="fc" id="L95">    className = clazz.getName();</span>
<span class="fc" id="L96">    addDefaultConstructor(clazz);</span>
<span class="fc" id="L97">    addGetMethods(clazz);</span>
<span class="fc" id="L98">    addSetMethods(clazz);</span>
<span class="fc" id="L99">    addFields(clazz);</span>
<span class="fc" id="L100">    readablePropertyNames = (String[]) getMethods.keySet().toArray(new String[getMethods.keySet().size()]);</span>
<span class="fc" id="L101">    writeablePropertyNames = (String[]) setMethods.keySet().toArray(new String[setMethods.keySet().size()]);</span>
<span class="fc" id="L102">  }</span>

  private void addDefaultConstructor(Class clazz) {
<span class="fc" id="L105">    Constructor[] consts = clazz.getDeclaredConstructors();</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">    for (int i = 0; i &lt; consts.length; i++) {</span>
<span class="fc" id="L107">      Constructor constructor = consts[i];</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">      if (constructor.getParameterTypes().length == 0) {</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        if (canAccessPrivateMethods()) {</span>
          try {
<span class="fc" id="L111">            constructor.setAccessible(true);</span>
<span class="pc" id="L112">          } catch (Exception e) {</span>
            // Ignored. This is only a final precaution, nothing we can do.
          }
        }
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (constructor.isAccessible()) {</span>
<span class="fc" id="L117">          this.defaultConstructor = constructor;</span>
        }
      }
    }
<span class="fc" id="L121">  }</span>

  private void addGetMethods(Class cls) {
<span class="fc" id="L124">    Method[] methods = getClassMethods(cls);</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">    for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="fc" id="L126">      Method method = methods[i];</span>
<span class="fc" id="L127">      String name = method.getName();</span>
<span class="fc bfc" id="L128" title="All 4 branches covered.">      if (name.startsWith(&quot;get&quot;) &amp;&amp; name.length() &gt; 3) {</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (method.getParameterTypes().length == 0) {</span>
<span class="fc" id="L130">          name = dropCase(name);</span>
<span class="fc" id="L131">          addGetMethod(name, method);</span>
        }
<span class="pc bpc" id="L133" title="1 of 4 branches missed.">      } else if (name.startsWith(&quot;is&quot;) &amp;&amp; name.length() &gt; 2) {</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (method.getParameterTypes().length == 0) {</span>
<span class="fc" id="L135">          name = dropCase(name);</span>
<span class="fc" id="L136">          addGetMethod(name, method);</span>
        }
      }
    }
<span class="fc" id="L140">  }</span>

  private void addGetMethod(String name, Method method) {
<span class="fc" id="L143">    getMethods.put(name, new MethodInvoker(method));</span>
<span class="fc" id="L144">    getTypes.put(name, method.getReturnType());</span>
<span class="fc" id="L145">  }</span>

  private void addSetMethods(Class cls) {
<span class="fc" id="L148">    Map conflictingSetters = new HashMap();</span>
<span class="fc" id="L149">    Method[] methods = getClassMethods(cls);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">    for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="fc" id="L151">      Method method = methods[i];</span>
<span class="fc" id="L152">      String name = method.getName();</span>
<span class="fc bfc" id="L153" title="All 4 branches covered.">      if (name.startsWith(&quot;set&quot;) &amp;&amp; name.length() &gt; 3) {</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (method.getParameterTypes().length == 1) {</span>
<span class="fc" id="L155">          name = dropCase(name);</span>
          ///------------
<span class="fc" id="L157">          addSetterConflict(conflictingSetters, name, method);</span>
          // addSetMethod(name, method);
          ///------------
        }
      }
    }
<span class="fc" id="L163">    resolveSetterConflicts(conflictingSetters);</span>
<span class="fc" id="L164">  }</span>

  private void addSetterConflict(Map conflictingSetters, String name, Method method) {
<span class="fc" id="L167">    List list = (List) conflictingSetters.get(name);</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">    if (list == null) {</span>
<span class="fc" id="L169">      list = new ArrayList();</span>
<span class="fc" id="L170">      conflictingSetters.put(name, list);</span>
    }
<span class="fc" id="L172">    list.add(method);</span>
<span class="fc" id="L173">  }</span>

  private void resolveSetterConflicts(Map conflictingSetters) {
<span class="fc bfc" id="L176" title="All 2 branches covered.">    for (Iterator propNames = conflictingSetters.keySet().iterator(); propNames.hasNext();) {</span>
<span class="fc" id="L177">      String propName = (String) propNames.next();</span>
<span class="fc" id="L178">      List setters = (List) conflictingSetters.get(propName);</span>
<span class="fc" id="L179">      Method firstMethod = (Method) setters.get(0);</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">      if (setters.size() == 1) {</span>
<span class="fc" id="L181">        addSetMethod(propName, firstMethod);</span>
<span class="fc" id="L182">      } else {</span>
<span class="fc" id="L183">        Class expectedType = (Class) getTypes.get(propName);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (expectedType == null) {</span>
<span class="fc" id="L185">          throw new RuntimeException(&quot;Illegal overloaded setter method with ambiguous type for property &quot;</span>
<span class="fc" id="L186">              + propName + &quot; in class &quot; + firstMethod.getDeclaringClass() + &quot;.  This breaks the JavaBeans &quot; +</span>
<span class="fc" id="L187">              &quot;specification and can cause unpredicatble results.&quot;);</span>
        } else {
<span class="fc" id="L189">          Iterator methods = setters.iterator();</span>
<span class="fc" id="L190">          Method setter = null;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">          while (methods.hasNext()) {</span>
<span class="fc" id="L192">            Method method = (Method) methods.next();</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">            if (method.getParameterTypes().length == 1</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">                &amp;&amp; expectedType.equals(method.getParameterTypes()[0])) {</span>
<span class="fc" id="L195">              setter = method;</span>
<span class="fc" id="L196">              break;</span>
            }
          }
<span class="fc bfc" id="L199" title="All 2 branches covered.">          if (setter == null) {</span>
<span class="fc" id="L200">            throw new RuntimeException(&quot;Illegal overloaded setter method with ambiguous type for property &quot;</span>
<span class="fc" id="L201">                + propName + &quot; in class &quot; + firstMethod.getDeclaringClass() + &quot;.  This breaks the JavaBeans &quot; +</span>
<span class="fc" id="L202">                &quot;specification and can cause unpredicatble results.&quot;);</span>
          }
<span class="fc" id="L204">          addSetMethod(propName, setter);</span>
        }
      }
    }
<span class="fc" id="L208">  }</span>

  private void addSetMethod(String name, Method method) {
<span class="fc" id="L211">    setMethods.put(name, new MethodInvoker(method));</span>
<span class="fc" id="L212">    setTypes.put(name, method.getParameterTypes()[0]);</span>
<span class="fc" id="L213">  }</span>

  private void addFields(Class clazz) {
<span class="fc" id="L216">    Field[] fields = clazz.getDeclaredFields();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">    for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="fc" id="L218">      Field field = fields[i];</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">      if (canAccessPrivateMethods()) {</span>
        try {
<span class="fc" id="L221">          field.setAccessible(true);</span>
<span class="pc" id="L222">        } catch (Exception e) {</span>
          // Ignored. This is only a final precaution, nothing we can do.
        }
      }
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">      if (field.isAccessible()) {</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        if (!setMethods.containsKey(field.getName())) {</span>
<span class="fc" id="L228">          addSetField(field);</span>
        }
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (!getMethods.containsKey(field.getName())) {</span>
<span class="fc" id="L231">          addGetField(field);</span>
        }
      }
    }
<span class="fc bfc" id="L235" title="All 2 branches covered.">    if (clazz.getSuperclass() != null) {</span>
<span class="fc" id="L236">      addFields(clazz.getSuperclass());</span>
    }
<span class="fc" id="L238">  }</span>

  private void addSetField(Field field) {
<span class="fc" id="L241">    setMethods.put(field.getName(), new SetFieldInvoker(field));</span>
<span class="fc" id="L242">    setTypes.put(field.getName(), field.getType());</span>
<span class="fc" id="L243">  }</span>

  private void addGetField(Field field) {
<span class="fc" id="L246">    getMethods.put(field.getName(), new GetFieldInvoker(field));</span>
<span class="fc" id="L247">    getTypes.put(field.getName(), field.getType());</span>
<span class="fc" id="L248">  }</span>

  /**
   * This method returns an array containing all methods
   * declared in this class and any superclass.
   * We use this method, instead of the simpler Class.getMethods(),
   * because we want to look for private methods as well.
   *
   * @param cls The class
   * @return An array containing all methods in this class
   */
  private Method[] getClassMethods(Class cls) {
<span class="fc" id="L260">    HashMap uniqueMethods = new HashMap();</span>
<span class="fc" id="L261">    Class currentClass = cls;</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">    while (currentClass != null) {</span>
<span class="fc" id="L263">      addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());</span>

      // we also need to look for interface methods - 
      // because the class may be abstract
<span class="fc" id="L267">      Class[] interfaces = currentClass.getInterfaces();</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">      for (int i = 0; i &lt; interfaces.length; i++) {</span>
<span class="fc" id="L269">        addUniqueMethods(uniqueMethods, interfaces[i].getMethods());</span>
      }

<span class="fc" id="L272">      currentClass = currentClass.getSuperclass();</span>
    }

<span class="fc" id="L275">    Collection methods = uniqueMethods.values();</span>

<span class="fc" id="L277">    return (Method[]) methods.toArray(new Method[methods.size()]);</span>
  }

  private void addUniqueMethods(HashMap uniqueMethods, Method[] methods) {
<span class="fc bfc" id="L281" title="All 2 branches covered.">    for (Method currentMethod : methods) {</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">      if (!currentMethod.isBridge()) {</span>
<span class="fc" id="L283">        String signature = getSignature(currentMethod);</span>
        // check to see if the method is already known
        // if it is known, then an extended class must have
        // overridden a method
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (!uniqueMethods.containsKey(signature)) {</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">          if (canAccessPrivateMethods()) {</span>
            try {
<span class="fc" id="L290">              currentMethod.setAccessible(true);</span>
<span class="pc" id="L291">            } catch (Exception e) {</span>
              // Ignored. This is only a final precaution, nothing we can do.
            }
          }

<span class="fc" id="L296">          uniqueMethods.put(signature, currentMethod);</span>
        }
      }
    }
<span class="fc" id="L300">  }</span>

  private String getSignature(Method method) {
<span class="fc" id="L303">    StringBuffer sb = new StringBuffer();</span>
<span class="fc" id="L304">    sb.append(method.getName());</span>
<span class="fc" id="L305">    Class[] parameters = method.getParameterTypes();</span>

<span class="fc bfc" id="L307" title="All 2 branches covered.">    for (int i = 0; i &lt; parameters.length; i++) {</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">      if (i == 0) {</span>
<span class="fc" id="L309">        sb.append(':');</span>
<span class="fc" id="L310">      } else {</span>
<span class="fc" id="L311">        sb.append(',');</span>
      }
<span class="fc" id="L313">      sb.append(parameters[i].getName());</span>
    }

<span class="fc" id="L316">    return sb.toString();</span>
  }

  private static String dropCase(String name) {
<span class="fc bfc" id="L320" title="All 2 branches covered.">    if (name.startsWith(&quot;is&quot;)) {</span>
<span class="fc" id="L321">      name = name.substring(2);</span>
<span class="pc bpc" id="L322" title="1 of 4 branches missed.">    } else if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {</span>
<span class="fc" id="L323">      name = name.substring(3);</span>
<span class="fc" id="L324">    } else {</span>
<span class="nc" id="L325">      throw new ProbeException(&quot;Error parsing property name '&quot; + name + &quot;'.  Didn't start with 'is', 'get' or 'set'.&quot;);</span>
    }

<span class="pc bpc" id="L328" title="3 of 6 branches missed.">    if (name.length() == 1 || (name.length() &gt; 1 &amp;&amp; !Character.isUpperCase(name.charAt(1)))) {</span>
<span class="fc" id="L329">      name = name.substring(0, 1).toLowerCase(Locale.US) + name.substring(1);</span>
    }

<span class="fc" id="L332">    return name;</span>
  }

  private static boolean canAccessPrivateMethods() {
    try {
<span class="fc" id="L337">      SecurityManager securityManager = System.getSecurityManager();</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">      if (null != securityManager) {</span>
<span class="nc" id="L339">        securityManager.checkPermission(new ReflectPermission(&quot;suppressAccessChecks&quot;));</span>
      }
<span class="nc" id="L341">    } catch (SecurityException e) {</span>
<span class="nc" id="L342">      return false;</span>
    }
<span class="fc" id="L344">    return true;</span>
  }

  /**
   * Gets the name of the class the instance provides information for
   *
   * @return The class name
   */
  public String getClassName() {
<span class="nc" id="L353">    return className;</span>
  }

  public Object instantiateClass() {
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">    if (defaultConstructor != null) {</span>
      try {
<span class="fc" id="L359">        return defaultConstructor.newInstance(null);</span>
<span class="nc" id="L360">      } catch (Exception e) {</span>
<span class="nc" id="L361">        throw new RuntimeException(&quot;Error instantiating class. Cause: &quot; + e, e);</span>
      }
    } else {
<span class="nc" id="L364">      throw new RuntimeException(&quot;Error instantiating class.  There is no default constructor for class &quot; + className);</span>
    }
  }

  /**
   * Gets the setter for a property as a Method object
   *
   * @param propertyName - the property
   * @return The Method
   */
  public Method getSetter(String propertyName) {
<span class="fc" id="L375">    Invoker method = (Invoker) setMethods.get(propertyName);</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L377">      throw new ProbeException(&quot;There is no WRITEABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);</span>
    }
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">    if (!(method instanceof MethodInvoker)) {</span>
<span class="nc" id="L380">      throw new ProbeException(&quot;Can't get setter method because '&quot; + propertyName + &quot;' is a field in class '&quot; + className + &quot;'&quot;);</span>
    }
<span class="fc" id="L382">    return ((MethodInvoker) method).getMethod();</span>
  }

  /**
   * Gets the getter for a property as a Method object
   *
   * @param propertyName - the property
   * @return The Method
   */
  public Method getGetter(String propertyName) {
<span class="fc" id="L392">    Invoker method = (Invoker) getMethods.get(propertyName);</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L394">      throw new ProbeException(&quot;There is no READABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);</span>
    }
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">    if (!(method instanceof MethodInvoker)) {</span>
<span class="nc" id="L397">      throw new ProbeException(&quot;Can't get getter method because '&quot; + propertyName + &quot;' is a field in class '&quot; + className + &quot;'&quot;);</span>
    }
<span class="fc" id="L399">    return ((MethodInvoker) method).getMethod();</span>
  }

  public Invoker getSetInvoker(String propertyName) {
<span class="fc" id="L403">    Invoker method = (Invoker) setMethods.get(propertyName);</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L405">      throw new ProbeException(&quot;There is no WRITEABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);</span>
    }
<span class="fc" id="L407">    return method;</span>
  }

  public Invoker getGetInvoker(String propertyName) {
<span class="fc" id="L411">    Invoker method = (Invoker) getMethods.get(propertyName);</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L413">      throw new ProbeException(&quot;There is no READABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);</span>
    }
<span class="fc" id="L415">    return method;</span>
  }

  /**
   * Gets the type for a property setter
   *
   * @param propertyName - the name of the property
   * @return The Class of the propery setter
   */
  public Class getSetterType(String propertyName) {
<span class="fc" id="L425">    Class clazz = (Class) setTypes.get(propertyName);</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">    if (clazz == null) {</span>
<span class="fc" id="L427">      throw new ProbeException(&quot;There is no WRITEABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);</span>
    }
<span class="fc" id="L429">    return clazz;</span>
  }

  /**
   * Gets the type for a property getter
   *
   * @param propertyName - the name of the property
   * @return The Class of the propery getter
   */
  public Class getGetterType(String propertyName) {
<span class="fc" id="L439">    Class clazz = (Class) getTypes.get(propertyName);</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">    if (clazz == null) {</span>
<span class="nc" id="L441">      throw new ProbeException(&quot;There is no READABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);</span>
    }
<span class="fc" id="L443">    return clazz;</span>
  }

  /**
   * Gets an array of the readable properties for an object
   *
   * @return The array
   */
  public String[] getReadablePropertyNames() {
<span class="nc" id="L452">    return readablePropertyNames;</span>
  }

  /**
   * Gets an array of the writeable properties for an object
   *
   * @return The array
   */
  public String[] getWriteablePropertyNames() {
<span class="fc" id="L461">    return writeablePropertyNames;</span>
  }

  /**
   * Check to see if a class has a writeable property by name
   *
   * @param propertyName - the name of the property to check
   * @return True if the object has a writeable property by the name
   */
  public boolean hasWritableProperty(String propertyName) {
<span class="fc" id="L471">    return setMethods.keySet().contains(propertyName);</span>
  }

  /**
   * Check to see if a class has a readable property by name
   *
   * @param propertyName - the name of the property to check
   * @return True if the object has a readable property by the name
   */
  public boolean hasReadableProperty(String propertyName) {
<span class="fc" id="L481">    return getMethods.keySet().contains(propertyName);</span>
  }

  /**
   * Tells us if the class passed in is a knwon common type
   *
   * @param clazz The class to check
   * @return True if the class is known
   */
  public static boolean isKnownType(Class clazz) {
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">    if (SIMPLE_TYPE_SET.contains(clazz)) {</span>
<span class="nc" id="L492">      return true;</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">    } else if (Collection.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L494">      return true;</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">    } else if (Map.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L496">      return true;</span>
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">    } else if (List.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L498">      return true;</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">    } else if (Set.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L500">      return true;</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">    } else if (Iterator.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L502">      return true;</span>
    } else {
<span class="fc" id="L504">      return false;</span>
    }
  }

  /**
   * Gets an instance of ClassInfo for the specified class.
   *
   * @param clazz The class for which to lookup the method cache.
   * @return The method cache for the class
   */
  public static ClassInfo getInstance(Class clazz) {
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">    if (cacheEnabled) {</span>
<span class="fc" id="L516">      ClassInfo cached = (ClassInfo) CLASS_INFO_MAP.get(clazz);</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">      if (cached == null) {</span>
<span class="fc" id="L518">        cached = new ClassInfo(clazz);</span>
<span class="fc" id="L519">        CLASS_INFO_MAP.put(clazz, cached);</span>
      }
<span class="fc" id="L521">      return cached;</span>
    } else {
<span class="nc" id="L523">      return new ClassInfo(clazz);</span>
    }
  }

  public static void setCacheEnabled(boolean cacheEnabled) {
<span class="fc" id="L528">    ClassInfo.cacheEnabled = cacheEnabled;</span>
<span class="fc" id="L529">  }</span>

  /**
   * Examines a Throwable object and gets it's root cause
   *
   * @param t - the exception to examine
   * @return The root cause
   */
  public static Throwable unwrapThrowable(Throwable t) {
<span class="fc" id="L538">    Throwable t2 = t;</span>
    while (true) {
<span class="fc bfc" id="L540" title="All 2 branches covered.">      if (t2 instanceof InvocationTargetException) {</span>
<span class="fc" id="L541">        t2 = ((InvocationTargetException) t).getTargetException();</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">      } else if (t2 instanceof UndeclaredThrowableException) {</span>
<span class="fc" id="L543">        t2 = ((UndeclaredThrowableException) t).getUndeclaredThrowable();</span>
<span class="fc" id="L544">      } else {</span>
<span class="fc" id="L545">        return t2;</span>
      }
    }
  }

}



</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>