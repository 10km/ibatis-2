<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ClassInfo.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.common.beans</a> &gt; <span class="el_source">ClassInfo.java</span></div><h1>ClassInfo.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2004-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.common.beans;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ReflectPermission;
import java.lang.reflect.UndeclaredThrowableException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.util.concurrent.ConcurrentHashMap;

/**
 * This class represents a cached set of class definition information that allows for easy mapping between property
 * names and getter/setter methods.
<span class="fc" id="L47"> */</span>
<span class="fc" id="L48">public class ClassInfo {</span>
<span class="fc" id="L49"></span>
<span class="fc" id="L50">  private static boolean cacheEnabled = true;</span>
  private static final String[] EMPTY_STRING_ARRAY = new String[0];
  private static final Set SIMPLE_TYPE_SET = new HashSet();
<span class="fc" id="L53">  private static final Map&lt;Class, ClassInfo&gt; CLASS_INFO_MAP = new ConcurrentHashMap&lt;Class, ClassInfo&gt;();</span>
<span class="fc" id="L54"></span>
<span class="fc" id="L55">  private String className;</span>
<span class="fc" id="L56">  private String[] readablePropertyNames = EMPTY_STRING_ARRAY;</span>
<span class="fc" id="L57">  private String[] writeablePropertyNames = EMPTY_STRING_ARRAY;</span>
<span class="fc" id="L58">  private HashMap setMethods = new HashMap();</span>
  private HashMap getMethods = new HashMap();
  private HashMap setTypes = new HashMap();
  private HashMap getTypes = new HashMap();
<span class="fc" id="L62">  private Constructor defaultConstructor;</span>
<span class="fc" id="L63"></span>
<span class="fc" id="L64">  static {</span>
<span class="fc" id="L65">    SIMPLE_TYPE_SET.add(String.class);</span>
<span class="fc" id="L66">    SIMPLE_TYPE_SET.add(Byte.class);</span>
<span class="fc" id="L67">    SIMPLE_TYPE_SET.add(Short.class);</span>
<span class="fc" id="L68">    SIMPLE_TYPE_SET.add(Character.class);</span>
<span class="fc" id="L69">    SIMPLE_TYPE_SET.add(Integer.class);</span>
<span class="fc" id="L70">    SIMPLE_TYPE_SET.add(Long.class);</span>
<span class="fc" id="L71">    SIMPLE_TYPE_SET.add(Float.class);</span>
<span class="fc" id="L72">    SIMPLE_TYPE_SET.add(Double.class);</span>
<span class="fc" id="L73">    SIMPLE_TYPE_SET.add(Boolean.class);</span>
<span class="fc" id="L74">    SIMPLE_TYPE_SET.add(Date.class);</span>
    SIMPLE_TYPE_SET.add(Class.class);
<span class="fc" id="L76">    SIMPLE_TYPE_SET.add(BigInteger.class);</span>
<span class="fc" id="L77">    SIMPLE_TYPE_SET.add(BigDecimal.class);</span>
<span class="fc" id="L78"></span>
<span class="fc" id="L79">    SIMPLE_TYPE_SET.add(Collection.class);</span>
<span class="fc" id="L80">    SIMPLE_TYPE_SET.add(Set.class);</span>
<span class="fc" id="L81">    SIMPLE_TYPE_SET.add(Map.class);</span>
<span class="fc" id="L82">    SIMPLE_TYPE_SET.add(List.class);</span>
<span class="fc" id="L83">    SIMPLE_TYPE_SET.add(HashMap.class);</span>
<span class="fc" id="L84">    SIMPLE_TYPE_SET.add(TreeMap.class);</span>
<span class="fc" id="L85">    SIMPLE_TYPE_SET.add(ArrayList.class);</span>
<span class="fc" id="L86">    SIMPLE_TYPE_SET.add(LinkedList.class);</span>
<span class="fc" id="L87">    SIMPLE_TYPE_SET.add(HashSet.class);</span>
<span class="fc" id="L88">    SIMPLE_TYPE_SET.add(TreeSet.class);</span>
<span class="fc" id="L89">    SIMPLE_TYPE_SET.add(Vector.class);</span>
    SIMPLE_TYPE_SET.add(Hashtable.class);
<span class="fc" id="L91">    SIMPLE_TYPE_SET.add(Enumeration.class);</span>
<span class="fc" id="L92">  }</span>
<span class="fc" id="L93"></span>
<span class="fc" id="L94">  private ClassInfo(Class clazz) {</span>
<span class="fc" id="L95">    className = clazz.getName();</span>
<span class="fc" id="L96">    addDefaultConstructor(clazz);</span>
<span class="fc" id="L97">    addGetMethods(clazz);</span>
<span class="fc" id="L98">    addSetMethods(clazz);</span>
<span class="fc" id="L99">    addFields(clazz);</span>
    readablePropertyNames = (String[]) getMethods.keySet().toArray(new String[getMethods.keySet().size()]);
    writeablePropertyNames = (String[]) setMethods.keySet().toArray(new String[setMethods.keySet().size()]);
<span class="fc" id="L102">  }</span>
<span class="fc bfc" id="L103" title="All 2 branches covered."></span>
<span class="fc" id="L104">  private void addDefaultConstructor(Class clazz) {</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">    Constructor[] consts = clazz.getDeclaredConstructors();</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">    for (int i = 0; i &lt; consts.length; i++) {</span>
      Constructor constructor = consts[i];
<span class="fc" id="L108">      if (constructor.getParameterTypes().length == 0) {</span>
<span class="nc" id="L109">        if (canAccessPrivateMethods()) {</span>
          try {
<span class="fc" id="L111">            constructor.setAccessible(true);</span>
          } catch (Exception e) {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            // Ignored. This is only a final precaution, nothing we can do.</span>
<span class="fc" id="L114">          }</span>
        }
        if (constructor.isAccessible()) {
          this.defaultConstructor = constructor;
<span class="fc" id="L118">        }</span>
      }
    }
<span class="fc" id="L121">  }</span>
<span class="fc bfc" id="L122" title="All 2 branches covered."></span>
<span class="fc" id="L123">  private void addGetMethods(Class cls) {</span>
<span class="fc" id="L124">    Method[] methods = getClassMethods(cls);</span>
<span class="fc bfc" id="L125" title="All 4 branches covered.">    for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">      Method method = methods[i];</span>
<span class="fc" id="L127">      String name = method.getName();</span>
<span class="fc" id="L128">      if (name.startsWith(&quot;get&quot;) &amp;&amp; name.length() &gt; 3) {</span>
        if (method.getParameterTypes().length == 0) {
<span class="pc bpc" id="L130" title="1 of 4 branches missed.">          name = dropCase(name);</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">          addGetMethod(name, method);</span>
<span class="fc" id="L132">        }</span>
<span class="fc" id="L133">      } else if (name.startsWith(&quot;is&quot;) &amp;&amp; name.length() &gt; 2) {</span>
        if (method.getParameterTypes().length == 0) {
          name = dropCase(name);
          addGetMethod(name, method);
<span class="fc" id="L137">        }</span>
      }
    }
<span class="fc" id="L140">  }</span>
<span class="fc" id="L141"></span>
<span class="fc" id="L142">  private void addGetMethod(String name, Method method) {</span>
    getMethods.put(name, new MethodInvoker(method));
    getTypes.put(name, method.getReturnType());
<span class="fc" id="L145">  }</span>
<span class="fc" id="L146"></span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">  private void addSetMethods(Class cls) {</span>
<span class="fc" id="L148">    Map conflictingSetters = new HashMap();</span>
<span class="fc" id="L149">    Method[] methods = getClassMethods(cls);</span>
<span class="fc bfc" id="L150" title="All 4 branches covered.">    for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">      Method method = methods[i];</span>
<span class="fc" id="L152">      String name = method.getName();</span>
      if (name.startsWith(&quot;set&quot;) &amp;&amp; name.length() &gt; 3) {
<span class="fc" id="L154">        if (method.getParameterTypes().length == 1) {</span>
          name = dropCase(name);
          // /------------
          addSetterConflict(conflictingSetters, name, method);
          // addSetMethod(name, method);
          // /------------
<span class="fc" id="L160">        }</span>
<span class="fc" id="L161">      }</span>
    }
    resolveSetterConflicts(conflictingSetters);
<span class="fc" id="L164">  }</span>
<span class="fc bfc" id="L165" title="All 2 branches covered."></span>
<span class="fc" id="L166">  private void addSetterConflict(Map conflictingSetters, String name, Method method) {</span>
<span class="fc" id="L167">    List list = (List) conflictingSetters.get(name);</span>
    if (list == null) {
<span class="fc" id="L169">      list = new ArrayList();</span>
<span class="fc" id="L170">      conflictingSetters.put(name, list);</span>
    }
    list.add(method);
<span class="fc bfc" id="L173" title="All 2 branches covered.">  }</span>
<span class="fc" id="L174"></span>
<span class="fc" id="L175">  private void resolveSetterConflicts(Map conflictingSetters) {</span>
<span class="fc" id="L176">    for (Iterator propNames = conflictingSetters.keySet().iterator(); propNames.hasNext();) {</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">      String propName = (String) propNames.next();</span>
<span class="fc" id="L178">      List setters = (List) conflictingSetters.get(propName);</span>
      Method firstMethod = (Method) setters.get(0);
<span class="fc" id="L180">      if (setters.size() == 1) {</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        addSetMethod(propName, firstMethod);</span>
<span class="fc" id="L182">      } else {</span>
        Class expectedType = (Class) getTypes.get(propName);
        if (expectedType == null) {
          throw new RuntimeException(&quot;Illegal overloaded setter method with ambiguous type for property &quot; + propName
<span class="fc" id="L186">              + &quot; in class &quot; + firstMethod.getDeclaringClass() + &quot;.  This breaks the JavaBeans &quot;</span>
<span class="fc" id="L187">              + &quot;specification and can cause unpredicatble results.&quot;);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        } else {</span>
<span class="fc" id="L189">          Iterator methods = setters.iterator();</span>
<span class="pc bpc" id="L190" title="1 of 4 branches missed.">          Method setter = null;</span>
<span class="fc" id="L191">          while (methods.hasNext()) {</span>
<span class="fc" id="L192">            Method method = (Method) methods.next();</span>
            if (method.getParameterTypes().length == 1 &amp;&amp; expectedType.equals(method.getParameterTypes()[0])) {
<span class="fc" id="L194">              setter = method;</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">              break;</span>
<span class="fc" id="L196">            }</span>
          }
          if (setter == null) {
            throw new RuntimeException(&quot;Illegal overloaded setter method with ambiguous type for property &quot; + propName
<span class="fc" id="L200">                + &quot; in class &quot; + firstMethod.getDeclaringClass() + &quot;.  This breaks the JavaBeans &quot;</span>
                + &quot;specification and can cause unpredicatble results.&quot;);
          }
<span class="fc" id="L203">          addSetMethod(propName, setter);</span>
<span class="fc" id="L204">        }</span>
      }
    }
<span class="fc" id="L207">  }</span>
<span class="fc" id="L208"></span>
<span class="fc" id="L209">  private void addSetMethod(String name, Method method) {</span>
    setMethods.put(name, new MethodInvoker(method));
    setTypes.put(name, method.getParameterTypes()[0]);
<span class="fc" id="L212">  }</span>
<span class="fc bfc" id="L213" title="All 2 branches covered."></span>
<span class="fc" id="L214">  private void addFields(Class clazz) {</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">    Field[] fields = clazz.getDeclaredFields();</span>
    for (int i = 0; i &lt; fields.length; i++) {
<span class="fc" id="L217">      Field field = fields[i];</span>
<span class="nc" id="L218">      if (canAccessPrivateMethods()) {</span>
        try {
<span class="fc" id="L220">          field.setAccessible(true);</span>
        } catch (Exception e) {
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">          // Ignored. This is only a final precaution, nothing we can do.</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        }</span>
<span class="fc" id="L224">      }</span>
      if (field.isAccessible()) {
<span class="fc bfc" id="L226" title="All 2 branches covered.">        if (!setMethods.containsKey(field.getName())) {</span>
<span class="fc" id="L227">          addSetField(field);</span>
        }
        if (!getMethods.containsKey(field.getName())) {
          addGetField(field);
<span class="fc bfc" id="L231" title="All 2 branches covered.">        }</span>
<span class="fc" id="L232">      }</span>
    }
<span class="fc" id="L234">    if (clazz.getSuperclass() != null) {</span>
      addFields(clazz.getSuperclass());
    }
<span class="fc" id="L237">  }</span>
<span class="fc" id="L238"></span>
<span class="fc" id="L239">  private void addSetField(Field field) {</span>
    setMethods.put(field.getName(), new SetFieldInvoker(field));
    setTypes.put(field.getName(), field.getType());
<span class="fc" id="L242">  }</span>
<span class="fc" id="L243"></span>
<span class="fc" id="L244">  private void addGetField(Field field) {</span>
    getMethods.put(field.getName(), new GetFieldInvoker(field));
    getTypes.put(field.getName(), field.getType());
  }

  /**
   * This method returns an array containing all methods declared in this class and any superclass. We use this method,
   * instead of the simpler Class.getMethods(), because we want to look for private methods as well.
   *
   * @param cls
   *          The class
<span class="fc" id="L255">   * @return An array containing all methods in this class</span>
<span class="fc" id="L256">   */</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">  private Method[] getClassMethods(Class cls) {</span>
<span class="fc" id="L258">    HashMap uniqueMethods = new HashMap();</span>
    Class currentClass = cls;
    while (currentClass != null) {
      addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());
<span class="fc" id="L262"></span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">      // we also need to look for interface methods -</span>
<span class="fc" id="L264">      // because the class may be abstract</span>
      Class[] interfaces = currentClass.getInterfaces();
      for (int i = 0; i &lt; interfaces.length; i++) {
<span class="fc" id="L267">        addUniqueMethods(uniqueMethods, interfaces[i].getMethods());</span>
<span class="fc" id="L268">      }</span>

<span class="fc" id="L270">      currentClass = currentClass.getSuperclass();</span>
    }
<span class="fc" id="L272"></span>
    Collection methods = uniqueMethods.values();

    return (Method[]) methods.toArray(new Method[methods.size()]);
<span class="fc bfc" id="L276" title="All 2 branches covered.">  }</span>
<span class="fc bfc" id="L277" title="All 2 branches covered."></span>
<span class="fc" id="L278">  private void addUniqueMethods(HashMap uniqueMethods, Method[] methods) {</span>
    for (Method currentMethod : methods) {
      if (!currentMethod.isBridge()) {
        String signature = getSignature(currentMethod);
<span class="fc bfc" id="L282" title="All 2 branches covered.">        // check to see if the method is already known</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        // if it is known, then an extended class must have</span>
        // overridden a method
<span class="fc" id="L285">        if (!uniqueMethods.containsKey(signature)) {</span>
<span class="nc" id="L286">          if (canAccessPrivateMethods()) {</span>
            try {
<span class="fc" id="L288">              currentMethod.setAccessible(true);</span>
            } catch (Exception e) {
              // Ignored. This is only a final precaution, nothing we can do.
<span class="fc" id="L291">            }</span>
          }

          uniqueMethods.put(signature, currentMethod);
<span class="fc" id="L295">        }</span>
      }
    }
<span class="fc" id="L298">  }</span>
<span class="fc" id="L299"></span>
<span class="fc" id="L300">  private String getSignature(Method method) {</span>
    StringBuffer sb = new StringBuffer();
<span class="fc bfc" id="L302" title="All 2 branches covered.">    sb.append(method.getName());</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">    Class[] parameters = method.getParameterTypes();</span>
<span class="fc" id="L304"></span>
    for (int i = 0; i &lt; parameters.length; i++) {
<span class="fc" id="L306">      if (i == 0) {</span>
        sb.append(':');
<span class="fc" id="L308">      } else {</span>
        sb.append(',');
      }
<span class="fc" id="L311">      sb.append(parameters[i].getName());</span>
    }

    return sb.toString();
<span class="fc bfc" id="L315" title="All 2 branches covered.">  }</span>
<span class="fc" id="L316"></span>
<span class="pc bpc" id="L317" title="1 of 4 branches missed.">  private static String dropCase(String name) {</span>
<span class="fc" id="L318">    if (name.startsWith(&quot;is&quot;)) {</span>
      name = name.substring(2);
<span class="nc" id="L320">    } else if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {</span>
      name = name.substring(3);
    } else {
<span class="pc bpc" id="L323" title="3 of 6 branches missed.">      throw new ProbeException(&quot;Error parsing property name '&quot; + name + &quot;'.  Didn't start with 'is', 'get' or 'set'.&quot;);</span>
<span class="fc" id="L324">    }</span>

    if (name.length() == 1 || (name.length() &gt; 1 &amp;&amp; !Character.isUpperCase(name.charAt(1)))) {
<span class="fc" id="L327">      name = name.substring(0, 1).toLowerCase(Locale.US) + name.substring(1);</span>
    }

    return name;
  }
<span class="fc" id="L332"></span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">  private static boolean canAccessPrivateMethods() {</span>
<span class="nc" id="L334">    try {</span>
      SecurityManager securityManager = System.getSecurityManager();
<span class="nc" id="L336">      if (null != securityManager) {</span>
<span class="nc" id="L337">        securityManager.checkPermission(new ReflectPermission(&quot;suppressAccessChecks&quot;));</span>
<span class="fc" id="L338">      }</span>
<span class="fc" id="L339">    } catch (SecurityException e) {</span>
      return false;
    }
    return true;
  }

  /**
   * Gets the name of the class the instance provides information for
   *
<span class="nc" id="L348">   * @return The class name</span>
   */
  public String getClassName() {
    return className;
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">  }</span>

<span class="fc" id="L354">  public Object instantiateClass() {</span>
<span class="nc" id="L355">    if (defaultConstructor != null) {</span>
<span class="nc" id="L356">      try {</span>
        return defaultConstructor.newInstance(null);
      } catch (Exception e) {
<span class="nc" id="L359">        throw new RuntimeException(&quot;Error instantiating class. Cause: &quot; + e, e);</span>
      }
    } else {
      throw new RuntimeException(&quot;Error instantiating class.  There is no default constructor for class &quot; + className);
    }
  }

  /**
   * Gets the setter for a property as a Method object
   *
   * @param propertyName
   *          - the property
<span class="fc" id="L371">   * @return The Method</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">   */</span>
<span class="nc" id="L373">  public Method getSetter(String propertyName) {</span>
    Invoker method = (Invoker) setMethods.get(propertyName);
    if (method == null) {
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">      throw new ProbeException(&quot;There is no WRITEABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className</span>
<span class="nc" id="L377">          + &quot;'&quot;);</span>
    }
    if (!(method instanceof MethodInvoker)) {
<span class="fc" id="L380">      throw new ProbeException(&quot;Can't get setter method because '&quot; + propertyName + &quot;' is a field in class '&quot;</span>
          + className + &quot;'&quot;);
    }
    return ((MethodInvoker) method).getMethod();
  }

  /**
   * Gets the getter for a property as a Method object
   *
   * @param propertyName
   *          - the property
<span class="fc" id="L391">   * @return The Method</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">   */</span>
<span class="nc" id="L393">  public Method getGetter(String propertyName) {</span>
    Invoker method = (Invoker) getMethods.get(propertyName);
    if (method == null) {
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">      throw new ProbeException(&quot;There is no READABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className</span>
<span class="nc" id="L397">          + &quot;'&quot;);</span>
    }
    if (!(method instanceof MethodInvoker)) {
<span class="fc" id="L400">      throw new ProbeException(&quot;Can't get getter method because '&quot; + propertyName + &quot;' is a field in class '&quot;</span>
          + className + &quot;'&quot;);
    }
    return ((MethodInvoker) method).getMethod();
<span class="fc" id="L404">  }</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed."></span>
<span class="nc" id="L406">  public Invoker getSetInvoker(String propertyName) {</span>
    Invoker method = (Invoker) setMethods.get(propertyName);
    if (method == null) {
<span class="fc" id="L409">      throw new ProbeException(&quot;There is no WRITEABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className</span>
          + &quot;'&quot;);
    }
    return method;
<span class="fc" id="L413">  }</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed."></span>
<span class="nc" id="L415">  public Invoker getGetInvoker(String propertyName) {</span>
    Invoker method = (Invoker) getMethods.get(propertyName);
    if (method == null) {
<span class="fc" id="L418">      throw new ProbeException(&quot;There is no READABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className</span>
          + &quot;'&quot;);
    }
    return method;
  }

  /**
   * Gets the type for a property setter
   *
   * @param propertyName
   *          - the name of the property
<span class="fc" id="L429">   * @return The Class of the propery setter</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">   */</span>
<span class="fc" id="L431">  public Class getSetterType(String propertyName) {</span>
    Class clazz = (Class) setTypes.get(propertyName);
    if (clazz == null) {
<span class="fc" id="L434">      throw new ProbeException(&quot;There is no WRITEABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className</span>
          + &quot;'&quot;);
    }
    return clazz;
  }

  /**
   * Gets the type for a property getter
   *
   * @param propertyName
   *          - the name of the property
<span class="fc" id="L445">   * @return The Class of the propery getter</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">   */</span>
<span class="nc" id="L447">  public Class getGetterType(String propertyName) {</span>
    Class clazz = (Class) getTypes.get(propertyName);
    if (clazz == null) {
<span class="fc" id="L450">      throw new ProbeException(&quot;There is no READABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className</span>
          + &quot;'&quot;);
    }
    return clazz;
  }

  /**
   * Gets an array of the readable properties for an object
   *
<span class="nc" id="L459">   * @return The array</span>
   */
  public String[] getReadablePropertyNames() {
    return readablePropertyNames;
  }

  /**
   * Gets an array of the writeable properties for an object
   *
<span class="fc" id="L468">   * @return The array</span>
   */
  public String[] getWriteablePropertyNames() {
    return writeablePropertyNames;
  }

  /**
   * Check to see if a class has a writeable property by name
   *
   * @param propertyName
   *          - the name of the property to check
<span class="fc" id="L479">   * @return True if the object has a writeable property by the name</span>
   */
  public boolean hasWritableProperty(String propertyName) {
    return setMethods.keySet().contains(propertyName);
  }

  /**
   * Check to see if a class has a readable property by name
   *
   * @param propertyName
   *          - the name of the property to check
<span class="fc" id="L490">   * @return True if the object has a readable property by the name</span>
   */
  public boolean hasReadableProperty(String propertyName) {
    return getMethods.keySet().contains(propertyName);
  }

  /**
   * Tells us if the class passed in is a knwon common type
   *
   * @param clazz
   *          The class to check
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">   * @return True if the class is known</span>
<span class="nc" id="L502">   */</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">  public static boolean isKnownType(Class clazz) {</span>
<span class="nc" id="L504">    if (SIMPLE_TYPE_SET.contains(clazz)) {</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">      return true;</span>
<span class="nc" id="L506">    } else if (Collection.class.isAssignableFrom(clazz)) {</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">      return true;</span>
<span class="nc" id="L508">    } else if (Map.class.isAssignableFrom(clazz)) {</span>
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">      return true;</span>
<span class="nc" id="L510">    } else if (List.class.isAssignableFrom(clazz)) {</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">      return true;</span>
<span class="nc" id="L512">    } else if (Set.class.isAssignableFrom(clazz)) {</span>
      return true;
<span class="fc" id="L514">    } else if (Iterator.class.isAssignableFrom(clazz)) {</span>
      return true;
    } else {
      return false;
    }
  }

  /**
   * Gets an instance of ClassInfo for the specified class.
   *
   * @param clazz
   *          The class for which to lookup the method cache.
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">   * @return The method cache for the class</span>
<span class="fc" id="L527">   */</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">  public static ClassInfo getInstance(Class clazz) {</span>
<span class="fc" id="L529">    if (cacheEnabled) {</span>
<span class="fc" id="L530">      ClassInfo cached = (ClassInfo) CLASS_INFO_MAP.get(clazz);</span>
      if (cached == null) {
<span class="fc" id="L532">        cached = new ClassInfo(clazz);</span>
        CLASS_INFO_MAP.put(clazz, cached);
<span class="nc" id="L534">      }</span>
      return cached;
    } else {
      return new ClassInfo(clazz);
    }
<span class="fc" id="L539">  }</span>
<span class="fc" id="L540"></span>
  public static void setCacheEnabled(boolean cacheEnabled) {
    ClassInfo.cacheEnabled = cacheEnabled;
  }

  /**
   * Examines a Throwable object and gets it's root cause
   *
   * @param t
   *          - the exception to examine
<span class="fc" id="L550">   * @return The root cause</span>
   */
<span class="fc bfc" id="L552" title="All 2 branches covered.">  public static Throwable unwrapThrowable(Throwable t) {</span>
<span class="fc" id="L553">    Throwable t2 = t;</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">    while (true) {</span>
<span class="fc" id="L555">      if (t2 instanceof InvocationTargetException) {</span>
        t2 = ((InvocationTargetException) t).getTargetException();
<span class="fc" id="L557">      } else if (t2 instanceof UndeclaredThrowableException) {</span>
        t2 = ((UndeclaredThrowableException) t).getUndeclaredThrowable();
      } else {
        return t2;
      }
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>