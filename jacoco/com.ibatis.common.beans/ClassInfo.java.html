<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassInfo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.common.beans</a> &gt; <span class="el_source">ClassInfo.java</span></div><h1>ClassInfo.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2004-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.common.beans;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ReflectPermission;
import java.lang.reflect.UndeclaredThrowableException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.util.concurrent.ConcurrentHashMap;

/**
 * This class represents a cached set of class definition information that allows for easy mapping between property
 * names and getter/setter methods.
 */
public class ClassInfo {

  /** The cache enabled. */
<span class="fc" id="L51">  private static boolean cacheEnabled = true;</span>

  /** The Constant EMPTY_STRING_ARRAY. */
<span class="fc" id="L54">  private static final String[] EMPTY_STRING_ARRAY = new String[0];</span>

  /** The Constant SIMPLE_TYPE_SET. */
<span class="fc" id="L57">  private static final Set SIMPLE_TYPE_SET = new HashSet();</span>

  /** The Constant CLASS_INFO_MAP. */
<span class="fc" id="L60">  private static final Map&lt;Class, ClassInfo&gt; CLASS_INFO_MAP = new ConcurrentHashMap&lt;Class, ClassInfo&gt;();</span>

  /** The class name. */
  private String className;

  /** The readable property names. */
<span class="fc" id="L66">  private String[] readablePropertyNames = EMPTY_STRING_ARRAY;</span>

  /** The writeable property names. */
<span class="fc" id="L69">  private String[] writeablePropertyNames = EMPTY_STRING_ARRAY;</span>

  /** The set methods. */
<span class="fc" id="L72">  private HashMap setMethods = new HashMap();</span>

  /** The get methods. */
<span class="fc" id="L75">  private HashMap getMethods = new HashMap();</span>

  /** The set types. */
<span class="fc" id="L78">  private HashMap setTypes = new HashMap();</span>

  /** The get types. */
<span class="fc" id="L81">  private HashMap getTypes = new HashMap();</span>

  /** The default constructor. */
  private Constructor defaultConstructor;

  static {
<span class="fc" id="L87">    SIMPLE_TYPE_SET.add(String.class);</span>
<span class="fc" id="L88">    SIMPLE_TYPE_SET.add(Byte.class);</span>
<span class="fc" id="L89">    SIMPLE_TYPE_SET.add(Short.class);</span>
<span class="fc" id="L90">    SIMPLE_TYPE_SET.add(Character.class);</span>
<span class="fc" id="L91">    SIMPLE_TYPE_SET.add(Integer.class);</span>
<span class="fc" id="L92">    SIMPLE_TYPE_SET.add(Long.class);</span>
<span class="fc" id="L93">    SIMPLE_TYPE_SET.add(Float.class);</span>
<span class="fc" id="L94">    SIMPLE_TYPE_SET.add(Double.class);</span>
<span class="fc" id="L95">    SIMPLE_TYPE_SET.add(Boolean.class);</span>
<span class="fc" id="L96">    SIMPLE_TYPE_SET.add(Date.class);</span>
<span class="fc" id="L97">    SIMPLE_TYPE_SET.add(Class.class);</span>
<span class="fc" id="L98">    SIMPLE_TYPE_SET.add(BigInteger.class);</span>
<span class="fc" id="L99">    SIMPLE_TYPE_SET.add(BigDecimal.class);</span>

<span class="fc" id="L101">    SIMPLE_TYPE_SET.add(Collection.class);</span>
<span class="fc" id="L102">    SIMPLE_TYPE_SET.add(Set.class);</span>
<span class="fc" id="L103">    SIMPLE_TYPE_SET.add(Map.class);</span>
<span class="fc" id="L104">    SIMPLE_TYPE_SET.add(List.class);</span>
<span class="fc" id="L105">    SIMPLE_TYPE_SET.add(HashMap.class);</span>
<span class="fc" id="L106">    SIMPLE_TYPE_SET.add(TreeMap.class);</span>
<span class="fc" id="L107">    SIMPLE_TYPE_SET.add(ArrayList.class);</span>
<span class="fc" id="L108">    SIMPLE_TYPE_SET.add(LinkedList.class);</span>
<span class="fc" id="L109">    SIMPLE_TYPE_SET.add(HashSet.class);</span>
<span class="fc" id="L110">    SIMPLE_TYPE_SET.add(TreeSet.class);</span>
<span class="fc" id="L111">    SIMPLE_TYPE_SET.add(Vector.class);</span>
<span class="fc" id="L112">    SIMPLE_TYPE_SET.add(Hashtable.class);</span>
<span class="fc" id="L113">    SIMPLE_TYPE_SET.add(Enumeration.class);</span>
<span class="fc" id="L114">  }</span>

  /**
   * Instantiates a new class info.
   *
   * @param clazz
   *          the clazz
   */
<span class="fc" id="L122">  private ClassInfo(Class clazz) {</span>
<span class="fc" id="L123">    className = clazz.getName();</span>
<span class="fc" id="L124">    addDefaultConstructor(clazz);</span>
<span class="fc" id="L125">    addGetMethods(clazz);</span>
<span class="fc" id="L126">    addSetMethods(clazz);</span>
<span class="fc" id="L127">    addFields(clazz);</span>
<span class="fc" id="L128">    readablePropertyNames = (String[]) getMethods.keySet().toArray(new String[getMethods.keySet().size()]);</span>
<span class="fc" id="L129">    writeablePropertyNames = (String[]) setMethods.keySet().toArray(new String[setMethods.keySet().size()]);</span>
<span class="fc" id="L130">  }</span>

  /**
   * Adds the default constructor.
   *
   * @param clazz
   *          the clazz
   */
  private void addDefaultConstructor(Class clazz) {
<span class="fc" id="L139">    Constructor[] consts = clazz.getDeclaredConstructors();</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">    for (int i = 0; i &lt; consts.length; i++) {</span>
<span class="fc" id="L141">      Constructor constructor = consts[i];</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">      if (constructor.getParameterTypes().length == 0) {</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (canAccessPrivateMethods()) {</span>
          try {
<span class="fc" id="L145">            constructor.setAccessible(true);</span>
<span class="nc" id="L146">          } catch (Exception e) {</span>
            // Ignored. This is only a final precaution, nothing we can do.
<span class="fc" id="L148">          }</span>
        }
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        if (constructor.isAccessible()) {</span>
<span class="fc" id="L151">          this.defaultConstructor = constructor;</span>
        }
      }
    }
<span class="fc" id="L155">  }</span>

  /**
   * Adds the get methods.
   *
   * @param cls
   *          the cls
   */
  private void addGetMethods(Class cls) {
<span class="fc" id="L164">    Method[] methods = getClassMethods(cls);</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">    for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="fc" id="L166">      Method method = methods[i];</span>
<span class="fc" id="L167">      String name = method.getName();</span>
<span class="fc bfc" id="L168" title="All 4 branches covered.">      if (name.startsWith(&quot;get&quot;) &amp;&amp; name.length() &gt; 3) {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (method.getParameterTypes().length == 0) {</span>
<span class="fc" id="L170">          name = dropCase(name);</span>
<span class="fc" id="L171">          addGetMethod(name, method);</span>
        }
<span class="pc bpc" id="L173" title="1 of 4 branches missed.">      } else if (name.startsWith(&quot;is&quot;) &amp;&amp; name.length() &gt; 2) {</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        if (method.getParameterTypes().length == 0) {</span>
<span class="fc" id="L175">          name = dropCase(name);</span>
<span class="fc" id="L176">          addGetMethod(name, method);</span>
        }
      }
    }
<span class="fc" id="L180">  }</span>

  /**
   * Adds the get method.
   *
   * @param name
   *          the name
   * @param method
   *          the method
   */
  private void addGetMethod(String name, Method method) {
<span class="fc" id="L191">    getMethods.put(name, new MethodInvoker(method));</span>
<span class="fc" id="L192">    getTypes.put(name, method.getReturnType());</span>
<span class="fc" id="L193">  }</span>

  /**
   * Adds the set methods.
   *
   * @param cls
   *          the cls
   */
  private void addSetMethods(Class cls) {
<span class="fc" id="L202">    Map conflictingSetters = new HashMap();</span>
<span class="fc" id="L203">    Method[] methods = getClassMethods(cls);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">    for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="fc" id="L205">      Method method = methods[i];</span>
<span class="fc" id="L206">      String name = method.getName();</span>
<span class="fc bfc" id="L207" title="All 4 branches covered.">      if (name.startsWith(&quot;set&quot;) &amp;&amp; name.length() &gt; 3) {</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (method.getParameterTypes().length == 1) {</span>
<span class="fc" id="L209">          name = dropCase(name);</span>
          // /------------
<span class="fc" id="L211">          addSetterConflict(conflictingSetters, name, method);</span>
          // addSetMethod(name, method);
          // /------------
        }
      }
    }
<span class="fc" id="L217">    resolveSetterConflicts(conflictingSetters);</span>
<span class="fc" id="L218">  }</span>

  /**
   * Adds the setter conflict.
   *
   * @param conflictingSetters
   *          the conflicting setters
   * @param name
   *          the name
   * @param method
   *          the method
   */
  private void addSetterConflict(Map conflictingSetters, String name, Method method) {
<span class="fc" id="L231">    List list = (List) conflictingSetters.get(name);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">    if (list == null) {</span>
<span class="fc" id="L233">      list = new ArrayList();</span>
<span class="fc" id="L234">      conflictingSetters.put(name, list);</span>
    }
<span class="fc" id="L236">    list.add(method);</span>
<span class="fc" id="L237">  }</span>

  /**
   * Resolve setter conflicts.
   *
   * @param conflictingSetters
   *          the conflicting setters
   */
  private void resolveSetterConflicts(Map conflictingSetters) {
<span class="fc bfc" id="L246" title="All 2 branches covered.">    for (Iterator propNames = conflictingSetters.keySet().iterator(); propNames.hasNext();) {</span>
<span class="fc" id="L247">      String propName = (String) propNames.next();</span>
<span class="fc" id="L248">      List setters = (List) conflictingSetters.get(propName);</span>
<span class="fc" id="L249">      Method firstMethod = (Method) setters.get(0);</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">      if (setters.size() == 1) {</span>
<span class="fc" id="L251">        addSetMethod(propName, firstMethod);</span>
      } else {
<span class="fc" id="L253">        Class expectedType = (Class) getTypes.get(propName);</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">        if (expectedType == null) {</span>
<span class="fc" id="L255">          throw new RuntimeException(&quot;Illegal overloaded setter method with ambiguous type for property &quot; + propName</span>
<span class="fc" id="L256">              + &quot; in class &quot; + firstMethod.getDeclaringClass() + &quot;.  This breaks the JavaBeans &quot;</span>
              + &quot;specification and can cause unpredicatble results.&quot;);
        } else {
<span class="fc" id="L259">          Iterator methods = setters.iterator();</span>
<span class="fc" id="L260">          Method setter = null;</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">          while (methods.hasNext()) {</span>
<span class="fc" id="L262">            Method method = (Method) methods.next();</span>
<span class="pc bpc" id="L263" title="1 of 4 branches missed.">            if (method.getParameterTypes().length == 1 &amp;&amp; expectedType.equals(method.getParameterTypes()[0])) {</span>
<span class="fc" id="L264">              setter = method;</span>
<span class="fc" id="L265">              break;</span>
            }
<span class="fc" id="L267">          }</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">          if (setter == null) {</span>
<span class="fc" id="L269">            throw new RuntimeException(&quot;Illegal overloaded setter method with ambiguous type for property &quot; + propName</span>
<span class="fc" id="L270">                + &quot; in class &quot; + firstMethod.getDeclaringClass() + &quot;.  This breaks the JavaBeans &quot;</span>
                + &quot;specification and can cause unpredicatble results.&quot;);
          }
<span class="fc" id="L273">          addSetMethod(propName, setter);</span>
        }
      }
<span class="fc" id="L276">    }</span>
<span class="fc" id="L277">  }</span>

  /**
   * Adds the set method.
   *
   * @param name
   *          the name
   * @param method
   *          the method
   */
  private void addSetMethod(String name, Method method) {
<span class="fc" id="L288">    setMethods.put(name, new MethodInvoker(method));</span>
<span class="fc" id="L289">    setTypes.put(name, method.getParameterTypes()[0]);</span>
<span class="fc" id="L290">  }</span>

  /**
   * Adds the fields.
   *
   * @param clazz
   *          the clazz
   */
  private void addFields(Class clazz) {
<span class="fc" id="L299">    Field[] fields = clazz.getDeclaredFields();</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">    for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="fc" id="L301">      Field field = fields[i];</span>
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">      if (canAccessPrivateMethods()) {</span>
        try {
<span class="fc" id="L304">          field.setAccessible(true);</span>
<span class="nc" id="L305">        } catch (Exception e) {</span>
          // Ignored. This is only a final precaution, nothing we can do.
<span class="fc" id="L307">        }</span>
      }
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">      if (field.isAccessible()) {</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (!setMethods.containsKey(field.getName())) {</span>
<span class="fc" id="L311">          addSetField(field);</span>
        }
<span class="fc bfc" id="L313" title="All 2 branches covered.">        if (!getMethods.containsKey(field.getName())) {</span>
<span class="fc" id="L314">          addGetField(field);</span>
        }
      }
    }
<span class="fc bfc" id="L318" title="All 2 branches covered.">    if (clazz.getSuperclass() != null) {</span>
<span class="fc" id="L319">      addFields(clazz.getSuperclass());</span>
    }
<span class="fc" id="L321">  }</span>

  /**
   * Adds the set field.
   *
   * @param field
   *          the field
   */
  private void addSetField(Field field) {
<span class="fc" id="L330">    setMethods.put(field.getName(), new SetFieldInvoker(field));</span>
<span class="fc" id="L331">    setTypes.put(field.getName(), field.getType());</span>
<span class="fc" id="L332">  }</span>

  /**
   * Adds the get field.
   *
   * @param field
   *          the field
   */
  private void addGetField(Field field) {
<span class="fc" id="L341">    getMethods.put(field.getName(), new GetFieldInvoker(field));</span>
<span class="fc" id="L342">    getTypes.put(field.getName(), field.getType());</span>
<span class="fc" id="L343">  }</span>

  /**
   * This method returns an array containing all methods declared in this class and any superclass. We use this method,
   * instead of the simpler Class.getMethods(), because we want to look for private methods as well.
   *
   * @param cls
   *          The class
   * @return An array containing all methods in this class
   */
  private Method[] getClassMethods(Class cls) {
<span class="fc" id="L354">    HashMap uniqueMethods = new HashMap();</span>
<span class="fc" id="L355">    Class currentClass = cls;</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">    while (currentClass != null) {</span>
<span class="fc" id="L357">      addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());</span>

      // we also need to look for interface methods -
      // because the class may be abstract
<span class="fc" id="L361">      Class[] interfaces = currentClass.getInterfaces();</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">      for (int i = 0; i &lt; interfaces.length; i++) {</span>
<span class="fc" id="L363">        addUniqueMethods(uniqueMethods, interfaces[i].getMethods());</span>
      }

<span class="fc" id="L366">      currentClass = currentClass.getSuperclass();</span>
<span class="fc" id="L367">    }</span>

<span class="fc" id="L369">    Collection methods = uniqueMethods.values();</span>

<span class="fc" id="L371">    return (Method[]) methods.toArray(new Method[methods.size()]);</span>
  }

  /**
   * Adds the unique methods.
   *
   * @param uniqueMethods
   *          the unique methods
   * @param methods
   *          the methods
   */
  private void addUniqueMethods(HashMap uniqueMethods, Method[] methods) {
<span class="fc bfc" id="L383" title="All 2 branches covered.">    for (Method currentMethod : methods) {</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">      if (!currentMethod.isBridge()) {</span>
<span class="fc" id="L385">        String signature = getSignature(currentMethod);</span>
        // check to see if the method is already known
        // if it is known, then an extended class must have
        // overridden a method
<span class="fc bfc" id="L389" title="All 2 branches covered.">        if (!uniqueMethods.containsKey(signature)) {</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">          if (canAccessPrivateMethods()) {</span>
            try {
<span class="fc" id="L392">              currentMethod.setAccessible(true);</span>
<span class="nc" id="L393">            } catch (Exception e) {</span>
              // Ignored. This is only a final precaution, nothing we can do.
<span class="fc" id="L395">            }</span>
          }

<span class="fc" id="L398">          uniqueMethods.put(signature, currentMethod);</span>
        }
      }
    }
<span class="fc" id="L402">  }</span>

  /**
   * Gets the signature.
   *
   * @param method
   *          the method
   * @return the signature
   */
  private String getSignature(Method method) {
<span class="fc" id="L412">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L413">    sb.append(method.getName());</span>
<span class="fc" id="L414">    Class[] parameters = method.getParameterTypes();</span>

<span class="fc bfc" id="L416" title="All 2 branches covered.">    for (int i = 0; i &lt; parameters.length; i++) {</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">      if (i == 0) {</span>
<span class="fc" id="L418">        sb.append(':');</span>
      } else {
<span class="fc" id="L420">        sb.append(',');</span>
      }
<span class="fc" id="L422">      sb.append(parameters[i].getName());</span>
    }

<span class="fc" id="L425">    return sb.toString();</span>
  }

  /**
   * Drop case.
   *
   * @param name
   *          the name
   * @return the string
   */
  private static String dropCase(String name) {
<span class="fc bfc" id="L436" title="All 2 branches covered.">    if (name.startsWith(&quot;is&quot;)) {</span>
<span class="fc" id="L437">      name = name.substring(2);</span>
<span class="pc bpc" id="L438" title="1 of 4 branches missed.">    } else if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {</span>
<span class="fc" id="L439">      name = name.substring(3);</span>
    } else {
<span class="nc" id="L441">      throw new ProbeException(&quot;Error parsing property name '&quot; + name + &quot;'.  Didn't start with 'is', 'get' or 'set'.&quot;);</span>
    }

<span class="pc bpc" id="L444" title="3 of 6 branches missed.">    if (name.length() == 1 || (name.length() &gt; 1 &amp;&amp; !Character.isUpperCase(name.charAt(1)))) {</span>
<span class="fc" id="L445">      name = name.substring(0, 1).toLowerCase(Locale.US) + name.substring(1);</span>
    }

<span class="fc" id="L448">    return name;</span>
  }

  /**
   * Can access private methods.
   *
   * @return true, if successful
   */
  private static boolean canAccessPrivateMethods() {
    try {
<span class="fc" id="L458">      SecurityManager securityManager = System.getSecurityManager();</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">      if (null != securityManager) {</span>
<span class="nc" id="L460">        securityManager.checkPermission(new ReflectPermission(&quot;suppressAccessChecks&quot;));</span>
      }
<span class="nc" id="L462">    } catch (SecurityException e) {</span>
<span class="nc" id="L463">      return false;</span>
<span class="fc" id="L464">    }</span>
<span class="fc" id="L465">    return true;</span>
  }

  /**
   * Gets the name of the class the instance provides information for.
   *
   * @return The class name
   */
  public String getClassName() {
<span class="nc" id="L474">    return className;</span>
  }

  /**
   * Instantiate class.
   *
   * @return the object
   */
  public Object instantiateClass() {
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">    if (defaultConstructor != null) {</span>
      try {
<span class="fc" id="L485">        return defaultConstructor.newInstance(null);</span>
<span class="nc" id="L486">      } catch (Exception e) {</span>
<span class="nc" id="L487">        throw new RuntimeException(&quot;Error instantiating class. Cause: &quot; + e, e);</span>
      }
    } else {
<span class="nc" id="L490">      throw new RuntimeException(&quot;Error instantiating class.  There is no default constructor for class &quot; + className);</span>
    }
  }

  /**
   * Gets the setter for a property as a Method object.
   *
   * @param propertyName
   *          - the property
   * @return The Method
   */
  public Method getSetter(String propertyName) {
<span class="fc" id="L502">    Invoker method = (Invoker) setMethods.get(propertyName);</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L504">      throw new ProbeException(</span>
          &quot;There is no WRITEABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);
    }
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">    if (!(method instanceof MethodInvoker)) {</span>
<span class="nc" id="L508">      throw new ProbeException(</span>
          &quot;Can't get setter method because '&quot; + propertyName + &quot;' is a field in class '&quot; + className + &quot;'&quot;);
    }
<span class="fc" id="L511">    return ((MethodInvoker) method).getMethod();</span>
  }

  /**
   * Gets the getter for a property as a Method object.
   *
   * @param propertyName
   *          - the property
   * @return The Method
   */
  public Method getGetter(String propertyName) {
<span class="fc" id="L522">    Invoker method = (Invoker) getMethods.get(propertyName);</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L524">      throw new ProbeException(</span>
          &quot;There is no READABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);
    }
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">    if (!(method instanceof MethodInvoker)) {</span>
<span class="nc" id="L528">      throw new ProbeException(</span>
          &quot;Can't get getter method because '&quot; + propertyName + &quot;' is a field in class '&quot; + className + &quot;'&quot;);
    }
<span class="fc" id="L531">    return ((MethodInvoker) method).getMethod();</span>
  }

  /**
   * Gets the sets the invoker.
   *
   * @param propertyName
   *          the property name
   * @return the sets the invoker
   */
  public Invoker getSetInvoker(String propertyName) {
<span class="fc" id="L542">    Invoker method = (Invoker) setMethods.get(propertyName);</span>
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L544">      throw new ProbeException(</span>
          &quot;There is no WRITEABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);
    }
<span class="fc" id="L547">    return method;</span>
  }

  /**
   * Gets the gets the invoker.
   *
   * @param propertyName
   *          the property name
   * @return the gets the invoker
   */
  public Invoker getGetInvoker(String propertyName) {
<span class="fc" id="L558">    Invoker method = (Invoker) getMethods.get(propertyName);</span>
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L560">      throw new ProbeException(</span>
          &quot;There is no READABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);
    }
<span class="fc" id="L563">    return method;</span>
  }

  /**
   * Gets the type for a property setter.
   *
   * @param propertyName
   *          - the name of the property
   * @return The Class of the propery setter
   */
  public Class getSetterType(String propertyName) {
<span class="fc" id="L574">    Class clazz = (Class) setTypes.get(propertyName);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">    if (clazz == null) {</span>
<span class="fc" id="L576">      throw new ProbeException(</span>
          &quot;There is no WRITEABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);
    }
<span class="fc" id="L579">    return clazz;</span>
  }

  /**
   * Gets the type for a property getter.
   *
   * @param propertyName
   *          - the name of the property
   * @return The Class of the propery getter
   */
  public Class getGetterType(String propertyName) {
<span class="fc" id="L590">    Class clazz = (Class) getTypes.get(propertyName);</span>
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">    if (clazz == null) {</span>
<span class="nc" id="L592">      throw new ProbeException(</span>
          &quot;There is no READABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);
    }
<span class="fc" id="L595">    return clazz;</span>
  }

  /**
   * Gets an array of the readable properties for an object.
   *
   * @return The array
   */
  public String[] getReadablePropertyNames() {
<span class="nc" id="L604">    return readablePropertyNames;</span>
  }

  /**
   * Gets an array of the writeable properties for an object.
   *
   * @return The array
   */
  public String[] getWriteablePropertyNames() {
<span class="fc" id="L613">    return writeablePropertyNames;</span>
  }

  /**
   * Check to see if a class has a writeable property by name.
   *
   * @param propertyName
   *          - the name of the property to check
   * @return True if the object has a writeable property by the name
   */
  public boolean hasWritableProperty(String propertyName) {
<span class="fc" id="L624">    return setMethods.keySet().contains(propertyName);</span>
  }

  /**
   * Check to see if a class has a readable property by name.
   *
   * @param propertyName
   *          - the name of the property to check
   * @return True if the object has a readable property by the name
   */
  public boolean hasReadableProperty(String propertyName) {
<span class="fc" id="L635">    return getMethods.keySet().contains(propertyName);</span>
  }

  /**
   * Tells us if the class passed in is a knwon common type.
   *
   * @param clazz
   *          The class to check
   * @return True if the class is known
   */
  public static boolean isKnownType(Class clazz) {
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">    if (SIMPLE_TYPE_SET.contains(clazz)) {</span>
<span class="nc" id="L647">      return true;</span>
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">    } else if (Collection.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L649">      return true;</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">    } else if (Map.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L651">      return true;</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">    } else if (List.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L653">      return true;</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">    } else if (Set.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L655">      return true;</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">    } else if (Iterator.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L657">      return true;</span>
    } else {
<span class="fc" id="L659">      return false;</span>
    }
  }

  /**
   * Gets an instance of ClassInfo for the specified class.
   *
   * @param clazz
   *          The class for which to lookup the method cache.
   * @return The method cache for the class
   */
  public static ClassInfo getInstance(Class clazz) {
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">    if (cacheEnabled) {</span>
<span class="fc" id="L672">      ClassInfo cached = (ClassInfo) CLASS_INFO_MAP.get(clazz);</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">      if (cached == null) {</span>
<span class="fc" id="L674">        cached = new ClassInfo(clazz);</span>
<span class="fc" id="L675">        CLASS_INFO_MAP.put(clazz, cached);</span>
      }
<span class="fc" id="L677">      return cached;</span>
    } else {
<span class="nc" id="L679">      return new ClassInfo(clazz);</span>
    }
  }

  /**
   * Sets the cache enabled.
   *
   * @param cacheEnabled
   *          the new cache enabled
   */
  public static void setCacheEnabled(boolean cacheEnabled) {
<span class="fc" id="L690">    ClassInfo.cacheEnabled = cacheEnabled;</span>
<span class="fc" id="L691">  }</span>

  /**
   * Examines a Throwable object and gets it's root cause.
   *
   * @param t
   *          - the exception to examine
   * @return The root cause
   */
  public static Throwable unwrapThrowable(Throwable t) {
<span class="fc" id="L701">    Throwable t2 = t;</span>
    while (true) {
<span class="fc bfc" id="L703" title="All 2 branches covered.">      if (t2 instanceof InvocationTargetException) {</span>
<span class="fc" id="L704">        t2 = ((InvocationTargetException) t).getTargetException();</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">      } else if (t2 instanceof UndeclaredThrowableException) {</span>
<span class="fc" id="L706">        t2 = ((UndeclaredThrowableException) t).getUndeclaredThrowable();</span>
      } else {
<span class="fc" id="L708">        return t2;</span>
      }
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>