<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SimpleDataSource.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.common.jdbc</a> &gt; <span class="el_source">SimpleDataSource.java</span></div><h1>SimpleDataSource.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2004-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.common.jdbc;

import com.ibatis.common.beans.ClassInfo;
import com.ibatis.common.resources.Resources;
import com.ibatis.common.logging.LogFactory;
import com.ibatis.common.logging.Log;

import javax.sql.DataSource;

import java.io.PrintWriter;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.sql.*;
import java.util.*;
import java.util.logging.Logger;

/**
 * This is a simple, synchronous, thread-safe database connection pool.
 * &lt;p/&gt;
 * REQUIRED PROPERTIES ------------------- JDBC.Driver JDBC.ConnectionURL JDBC.Username JDBC.Password
 * &lt;p/&gt;
 * Pool.MaximumActiveConnections Pool.MaximumIdleConnections Pool.MaximumCheckoutTime Pool.TimeToWait Pool.PingQuery
 * Pool.PingEnabled Pool.PingConnectionsOlderThan Pool.PingConnectionsNotUsedFor Pool.QuietMode
<span class="fc" id="L40"> */</span>
public class SimpleDataSource implements DataSource {

  private static final Log log = LogFactory.getLog(SimpleDataSource.class);

  // Required Properties
  private static final String PROP_JDBC_DRIVER = &quot;JDBC.Driver&quot;;
  private static final String PROP_JDBC_URL = &quot;JDBC.ConnectionURL&quot;;
  private static final String PROP_JDBC_USERNAME = &quot;JDBC.Username&quot;;
  private static final String PROP_JDBC_PASSWORD = &quot;JDBC.Password&quot;;
  private static final String PROP_JDBC_DEFAULT_AUTOCOMMIT = &quot;JDBC.DefaultAutoCommit&quot;;

  // Optional Properties
  private static final String PROP_POOL_MAX_ACTIVE_CONN = &quot;Pool.MaximumActiveConnections&quot;;
  private static final String PROP_POOL_MAX_IDLE_CONN = &quot;Pool.MaximumIdleConnections&quot;;
  private static final String PROP_POOL_MAX_CHECKOUT_TIME = &quot;Pool.MaximumCheckoutTime&quot;;
  private static final String PROP_POOL_TIME_TO_WAIT = &quot;Pool.TimeToWait&quot;;
  private static final String PROP_POOL_PING_QUERY = &quot;Pool.PingQuery&quot;;
  private static final String PROP_POOL_PING_CONN_OLDER_THAN = &quot;Pool.PingConnectionsOlderThan&quot;;
  private static final String PROP_POOL_PING_ENABLED = &quot;Pool.PingEnabled&quot;;
  private static final String PROP_POOL_PING_CONN_NOT_USED_FOR = &quot;Pool.PingConnectionsNotUsedFor&quot;;
<span class="fc" id="L61">  private int expectedConnectionTypeCode;</span>
  // Additional Driver Properties prefix
  private static final String ADD_DRIVER_PROPS_PREFIX = &quot;Driver.&quot;;
<span class="fc" id="L64">  private static final int ADD_DRIVER_PROPS_PREFIX_LENGTH = ADD_DRIVER_PROPS_PREFIX.length();</span>
<span class="fc" id="L65"></span>
<span class="fc" id="L66">  // ----- BEGIN: FIELDS LOCKED BY POOL_LOCK -----</span>
<span class="fc" id="L67">  private final Object POOL_LOCK = new Object();</span>
<span class="fc" id="L68">  private List idleConnections = new ArrayList();</span>
<span class="fc" id="L69">  private List activeConnections = new ArrayList();</span>
<span class="fc" id="L70">  private long requestCount = 0;</span>
<span class="fc" id="L71">  private long accumulatedRequestTime = 0;</span>
<span class="fc" id="L72">  private long accumulatedCheckoutTime = 0;</span>
<span class="fc" id="L73">  private long claimedOverdueConnectionCount = 0;</span>
<span class="fc" id="L74">  private long accumulatedCheckoutTimeOfOverdueConnections = 0;</span>
  private long accumulatedWaitTime = 0;
  private long hadToWaitCount = 0;
  private long badConnectionCount = 0;
  // ----- END: FIELDS LOCKED BY POOL_LOCK -----

  // ----- BEGIN: PROPERTY FIELDS FOR CONFIGURATION -----
  private String jdbcDriver;
  private String jdbcUrl;
  private String jdbcUsername;
  private String jdbcPassword;
  private boolean jdbcDefaultAutoCommit;
  private Properties driverProps;
  private boolean useDriverProps;

  private int poolMaximumActiveConnections;
  private int poolMaximumIdleConnections;
  private int poolMaximumCheckoutTime;
  private int poolTimeToWait;
  private String poolPingQuery;
  private boolean poolPingEnabled;
  private int poolPingConnectionsOlderThan;
  private int poolPingConnectionsNotUsedFor;

  // ----- END: PROPERTY FIELDS FOR CONFIGURATION -----

  /**
   * Constructor to allow passing in a map of properties for configuration
   *
<span class="fc" id="L103">   * @param props</span>
<span class="fc" id="L104">   *          - the configuration parameters</span>
<span class="fc" id="L105">   */</span>
  public SimpleDataSource(Map props) {
    initialize(props);
  }
<span class="fc" id="L109"></span>
  private void initialize(Map props) {
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">    try {</span>
<span class="nc" id="L112">      String prop_pool_ping_query = null;</span>

      if (props == null) {
<span class="pc bpc" id="L115" title="2 of 4 branches missed.">        throw new RuntimeException(&quot;SimpleDataSource: The properties map passed to the initializer was null.&quot;);</span>
<span class="pc bpc" id="L116" title="2 of 4 branches missed.">      }</span>
<span class="nc" id="L117"></span>
      if (!(props.containsKey(PROP_JDBC_DRIVER) &amp;&amp; props.containsKey(PROP_JDBC_URL)
          &amp;&amp; props.containsKey(PROP_JDBC_USERNAME) &amp;&amp; props.containsKey(PROP_JDBC_PASSWORD))) {
<span class="fc" id="L120">        throw new RuntimeException(&quot;SimpleDataSource: Some properties were not set.&quot;);</span>
<span class="fc" id="L121">      } else {</span>
<span class="fc" id="L122"></span>
<span class="fc" id="L123">        jdbcDriver = (String) props.get(PROP_JDBC_DRIVER);</span>
        jdbcUrl = (String) props.get(PROP_JDBC_URL);
<span class="fc bfc" id="L125" title="All 2 branches covered.">        jdbcUsername = (String) props.get(PROP_JDBC_USERNAME);</span>
<span class="fc" id="L126">        jdbcPassword = (String) props.get(PROP_JDBC_PASSWORD);</span>

<span class="fc bfc" id="L128" title="All 2 branches covered.">        poolMaximumActiveConnections = props.containsKey(PROP_POOL_MAX_ACTIVE_CONN) ? Integer.parseInt((String) props</span>
<span class="fc" id="L129">            .get(PROP_POOL_MAX_ACTIVE_CONN)) : 10;</span>

<span class="fc bfc" id="L131" title="All 2 branches covered.">        poolMaximumIdleConnections = props.containsKey(PROP_POOL_MAX_IDLE_CONN) ? Integer.parseInt((String) props</span>
<span class="fc" id="L132">            .get(PROP_POOL_MAX_IDLE_CONN)) : 5;</span>

<span class="fc bfc" id="L134" title="All 2 branches covered.">        poolMaximumCheckoutTime = props.containsKey(PROP_POOL_MAX_CHECKOUT_TIME) ? Integer.parseInt((String) props</span>
<span class="fc" id="L135">            .get(PROP_POOL_MAX_CHECKOUT_TIME)) : 20000;</span>

<span class="fc bfc" id="L137" title="All 2 branches covered.">        poolTimeToWait = props.containsKey(PROP_POOL_TIME_TO_WAIT) ? Integer.parseInt((String) props</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">            .get(PROP_POOL_TIME_TO_WAIT)) : 20000;</span>

<span class="fc" id="L140">        poolPingEnabled = props.containsKey(PROP_POOL_PING_ENABLED)</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">            &amp;&amp; Boolean.valueOf((String) props.get(PROP_POOL_PING_ENABLED)).booleanValue();</span>

<span class="fc bfc" id="L143" title="All 2 branches covered.">        prop_pool_ping_query = (String) props.get(PROP_POOL_PING_QUERY);</span>
<span class="fc" id="L144">        poolPingQuery = props.containsKey(PROP_POOL_PING_QUERY) ? prop_pool_ping_query : &quot;NO PING QUERY SET&quot;;</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">        poolPingConnectionsOlderThan = props.containsKey(PROP_POOL_PING_CONN_OLDER_THAN) ? Integer</span>
<span class="fc" id="L147">            .parseInt((String) props.get(PROP_POOL_PING_CONN_OLDER_THAN)) : 0;</span>

<span class="fc bfc" id="L149" title="All 2 branches covered.">        poolPingConnectionsNotUsedFor = props.containsKey(PROP_POOL_PING_CONN_NOT_USED_FOR) ? Integer</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">            .parseInt((String) props.get(PROP_POOL_PING_CONN_NOT_USED_FOR)) : 0;</span>

<span class="fc" id="L152">        jdbcDefaultAutoCommit = props.containsKey(PROP_JDBC_DEFAULT_AUTOCOMMIT)</span>
<span class="fc" id="L153">            &amp;&amp; Boolean.valueOf((String) props.get(PROP_JDBC_DEFAULT_AUTOCOMMIT)).booleanValue();</span>
<span class="fc" id="L154"></span>
<span class="fc" id="L155">        useDriverProps = false;</span>
<span class="fc" id="L156">        Iterator propIter = props.keySet().iterator();</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        driverProps = new Properties();</span>
<span class="fc" id="L158">        driverProps.put(&quot;user&quot;, jdbcUsername);</span>
<span class="fc" id="L159">        driverProps.put(&quot;password&quot;, jdbcPassword);</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        while (propIter.hasNext()) {</span>
<span class="nc" id="L161">          String name = (String) propIter.next();</span>
<span class="nc" id="L162">          String value = (String) props.get(name);</span>
          if (name.startsWith(ADD_DRIVER_PROPS_PREFIX)) {
<span class="fc" id="L164">            driverProps.put(name.substring(ADD_DRIVER_PROPS_PREFIX_LENGTH), value);</span>
            useDriverProps = true;
<span class="fc" id="L166">          }</span>
        }
<span class="fc" id="L168"></span>
        expectedConnectionTypeCode = assembleConnectionTypeCode(jdbcUrl, jdbcUsername, jdbcPassword);
<span class="pc bpc" id="L170" title="5 of 6 branches missed."></span>
<span class="nc" id="L171">        Resources.instantiate(jdbcDriver);</span>

        if (poolPingEnabled &amp;&amp; (!props.containsKey(PROP_POOL_PING_QUERY) || prop_pool_ping_query.trim().length() == 0)) {
          throw new RuntimeException(&quot;SimpleDataSource: property '&quot; + PROP_POOL_PING_ENABLED
              + &quot;' is true, but property '&quot; + PROP_POOL_PING_QUERY + &quot;' is not set correctly.&quot;);
<span class="nc" id="L176">        }</span>
<span class="nc" id="L177">      }</span>
<span class="nc" id="L178"></span>
<span class="fc" id="L179">    } catch (Exception e) {</span>
<span class="fc" id="L180">      log.error(&quot;SimpleDataSource: Error while loading properties. Cause: &quot; + e.toString(), e);</span>
      throw new RuntimeException(&quot;SimpleDataSource: Error while loading properties. Cause: &quot; + e, e);
    }
<span class="fc" id="L183">  }</span>

  private int assembleConnectionTypeCode(String url, String username, String password) {
    return (&quot;&quot; + url + username + password).hashCode();
  }

  /**
<span class="fc" id="L190">   * @see javax.sql.DataSource#getConnection()</span>
   */
  public Connection getConnection() throws SQLException {
    return popConnection(jdbcUsername, jdbcPassword).getProxyConnection();
  }

  /**
<span class="nc" id="L197">   * @see javax.sql.DataSource#getConnection(java.lang.String, java.lang.String)</span>
   */
  public Connection getConnection(String username, String password) throws SQLException {
    return popConnection(username, password).getProxyConnection();
  }

  /**
<span class="nc" id="L204">   * @see javax.sql.DataSource#setLoginTimeout(int)</span>
<span class="nc" id="L205">   */</span>
  public void setLoginTimeout(int loginTimeout) throws SQLException {
    DriverManager.setLoginTimeout(loginTimeout);
  }

  /**
<span class="nc" id="L211">   * @see javax.sql.DataSource#getLoginTimeout()</span>
   */
  public int getLoginTimeout() throws SQLException {
    return DriverManager.getLoginTimeout();
  }

  /**
<span class="nc" id="L218">   * @see javax.sql.DataSource#setLogWriter(java.io.PrintWriter)</span>
<span class="nc" id="L219">   */</span>
  public void setLogWriter(PrintWriter logWriter) throws SQLException {
    DriverManager.setLogWriter(logWriter);
  }

  /**
<span class="nc" id="L225">   * @see javax.sql.DataSource#getLogWriter()</span>
   */
  public PrintWriter getLogWriter() throws SQLException {
    return DriverManager.getLogWriter();
  }

  /**
   * If a connection has not been used in this many milliseconds, ping the database to make sure the connection is still
   * good.
   *
<span class="nc" id="L235">   * @return the number of milliseconds of inactivity that will trigger a ping</span>
   */
  public int getPoolPingConnectionsNotUsedFor() {
    return poolPingConnectionsNotUsedFor;
  }

  /**
   * Getter for the name of the JDBC driver class used
   * 
<span class="nc" id="L244">   * @return The name of the class</span>
   */
  public String getJdbcDriver() {
    return jdbcDriver;
  }

  /**
   * Getter of the JDBC URL used
   * 
<span class="nc" id="L253">   * @return The JDBC URL</span>
   */
  public String getJdbcUrl() {
    return jdbcUrl;
  }

  /**
   * Getter for the JDBC user name used
   * 
<span class="nc" id="L262">   * @return The user name</span>
   */
  public String getJdbcUsername() {
    return jdbcUsername;
  }

  /**
   * Getter for the JDBC password used
   * 
<span class="nc" id="L271">   * @return The password</span>
   */
  public String getJdbcPassword() {
    return jdbcPassword;
  }

  /**
   * Getter for the maximum number of active connections
   * 
<span class="nc" id="L280">   * @return The maximum number of active connections</span>
   */
  public int getPoolMaximumActiveConnections() {
    return poolMaximumActiveConnections;
  }

  /**
   * Getter for the maximum number of idle connections
   * 
<span class="nc" id="L289">   * @return The maximum number of idle connections</span>
   */
  public int getPoolMaximumIdleConnections() {
    return poolMaximumIdleConnections;
  }

  /**
   * Getter for the maximum time a connection can be used before it *may* be given away again.
   * 
<span class="nc" id="L298">   * @return The maximum time</span>
   */
  public int getPoolMaximumCheckoutTime() {
    return poolMaximumCheckoutTime;
  }

  /**
   * Getter for the time to wait before retrying to get a connection
   * 
<span class="nc" id="L307">   * @return The time to wait</span>
   */
  public int getPoolTimeToWait() {
    return poolTimeToWait;
  }

  /**
   * Getter for the query to be used to check a connection
   * 
<span class="nc" id="L316">   * @return The query</span>
   */
  public String getPoolPingQuery() {
    return poolPingQuery;
  }

  /**
   * Getter to tell if we should use the ping query
   * 
<span class="nc" id="L325">   * @return True if we need to check a connection before using it</span>
   */
  public boolean isPoolPingEnabled() {
    return poolPingEnabled;
  }

  /**
   * Getter for the age of connections that should be pinged before using
   * 
<span class="nc" id="L334">   * @return The age</span>
   */
  public int getPoolPingConnectionsOlderThan() {
    return poolPingConnectionsOlderThan;
<span class="fc" id="L338">  }</span>

  private int getExpectedConnectionTypeCode() {
    return expectedConnectionTypeCode;
  }

  /**
   * Getter for the number of connection requests made
   * 
<span class="nc" id="L347">   * @return The number of connection requests made</span>
<span class="nc" id="L348">   */</span>
<span class="nc" id="L349">  public long getRequestCount() {</span>
    synchronized (POOL_LOCK) {
      return requestCount;
    }
  }

  /**
   * Getter for the average time required to get a connection to the database
   * 
<span class="nc" id="L358">   * @return The average time</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">   */</span>
<span class="nc" id="L360">  public long getAverageRequestTime() {</span>
    synchronized (POOL_LOCK) {
      return requestCount == 0 ? 0 : accumulatedRequestTime / requestCount;
    }
  }

  /**
   * Getter for the average time spent waiting for connections that were in use
   * 
<span class="nc" id="L369">   * @return The average time</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">   */</span>
<span class="nc" id="L371">  public long getAverageWaitTime() {</span>
    synchronized (POOL_LOCK) {
      return hadToWaitCount == 0 ? 0 : accumulatedWaitTime / hadToWaitCount;
    }
  }

  /**
   * Getter for the number of requests that had to wait for connections that were in use
   * 
<span class="nc" id="L380">   * @return The number of requests that had to wait</span>
<span class="nc" id="L381">   */</span>
<span class="nc" id="L382">  public long getHadToWaitCount() {</span>
    synchronized (POOL_LOCK) {
      return hadToWaitCount;
    }
  }

  /**
   * Getter for the number of invalid connections that were found in the pool
   * 
<span class="nc" id="L391">   * @return The number of invalid connections</span>
<span class="nc" id="L392">   */</span>
<span class="nc" id="L393">  public long getBadConnectionCount() {</span>
    synchronized (POOL_LOCK) {
      return badConnectionCount;
    }
  }

  /**
   * Getter for the number of connections that were claimed before they were returned
   * 
<span class="nc" id="L402">   * @return The number of connections</span>
<span class="nc" id="L403">   */</span>
<span class="nc" id="L404">  public long getClaimedOverdueConnectionCount() {</span>
    synchronized (POOL_LOCK) {
      return claimedOverdueConnectionCount;
    }
  }

  /**
   * Getter for the average age of overdue connections
   * 
<span class="nc" id="L413">   * @return The average age</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">   */</span>
  public long getAverageOverdueCheckoutTime() {
<span class="nc" id="L416">    synchronized (POOL_LOCK) {</span>
      return claimedOverdueConnectionCount == 0 ? 0 : accumulatedCheckoutTimeOfOverdueConnections
          / claimedOverdueConnectionCount;
    }
  }

  /**
   * Getter for the average age of a connection checkout
   * 
<span class="nc" id="L425">   * @return The average age</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">   */</span>
<span class="nc" id="L427">  public long getAverageCheckoutTime() {</span>
    synchronized (POOL_LOCK) {
      return requestCount == 0 ? 0 : accumulatedCheckoutTime / requestCount;
    }
  }

  /**
   * Returns the status of the connection pool
   * 
<span class="nc" id="L436">   * @return The status</span>
   */
<span class="nc" id="L438">  public String getStatus() {</span>
<span class="nc" id="L439">    StringBuffer buffer = new StringBuffer();</span>
<span class="nc" id="L440"></span>
<span class="nc" id="L441">    buffer.append(&quot;\n===============================================================&quot;);</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">    buffer.append(&quot;\n jdbcDriver                     &quot;).append(jdbcDriver);</span>
<span class="nc" id="L443">    buffer.append(&quot;\n jdbcUrl                        &quot;).append(jdbcUrl);</span>
<span class="nc" id="L444">    buffer.append(&quot;\n jdbcUsername                   &quot;).append(jdbcUsername);</span>
<span class="nc" id="L445">    buffer.append(&quot;\n jdbcPassword                   &quot;).append((jdbcPassword == null ? &quot;NULL&quot; : &quot;************&quot;));</span>
<span class="nc" id="L446">    buffer.append(&quot;\n poolMaxActiveConnections       &quot;).append(poolMaximumActiveConnections);</span>
<span class="nc" id="L447">    buffer.append(&quot;\n poolMaxIdleConnections         &quot;).append(poolMaximumIdleConnections);</span>
<span class="nc" id="L448">    buffer.append(&quot;\n poolMaxCheckoutTime            &quot; + poolMaximumCheckoutTime);</span>
<span class="nc" id="L449">    buffer.append(&quot;\n poolTimeToWait                 &quot; + poolTimeToWait);</span>
<span class="nc" id="L450">    buffer.append(&quot;\n poolPingEnabled                &quot; + poolPingEnabled);</span>
<span class="nc" id="L451">    buffer.append(&quot;\n poolPingQuery                  &quot; + poolPingQuery);</span>
<span class="nc" id="L452">    buffer.append(&quot;\n poolPingConnectionsOlderThan   &quot; + poolPingConnectionsOlderThan);</span>
<span class="nc" id="L453">    buffer.append(&quot;\n poolPingConnectionsNotUsedFor  &quot; + poolPingConnectionsNotUsedFor);</span>
<span class="nc" id="L454">    buffer.append(&quot;\n --------------------------------------------------------------&quot;);</span>
<span class="nc" id="L455">    buffer.append(&quot;\n activeConnections              &quot; + activeConnections.size());</span>
<span class="nc" id="L456">    buffer.append(&quot;\n idleConnections                &quot; + idleConnections.size());</span>
<span class="nc" id="L457">    buffer.append(&quot;\n requestCount                   &quot; + getRequestCount());</span>
<span class="nc" id="L458">    buffer.append(&quot;\n averageRequestTime             &quot; + getAverageRequestTime());</span>
<span class="nc" id="L459">    buffer.append(&quot;\n averageCheckoutTime            &quot; + getAverageCheckoutTime());</span>
<span class="nc" id="L460">    buffer.append(&quot;\n claimedOverdue                 &quot; + getClaimedOverdueConnectionCount());</span>
<span class="nc" id="L461">    buffer.append(&quot;\n averageOverdueCheckoutTime     &quot; + getAverageOverdueCheckoutTime());</span>
<span class="nc" id="L462">    buffer.append(&quot;\n hadToWait                      &quot; + getHadToWaitCount());</span>
<span class="nc" id="L463">    buffer.append(&quot;\n averageWaitTime                &quot; + getAverageWaitTime());</span>
    buffer.append(&quot;\n badConnectionCount             &quot; + getBadConnectionCount());
    buffer.append(&quot;\n===============================================================&quot;);
    return buffer.toString();
  }

  /**
<span class="fc" id="L470">   * Closes all of the connections in the pool</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">   */</span>
  public void forceCloseAll() {
<span class="nc" id="L473">    synchronized (POOL_LOCK) {</span>
<span class="nc" id="L474">      for (int i = activeConnections.size(); i &gt; 0; i--) {</span>
        try {
<span class="nc" id="L476">          SimplePooledConnection conn = (SimplePooledConnection) activeConnections.remove(i - 1);</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">          conn.invalidate();</span>
<span class="nc" id="L478"></span>
          Connection realConn = conn.getRealConnection();
<span class="nc" id="L480">          if (!realConn.getAutoCommit()) {</span>
<span class="nc" id="L481">            realConn.rollback();</span>
          }
<span class="nc" id="L483">          realConn.close();</span>
        } catch (Exception e) {
<span class="fc bfc" id="L485" title="All 2 branches covered.">          // ignore</span>
        }
<span class="fc" id="L487">      }</span>
<span class="fc" id="L488">      for (int i = idleConnections.size(); i &gt; 0; i--) {</span>
        try {
<span class="fc" id="L490">          SimplePooledConnection conn = (SimplePooledConnection) idleConnections.remove(i - 1);</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">          conn.invalidate();</span>
<span class="fc" id="L492"></span>
          Connection realConn = conn.getRealConnection();
<span class="fc" id="L494">          if (!realConn.getAutoCommit()) {</span>
<span class="fc" id="L495">            realConn.rollback();</span>
          }
<span class="fc" id="L497">          realConn.close();</span>
        } catch (Exception e) {
<span class="pc" id="L499">          // ignore</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">        }</span>
<span class="nc" id="L501">      }</span>
    }
<span class="fc" id="L503">    if (log.isDebugEnabled()) {</span>
      log.debug(&quot;SimpleDataSource forcefully closed/removed all connections.&quot;);
    }
  }
<span class="fc" id="L507"></span>
<span class="fc" id="L508">  private void pushConnection(SimplePooledConnection conn) throws SQLException {</span>
<span class="pc bpc" id="L509" title="1 of 2 branches missed."></span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">    synchronized (POOL_LOCK) {</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">      activeConnections.remove(conn);</span>
<span class="fc" id="L512">      if (conn.isValid()) {</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">        if (idleConnections.size() &lt; poolMaximumIdleConnections</span>
<span class="fc" id="L514">            &amp;&amp; conn.getConnectionTypeCode() == getExpectedConnectionTypeCode()) {</span>
          accumulatedCheckoutTime += conn.getCheckoutTime();
<span class="fc" id="L516">          if (!conn.getRealConnection().getAutoCommit()) {</span>
<span class="fc" id="L517">            conn.getRealConnection().rollback();</span>
<span class="fc" id="L518">          }</span>
<span class="fc" id="L519">          SimplePooledConnection newConn = new SimplePooledConnection(conn.getRealConnection(), this);</span>
<span class="fc" id="L520">          idleConnections.add(newConn);</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">          newConn.setCreatedTimestamp(conn.getCreatedTimestamp());</span>
<span class="nc" id="L522">          newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());</span>
          conn.invalidate();
<span class="fc" id="L524">          if (log.isDebugEnabled()) {</span>
<span class="fc" id="L525">            log.debug(&quot;Returned connection &quot; + newConn.getRealHashCode() + &quot; to pool.&quot;);</span>
<span class="nc" id="L526">          }</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">          POOL_LOCK.notifyAll();</span>
<span class="nc" id="L528">        } else {</span>
          accumulatedCheckoutTime += conn.getCheckoutTime();
<span class="nc" id="L530">          if (!conn.getRealConnection().getAutoCommit()) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">            conn.getRealConnection().rollback();</span>
<span class="nc" id="L532">          }</span>
          conn.getRealConnection().close();
<span class="nc" id="L534">          if (log.isDebugEnabled()) {</span>
            log.debug(&quot;Closed connection &quot; + conn.getRealHashCode() + &quot;.&quot;);
          }
<span class="nc bnc" id="L537" title="All 2 branches missed.">          conn.invalidate();</span>
<span class="nc" id="L538">        }</span>
      } else {
        if (log.isDebugEnabled()) {
<span class="nc" id="L541">          log.debug(&quot;A bad connection (&quot; + conn.getRealHashCode()</span>
              + &quot;) attempted to return to the pool, discarding connection.&quot;);
<span class="pc" id="L543">        }</span>
<span class="fc" id="L544">        badConnectionCount++;</span>
      }
    }
<span class="fc" id="L547">  }</span>
<span class="fc" id="L548"></span>
<span class="fc" id="L549">  private SimplePooledConnection popConnection(String username, String password) throws SQLException {</span>
<span class="fc" id="L550">    boolean countedWait = false;</span>
    SimplePooledConnection conn = null;
<span class="fc bfc" id="L552" title="All 2 branches covered.">    long t = System.currentTimeMillis();</span>
<span class="fc" id="L553">    int localBadConnectionCount = 0;</span>
<span class="fc bfc" id="L554" title="All 2 branches covered."></span>
    while (conn == null) {
<span class="fc" id="L556">      synchronized (POOL_LOCK) {</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">        if (idleConnections.size() &gt; 0) {</span>
<span class="nc" id="L558">          // Pool has available connection</span>
          conn = (SimplePooledConnection) idleConnections.remove(0);
          if (log.isDebugEnabled()) {
            log.debug(&quot;Checked out connection &quot; + conn.getRealHashCode() + &quot; from pool.&quot;);
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">          }</span>
        } else {
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">          // Pool does not have available connection</span>
<span class="nc" id="L565">          if (activeConnections.size() &lt; poolMaximumActiveConnections) {</span>
            // Can create new connection
<span class="fc" id="L567">            if (useDriverProps) {</span>
              conn = new SimplePooledConnection(DriverManager.getConnection(jdbcUrl, driverProps), this);
<span class="fc" id="L569">            } else {</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">              conn = new SimplePooledConnection(DriverManager.getConnection(jdbcUrl, jdbcUsername, jdbcPassword), this);</span>
<span class="fc" id="L571">            }</span>
            Connection realConn = conn.getRealConnection();
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">            if (realConn.getAutoCommit() != jdbcDefaultAutoCommit) {</span>
<span class="nc" id="L574">              realConn.setAutoCommit(jdbcDefaultAutoCommit);</span>
            }
<span class="fc" id="L576">            if (log.isDebugEnabled()) {</span>
              log.debug(&quot;Created connection &quot; + conn.getRealHashCode() + &quot;.&quot;);
<span class="nc" id="L578">            }</span>
<span class="nc" id="L579">          } else {</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">            // Cannot create new connection</span>
            SimplePooledConnection oldestActiveConnection = (SimplePooledConnection) activeConnections.get(0);
<span class="nc" id="L582">            long longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span>
<span class="nc" id="L583">            if (longestCheckoutTime &gt; poolMaximumCheckoutTime) {</span>
<span class="nc" id="L584">              // Can claim overdue connection</span>
<span class="nc" id="L585">              claimedOverdueConnectionCount++;</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">              accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span>
<span class="nc" id="L587">              accumulatedCheckoutTime += longestCheckoutTime;</span>
              activeConnections.remove(oldestActiveConnection);
<span class="nc" id="L589">              if (!oldestActiveConnection.getRealConnection().getAutoCommit()) {</span>
<span class="nc" id="L590">                oldestActiveConnection.getRealConnection().rollback();</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">              }</span>
<span class="nc" id="L592">              conn = new SimplePooledConnection(oldestActiveConnection.getRealConnection(), this);</span>
              oldestActiveConnection.invalidate();
              if (log.isDebugEnabled()) {
                log.debug(&quot;Claimed overdue connection &quot; + conn.getRealHashCode() + &quot;.&quot;);
              }
<span class="nc bnc" id="L597" title="All 2 branches missed.">            } else {</span>
<span class="nc" id="L598">              // Must wait</span>
<span class="nc" id="L599">              try {</span>
                if (!countedWait) {
<span class="nc bnc" id="L601" title="All 2 branches missed.">                  hadToWaitCount++;</span>
<span class="nc" id="L602">                  countedWait = true;</span>
                }
<span class="nc" id="L604">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L605">                  log.debug(&quot;Waiting as long as &quot; + poolTimeToWait + &quot; milliseconds for connection.&quot;);</span>
<span class="nc" id="L606">                }</span>
<span class="nc" id="L607">                long wt = System.currentTimeMillis();</span>
<span class="nc" id="L608">                POOL_LOCK.wait(poolTimeToWait);</span>
<span class="nc" id="L609">                accumulatedWaitTime += System.currentTimeMillis() - wt;</span>
              } catch (InterruptedException e) {
                break;
              }
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">            }</span>
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">          }</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">        }</span>
<span class="fc" id="L616">        if (conn != null) {</span>
          if (conn.isValid()) {
<span class="fc" id="L618">            if (!conn.getRealConnection().getAutoCommit()) {</span>
<span class="fc" id="L619">              conn.getRealConnection().rollback();</span>
<span class="fc" id="L620">            }</span>
<span class="fc" id="L621">            conn.setConnectionTypeCode(assembleConnectionTypeCode(jdbcUrl, username, password));</span>
<span class="fc" id="L622">            conn.setCheckoutTimestamp(System.currentTimeMillis());</span>
<span class="fc" id="L623">            conn.setLastUsedTimestamp(System.currentTimeMillis());</span>
            activeConnections.add(conn);
<span class="nc bnc" id="L625" title="All 2 branches missed.">            requestCount++;</span>
<span class="nc" id="L626">            accumulatedRequestTime += System.currentTimeMillis() - t;</span>
          } else {
            if (log.isDebugEnabled()) {
<span class="nc" id="L629">              log.debug(&quot;A bad connection (&quot; + conn.getRealHashCode()</span>
<span class="nc" id="L630">                  + &quot;) was returned from the pool, getting another connection.&quot;);</span>
<span class="nc" id="L631">            }</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">            badConnectionCount++;</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">            localBadConnectionCount++;</span>
<span class="nc" id="L634">            conn = null;</span>
            if (localBadConnectionCount &gt; (poolMaximumIdleConnections + 3)) {
<span class="nc" id="L636">              if (log.isDebugEnabled()) {</span>
                log.debug(&quot;SimpleDataSource: Could not get a good connection to the database.&quot;);
              }
              throw new SQLException(&quot;SimpleDataSource: Could not get a good connection to the database.&quot;);
<span class="pc" id="L640">            }</span>
          }
        }
      }
<span class="pc bpc" id="L644" title="1 of 2 branches missed."></span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">    }</span>
<span class="nc" id="L646"></span>
    if (conn == null) {
<span class="nc" id="L648">      if (log.isDebugEnabled()) {</span>
        log.debug(&quot;SimpleDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);
      }
      throw new SQLException(
<span class="fc" id="L652">          &quot;SimpleDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);</span>
    }

    return conn;
  }

  /**
   * Method to check to see if a connection is still usable
   *
   * @param conn
   *          - the connection to check
<span class="fc" id="L663">   * @return True if the connection is still usable</span>
   */
  private boolean pingConnection(SimplePooledConnection conn) {
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">    boolean result = true;</span>
<span class="nc" id="L667"></span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">    try {</span>
<span class="nc" id="L669">      result = !conn.getRealConnection().isClosed();</span>
    } catch (SQLException e) {
<span class="nc" id="L671">      if (log.isDebugEnabled()) {</span>
<span class="fc" id="L672">        log.debug(&quot;Connection &quot; + conn.getRealHashCode() + &quot; is BAD: &quot; + e.getMessage());</span>
      }
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">      result = false;</span>
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">    }</span>
<span class="nc bnc" id="L676" title="All 6 branches missed."></span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">    if (result) {</span>
      if (poolPingEnabled) {
        if ((poolPingConnectionsOlderThan &gt; 0 &amp;&amp; conn.getAge() &gt; poolPingConnectionsOlderThan)
<span class="nc bnc" id="L680" title="All 2 branches missed.">            || (poolPingConnectionsNotUsedFor &gt; 0 &amp;&amp; conn.getTimeElapsedSinceLastUse() &gt; poolPingConnectionsNotUsedFor)) {</span>
<span class="nc" id="L681"></span>
          try {
<span class="nc" id="L683">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L684">              log.debug(&quot;Testing connection &quot; + conn.getRealHashCode() + &quot; ...&quot;);</span>
<span class="nc" id="L685">            }</span>
<span class="nc" id="L686">            Connection realConn = conn.getRealConnection();</span>
<span class="nc" id="L687">            Statement statement = realConn.createStatement();</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">            ResultSet rs = statement.executeQuery(poolPingQuery);</span>
<span class="nc" id="L689">            rs.close();</span>
            statement.close();
<span class="nc" id="L691">            if (!realConn.getAutoCommit()) {</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">              realConn.rollback();</span>
<span class="nc" id="L693">            }</span>
            result = true;
<span class="nc" id="L695">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L696">              log.debug(&quot;Connection &quot; + conn.getRealHashCode() + &quot; is GOOD!&quot;);</span>
            }
<span class="nc" id="L698">          } catch (Exception e) {</span>
<span class="nc" id="L699">            log.warn(&quot;Execution of ping query '&quot; + poolPingQuery + &quot;' failed: &quot; + e.getMessage());</span>
            try {
<span class="nc" id="L701">              conn.getRealConnection().close();</span>
<span class="nc" id="L702">            } catch (Exception e2) {</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">              // ignore</span>
<span class="nc" id="L704">            }</span>
            result = false;
<span class="nc" id="L706">            if (log.isDebugEnabled()) {</span>
              log.debug(&quot;Connection &quot; + conn.getRealHashCode() + &quot; is BAD: &quot; + e.getMessage());
            }
          }
<span class="fc" id="L710">        }</span>
      }
    }
    return result;
  }

  /**
   * Unwraps a pooled connection to get to the 'real' connection
   *
   * @param conn
   *          - the pooled connection to unwrap
<span class="nc bnc" id="L721" title="All 2 branches missed.">   * @return The 'real' connection</span>
<span class="nc" id="L722">   */</span>
  public static Connection unwrapConnection(Connection conn) {
<span class="nc" id="L724">    if (conn instanceof SimplePooledConnection) {</span>
      return ((SimplePooledConnection) conn).getRealConnection();
    } else {
      return conn;
    }
<span class="fc" id="L729">  }</span>
<span class="fc" id="L730"></span>
  protected void finalize() throws Throwable {
    forceCloseAll();
  }

  /**
   * --------------------------------------------------------------------------------------- SimplePooledConnection
   * ---------------------------------------------------------------------------------------
   */
<span class="fc" id="L739">  public static class SimplePooledConnection implements InvocationHandler {</span>

<span class="fc" id="L741">    private static final String CLOSE = &quot;close&quot;;</span>
    private static final Class[] IFACES = new Class[] { Connection.class };

    private int hashCode = 0;
    private SimpleDataSource dataSource;
    private Connection realConnection;
    private Connection proxyConnection;
    private long checkoutTimestamp;
    private long createdTimestamp;
    private long lastUsedTimestamp;
    private int connectionTypeCode;
    private boolean valid;

    /**
     * Constructor for SimplePooledConnection that uses the Connection and SimpleDataSource passed in
     *
     * @param connection
     *          - the connection that is to be presented as a pooled connection
<span class="fc" id="L759">     * @param dataSource</span>
<span class="fc" id="L760">     *          - the dataSource that the connection is from</span>
<span class="fc" id="L761">     */</span>
<span class="fc" id="L762">    public SimplePooledConnection(Connection connection, SimpleDataSource dataSource) {</span>
<span class="fc" id="L763">      this.hashCode = connection.hashCode();</span>
<span class="fc" id="L764">      this.realConnection = connection;</span>
<span class="fc" id="L765">      this.dataSource = dataSource;</span>
      this.createdTimestamp = System.currentTimeMillis();
<span class="fc" id="L767">      this.lastUsedTimestamp = System.currentTimeMillis();</span>
<span class="fc" id="L768">      this.valid = true;</span>

      proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, this);
    }

    /**
<span class="fc" id="L774">     * Invalidates the connection</span>
<span class="fc" id="L775">     */</span>
    public void invalidate() {
      valid = false;
    }

    /**
     * Method to see if the connection is usable
     *
<span class="pc bpc" id="L783" title="3 of 6 branches missed.">     * @return True if the connection is usable</span>
     */
    public boolean isValid() {
      return valid &amp;&amp; realConnection != null &amp;&amp; dataSource.pingConnection(this);
    }

    /**
     * Getter for the *real* connection that this wraps
     * 
<span class="fc" id="L792">     * @return The connection</span>
     */
    public Connection getRealConnection() {
      return realConnection;
    }

    /**
     * Getter for the proxy for the connection
     * 
<span class="fc" id="L801">     * @return The proxy</span>
     */
    public Connection getProxyConnection() {
      return proxyConnection;
    }

    /**
     * Gets the hashcode of the real connection (or 0 if it is null)
     *
<span class="nc bnc" id="L810" title="All 2 branches missed.">     * @return The hashcode of the real connection (or 0 if it is null)</span>
<span class="nc" id="L811">     */</span>
    public int getRealHashCode() {
<span class="nc" id="L813">      if (realConnection == null) {</span>
        return 0;
      } else {
        return realConnection.hashCode();
      }
    }

    /**
     * Getter for the connection type (based on url + user + password)
     * 
<span class="fc" id="L823">     * @return The connection type</span>
     */
    public int getConnectionTypeCode() {
      return connectionTypeCode;
    }

    /**
     * Setter for the connection type
     * 
     * @param connectionTypeCode
<span class="fc" id="L833">     *          - the connection type</span>
<span class="fc" id="L834">     */</span>
    public void setConnectionTypeCode(int connectionTypeCode) {
      this.connectionTypeCode = connectionTypeCode;
    }

    /**
     * Getter for the time that the connection was created
     * 
<span class="fc" id="L842">     * @return The creation timestamp</span>
     */
    public long getCreatedTimestamp() {
      return createdTimestamp;
    }

    /**
     * Setter for the time that the connection was created
     * 
     * @param createdTimestamp
<span class="fc" id="L852">     *          - the timestamp</span>
<span class="fc" id="L853">     */</span>
    public void setCreatedTimestamp(long createdTimestamp) {
      this.createdTimestamp = createdTimestamp;
    }

    /**
     * Getter for the time that the connection was last used
     * 
<span class="fc" id="L861">     * @return - the timestamp</span>
     */
    public long getLastUsedTimestamp() {
      return lastUsedTimestamp;
    }

    /**
     * Setter for the time that the connection was last used
     * 
     * @param lastUsedTimestamp
<span class="fc" id="L871">     *          - the timestamp</span>
<span class="fc" id="L872">     */</span>
    public void setLastUsedTimestamp(long lastUsedTimestamp) {
      this.lastUsedTimestamp = lastUsedTimestamp;
    }

    /**
     * Getter for the time since this connection was last used
     * 
<span class="nc" id="L880">     * @return - the time since the last use</span>
     */
    public long getTimeElapsedSinceLastUse() {
      return System.currentTimeMillis() - lastUsedTimestamp;
    }

    /**
     * Getter for the age of the connection
     * 
<span class="nc" id="L889">     * @return the age</span>
     */
    public long getAge() {
      return System.currentTimeMillis() - createdTimestamp;
    }

    /**
     * Getter for the timestamp that this connection was checked out
     * 
<span class="nc" id="L898">     * @return the timestamp</span>
     */
    public long getCheckoutTimestamp() {
      return checkoutTimestamp;
    }

    /**
     * Setter for the timestamp that this connection was checked out
     * 
     * @param timestamp
<span class="fc" id="L908">     *          the timestamp</span>
<span class="fc" id="L909">     */</span>
    public void setCheckoutTimestamp(long timestamp) {
      this.checkoutTimestamp = timestamp;
    }

    /**
     * Getter for the time that this connection has been checked out
     * 
<span class="fc" id="L917">     * @return the time</span>
     */
    public long getCheckoutTime() {
      return System.currentTimeMillis() - checkoutTimestamp;
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">    }</span>
<span class="nc" id="L922"></span>
    private Connection getValidConnection() {
<span class="fc" id="L924">      if (!valid) {</span>
        throw new RuntimeException(&quot;Error accessing SimplePooledConnection. Connection is invalid.&quot;);
      }
      return realConnection;
<span class="nc" id="L928">    }</span>

    public int hashCode() {
      return hashCode;
    }

    /**
     * Allows comparing this connection to another
     *
     * @param obj
     *          - the other connection to test for equality
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">     * @see java.lang.Object#equals(java.lang.Object)</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">     */</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">    public boolean equals(Object obj) {</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">      if (obj instanceof SimplePooledConnection) {</span>
        return realConnection.hashCode() == (((SimplePooledConnection) obj).realConnection.hashCode());
<span class="nc" id="L944">      } else if (obj instanceof Connection) {</span>
        return hashCode == obj.hashCode();
      } else {
        return false;
      }
    }

    // **********************************
    // Implemented Connection Methods -- Now handled by proxy
    // **********************************

    /**
     * Required for InvocationHandler implementation.
     *
     * @param proxy
     *          - not used
     * @param method
     *          - the method to be executed
     * @param args
     *          - the parameters to be passed to the method
<span class="fc" id="L964">     * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])</span>
<span class="pc bpc" id="L965" title="1 of 4 branches missed.">     */</span>
<span class="fc" id="L966">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {</span>
<span class="fc" id="L967">      String methodName = method.getName();</span>
      if (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) {
        dataSource.pushConnection(this);
<span class="fc" id="L970">        return null;</span>
<span class="fc" id="L971">      } else {</span>
<span class="fc" id="L972">        try {</span>
          return method.invoke(getValidConnection(), args);
        } catch (Throwable t) {
          throw ClassInfo.unwrapThrowable(t);
        }
      }
<span class="nc" id="L978">    }</span>

    public Statement createStatement() throws SQLException {
      return getValidConnection().createStatement();
<span class="nc" id="L982">    }</span>

    public PreparedStatement prepareStatement(String sql) throws SQLException {
      return getValidConnection().prepareStatement(sql);
<span class="nc" id="L986">    }</span>

    public CallableStatement prepareCall(String sql) throws SQLException {
      return getValidConnection().prepareCall(sql);
<span class="nc" id="L990">    }</span>

    public String nativeSQL(String sql) throws SQLException {
      return getValidConnection().nativeSQL(sql);
<span class="nc" id="L994">    }</span>
<span class="nc" id="L995"></span>
    public void setAutoCommit(boolean autoCommit) throws SQLException {
      getValidConnection().setAutoCommit(autoCommit);
<span class="nc" id="L998">    }</span>

    public boolean getAutoCommit() throws SQLException {
      return getValidConnection().getAutoCommit();
<span class="nc" id="L1002">    }</span>
<span class="nc" id="L1003"></span>
    public void commit() throws SQLException {
      getValidConnection().commit();
<span class="nc" id="L1006">    }</span>
<span class="nc" id="L1007"></span>
    public void rollback() throws SQLException {
      getValidConnection().rollback();
<span class="nc" id="L1010">    }</span>
<span class="nc" id="L1011"></span>
    public void close() throws SQLException {
      dataSource.pushConnection(this);
<span class="nc" id="L1014">    }</span>

    public boolean isClosed() throws SQLException {
      return getValidConnection().isClosed();
<span class="nc" id="L1018">    }</span>

    public DatabaseMetaData getMetaData() throws SQLException {
      return getValidConnection().getMetaData();
<span class="nc" id="L1022">    }</span>
<span class="nc" id="L1023"></span>
    public void setReadOnly(boolean readOnly) throws SQLException {
      getValidConnection().setReadOnly(readOnly);
<span class="nc" id="L1026">    }</span>

    public boolean isReadOnly() throws SQLException {
      return getValidConnection().isReadOnly();
<span class="nc" id="L1030">    }</span>
<span class="nc" id="L1031"></span>
    public void setCatalog(String catalog) throws SQLException {
      getValidConnection().setCatalog(catalog);
<span class="nc" id="L1034">    }</span>

    public String getCatalog() throws SQLException {
      return getValidConnection().getCatalog();
<span class="nc" id="L1038">    }</span>
<span class="nc" id="L1039"></span>
    public void setTransactionIsolation(int level) throws SQLException {
      getValidConnection().setTransactionIsolation(level);
<span class="nc" id="L1042">    }</span>

    public int getTransactionIsolation() throws SQLException {
      return getValidConnection().getTransactionIsolation();
<span class="nc" id="L1046">    }</span>

    public SQLWarning getWarnings() throws SQLException {
      return getValidConnection().getWarnings();
<span class="nc" id="L1050">    }</span>
<span class="nc" id="L1051"></span>
    public void clearWarnings() throws SQLException {
      getValidConnection().clearWarnings();
<span class="nc" id="L1054">    }</span>

    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
      return getValidConnection().createStatement(resultSetType, resultSetConcurrency);
    }
<span class="nc" id="L1059"></span>
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
        throws SQLException {
      return getValidConnection().prepareCall(sql, resultSetType, resultSetConcurrency);
<span class="nc" id="L1063">    }</span>

    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
      return getValidConnection().prepareCall(sql, resultSetType, resultSetConcurrency);
<span class="nc" id="L1067">    }</span>

    public Map getTypeMap() throws SQLException {
      return getValidConnection().getTypeMap();
<span class="nc" id="L1071">    }</span>
<span class="nc" id="L1072"></span>
    public void setTypeMap(Map map) throws SQLException {
      getValidConnection().setTypeMap(map);
    }

    // **********************************
    // JDK 1.4 JDBC 3.0 Methods below
<span class="nc" id="L1079">    // **********************************</span>
<span class="nc" id="L1080"></span>
    public void setHoldability(int holdability) throws SQLException {
      getValidConnection().setHoldability(holdability);
<span class="nc" id="L1083">    }</span>

    public int getHoldability() throws SQLException {
      return getValidConnection().getHoldability();
<span class="nc" id="L1087">    }</span>

    public Savepoint setSavepoint() throws SQLException {
      return getValidConnection().setSavepoint();
<span class="nc" id="L1091">    }</span>

    public Savepoint setSavepoint(String name) throws SQLException {
      return getValidConnection().setSavepoint(name);
<span class="nc" id="L1095">    }</span>
<span class="nc" id="L1096"></span>
    public void rollback(Savepoint savepoint) throws SQLException {
      getValidConnection().rollback(savepoint);
<span class="nc" id="L1099">    }</span>
<span class="nc" id="L1100"></span>
    public void releaseSavepoint(Savepoint savepoint) throws SQLException {
      getValidConnection().releaseSavepoint(savepoint);
    }
<span class="nc" id="L1104"></span>
    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
        throws SQLException {
      return getValidConnection().createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
    }
<span class="nc" id="L1109"></span>
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency,
        int resultSetHoldability) throws SQLException {
      return getValidConnection().prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    }
<span class="nc" id="L1114"></span>
    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency,
        int resultSetHoldability) throws SQLException {
      return getValidConnection().prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
<span class="nc" id="L1118">    }</span>

    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
      return getValidConnection().prepareStatement(sql, autoGeneratedKeys);
<span class="nc" id="L1122">    }</span>

    public PreparedStatement prepareStatement(String sql, int columnIndexes[]) throws SQLException {
      return getValidConnection().prepareStatement(sql, columnIndexes);
<span class="nc" id="L1126">    }</span>

    public PreparedStatement prepareStatement(String sql, String columnNames[]) throws SQLException {
      return getValidConnection().prepareStatement(sql, columnNames);
    }

  }
<span class="nc" id="L1133"></span>
  public Logger getParentLogger() throws SQLFeatureNotSupportedException {
    // TODO Auto-generated method stub
    return null;
  }
<span class="nc" id="L1138"></span>
  public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException {
    // TODO Auto-generated method stub
    return null;
  }
<span class="nc" id="L1143"></span>
  public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException {
    // TODO Auto-generated method stub
    return false;
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>