<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultSqlExecutor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.execution</a> &gt; <span class="el_source">DefaultSqlExecutor.java</span></div><h1>DefaultSqlExecutor.java</h1><pre class="source lang-java linenums">/**
 *    Copyright 2004-2015 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.ibatis.sqlmap.engine.execution;

import java.sql.BatchUpdateException;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

import com.ibatis.sqlmap.engine.config.SqlMapConfiguration;
import com.ibatis.sqlmap.engine.impl.SqlMapClientImpl;
import com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate;
import com.ibatis.sqlmap.engine.mapping.parameter.ParameterMap;
import com.ibatis.sqlmap.engine.mapping.parameter.ParameterMapping;
import com.ibatis.sqlmap.engine.mapping.result.ResultMap;
import com.ibatis.sqlmap.engine.mapping.result.ResultObjectFactoryUtil;
import com.ibatis.sqlmap.engine.mapping.statement.DefaultRowHandler;
import com.ibatis.sqlmap.engine.mapping.statement.MappedStatement;
import com.ibatis.sqlmap.engine.mapping.statement.RowHandlerCallback;
import com.ibatis.sqlmap.engine.scope.ErrorContext;
import com.ibatis.sqlmap.engine.scope.SessionScope;
import com.ibatis.sqlmap.engine.scope.StatementScope;

/**
 * Class responsible for executing the SQL
 */
<span class="fc" id="L47">public class DefaultSqlExecutor implements SqlExecutor {</span>

  //
  // Public Methods
  //

  /**
   * Execute an update
   *
   * @param statementScope    - the request scope
   * @param conn       - the database connection
   * @param sql        - the sql statement to execute
   * @param parameters - the parameters for the sql statement
   * @return - the number of records changed
   * @throws SQLException - if the update fails
   */
  public int executeUpdate(StatementScope statementScope, Connection conn, String sql, Object[] parameters) throws SQLException {
<span class="fc" id="L64">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L65">    errorContext.setActivity(&quot;executing update&quot;);</span>
<span class="fc" id="L66">    errorContext.setObjectId(sql);</span>
<span class="fc" id="L67">    PreparedStatement ps = null;</span>
<span class="fc" id="L68">    setupResultObjectFactory(statementScope);</span>
<span class="fc" id="L69">    int rows = 0;</span>
    try {
<span class="fc" id="L71">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="fc" id="L72">      ps = prepareStatement(statementScope.getSession(), conn, sql);</span>
<span class="fc" id="L73">      setStatementTimeout(statementScope.getStatement(), ps);</span>
<span class="fc" id="L74">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="fc" id="L75">      statementScope.getParameterMap().setParameters(statementScope, ps, parameters);</span>
<span class="fc" id="L76">      errorContext.setMoreInfo(&quot;Check the statement (update failed).&quot;);</span>
<span class="fc" id="L77">      ps.execute();</span>
<span class="fc" id="L78">      rows = ps.getUpdateCount();</span>
<span class="fc" id="L79">    } finally {</span>
<span class="fc" id="L80">      closeStatement(statementScope.getSession(), ps);</span>
<span class="fc" id="L81">      cleanupResultObjectFactory();</span>
<span class="fc" id="L82">    }</span>
<span class="fc" id="L83">    return rows;</span>
  }

  /**
   * Adds a statement to a batch
   *
   * @param statementScope    - the request scope
   * @param conn       - the database connection
   * @param sql        - the sql statement
   * @param parameters - the parameters for the statement
   * @throws SQLException - if the statement fails
   */
  public void addBatch(StatementScope statementScope, Connection conn, String sql, Object[] parameters) throws SQLException {
<span class="fc" id="L96">    Batch batch = (Batch) statementScope.getSession().getBatch();</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">    if (batch == null) {</span>
<span class="fc" id="L98">      batch = new Batch();</span>
<span class="fc" id="L99">      statementScope.getSession().setBatch(batch);</span>
    }
<span class="fc" id="L101">    batch.addBatch(statementScope, conn, sql, parameters);</span>
<span class="fc" id="L102">  }</span>

  /**
   * Execute a batch of statements
   *
   * @param sessionScope - the session scope
   * @return - the number of rows impacted by the batch
   * @throws SQLException - if a statement fails
   */
  public int executeBatch(SessionScope sessionScope) throws SQLException {
<span class="fc" id="L112">    int rows = 0;</span>
<span class="fc" id="L113">    Batch batch = (Batch) sessionScope.getBatch();</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">    if (batch != null) {</span>
      try {
<span class="fc" id="L116">        rows = batch.executeBatch();</span>
<span class="pc" id="L117">      } finally {</span>
<span class="pc" id="L118">        batch.cleanupBatch(sessionScope);</span>
<span class="nc" id="L119">      }</span>
    }
<span class="fc" id="L121">    return rows;</span>
  }

  /**
   * Execute a batch of statements
   *
   * @param sessionScope - the session scope
   * @return - a List of BatchResult objects (may be null if no batch
   *         has been initiated).  There will be one BatchResult object in the
   *         list for each sub-batch executed
   * @throws SQLException   if a database access error occurs, or the drive
   *                        does not support batch statements
   * @throws BatchException if the driver throws BatchUpdateException
   */
  public List executeBatchDetailed(SessionScope sessionScope) throws SQLException, BatchException {
<span class="fc" id="L136">    List answer = null;</span>
<span class="fc" id="L137">    Batch batch = (Batch) sessionScope.getBatch();</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">    if (batch != null) {</span>
      try {
<span class="fc" id="L140">        answer = batch.executeBatchDetailed();</span>
<span class="fc" id="L141">      } finally {</span>
<span class="fc" id="L142">        batch.cleanupBatch(sessionScope);</span>
<span class="fc" id="L143">      }</span>
    }
<span class="fc" id="L145">    return answer;</span>
  }

  /**
   * Long form of the method to execute a query
   *
   * @param statementScope     - the request scope
   * @param conn        - the database connection
   * @param sql         - the SQL statement to execute
   * @param parameters  - the parameters for the statement
   * @param skipResults - the number of results to skip
   * @param maxResults  - the maximum number of results to return
   * @param callback    - the row handler for the query
   * @throws SQLException - if the query fails
   */
  public void executeQuery(StatementScope statementScope, Connection conn, String sql, Object[] parameters, int skipResults, int maxResults, RowHandlerCallback callback) throws SQLException {
<span class="fc" id="L161">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L162">    errorContext.setActivity(&quot;executing query&quot;);</span>
<span class="fc" id="L163">    errorContext.setObjectId(sql);</span>
<span class="fc" id="L164">    PreparedStatement ps = null;</span>
<span class="fc" id="L165">    ResultSet rs = null;</span>
<span class="fc" id="L166">    setupResultObjectFactory(statementScope);</span>
    try {
<span class="fc" id="L168">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="fc" id="L169">      Integer rsType = statementScope.getStatement().getResultSetType();</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">      if (rsType != null) {</span>
<span class="nc" id="L171">        ps = prepareStatement(statementScope.getSession(), conn, sql, rsType);</span>
<span class="nc" id="L172">      } else {</span>
<span class="fc" id="L173">        ps = prepareStatement(statementScope.getSession(), conn, sql);</span>
      }
<span class="fc" id="L175">      setStatementTimeout(statementScope.getStatement(), ps);</span>
<span class="fc" id="L176">      Integer fetchSize = statementScope.getStatement().getFetchSize();</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">      if (fetchSize != null) {</span>
<span class="nc" id="L178">        ps.setFetchSize(fetchSize.intValue());</span>
      }
<span class="fc" id="L180">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="fc" id="L181">      statementScope.getParameterMap().setParameters(statementScope, ps, parameters);</span>
<span class="fc" id="L182">      errorContext.setMoreInfo(&quot;Check the statement (query failed).&quot;);</span>
<span class="fc" id="L183">      ps.execute();</span>
<span class="fc" id="L184">      errorContext.setMoreInfo(&quot;Check the results (failed to retrieve results).&quot;);</span>

      // Begin ResultSet Handling
<span class="fc" id="L187">      rs = handleMultipleResults(ps, statementScope, skipResults, maxResults, callback);</span>
      // End ResultSet Handling
<span class="fc" id="L189">    } finally {</span>
      try {
<span class="fc" id="L191">        closeResultSet(rs);</span>
<span class="pc" id="L192">      } finally {</span>
<span class="pc" id="L193">        closeStatement(statementScope.getSession(), ps);</span>
<span class="pc" id="L194">        cleanupResultObjectFactory();</span>
<span class="nc" id="L195">      }</span>
<span class="fc" id="L196">    }</span>

<span class="fc" id="L198">  }</span>

  /**
   * Execute a stored procedure that updates data
   *
   * @param statementScope    - the request scope
   * @param conn       - the database connection
   * @param sql        - the SQL to call the procedure
   * @param parameters - the parameters for the procedure
   * @return - the rows impacted by the procedure
   * @throws SQLException - if the procedure fails
   */
  public int executeUpdateProcedure(StatementScope statementScope, Connection conn, String sql, Object[] parameters) throws SQLException {
<span class="nc" id="L211">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="nc" id="L212">    errorContext.setActivity(&quot;executing update procedure&quot;);</span>
<span class="nc" id="L213">    errorContext.setObjectId(sql);</span>
<span class="nc" id="L214">    CallableStatement cs = null;</span>
<span class="nc" id="L215">    setupResultObjectFactory(statementScope);</span>
<span class="nc" id="L216">    int rows = 0;</span>
    try {
<span class="nc" id="L218">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="nc" id="L219">      cs = prepareCall(statementScope.getSession(), conn, sql);</span>
<span class="nc" id="L220">      setStatementTimeout(statementScope.getStatement(), cs);</span>
<span class="nc" id="L221">      ParameterMap parameterMap = statementScope.getParameterMap();</span>
<span class="nc" id="L222">      ParameterMapping[] mappings = parameterMap.getParameterMappings();</span>
<span class="nc" id="L223">      errorContext.setMoreInfo(&quot;Check the output parameters (register output parameters failed).&quot;);</span>
<span class="nc" id="L224">      registerOutputParameters(cs, mappings);</span>
<span class="nc" id="L225">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="nc" id="L226">      parameterMap.setParameters(statementScope, cs, parameters);</span>
<span class="nc" id="L227">      errorContext.setMoreInfo(&quot;Check the statement (update procedure failed).&quot;);</span>
<span class="nc" id="L228">      cs.execute();</span>
<span class="nc" id="L229">      rows = cs.getUpdateCount();</span>
<span class="nc" id="L230">      errorContext.setMoreInfo(&quot;Check the output parameters (retrieval of output parameters failed).&quot;);</span>
<span class="nc" id="L231">      retrieveOutputParameters(statementScope, cs, mappings, parameters, null);</span>
<span class="nc" id="L232">    } finally {</span>
<span class="nc" id="L233">      closeStatement(statementScope.getSession(), cs);</span>
<span class="nc" id="L234">      cleanupResultObjectFactory();</span>
<span class="nc" id="L235">    }</span>
<span class="nc" id="L236">    return rows;</span>
  }

  /**
   * Execute a stored procedure
   *
   * @param statementScope     - the request scope
   * @param conn        - the database connection
   * @param sql         - the sql to call the procedure
   * @param parameters  - the parameters for the procedure
   * @param skipResults - the number of results to skip
   * @param maxResults  - the maximum number of results to return
   * @param callback    - a row handler for processing the results
   * @throws SQLException - if the procedure fails
   */
  public void executeQueryProcedure(StatementScope statementScope, Connection conn, String sql, Object[] parameters, int skipResults, int maxResults, RowHandlerCallback callback) throws SQLException {
<span class="fc" id="L252">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L253">    errorContext.setActivity(&quot;executing query procedure&quot;);</span>
<span class="fc" id="L254">    errorContext.setObjectId(sql);</span>
<span class="fc" id="L255">    CallableStatement cs = null;</span>
<span class="fc" id="L256">    ResultSet rs = null;</span>
<span class="fc" id="L257">    setupResultObjectFactory(statementScope);</span>
    try {
<span class="fc" id="L259">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="fc" id="L260">      Integer rsType = statementScope.getStatement().getResultSetType();</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">      if (rsType != null) {</span>
<span class="nc" id="L262">        cs = prepareCall(statementScope.getSession(), conn, sql, rsType);</span>
<span class="nc" id="L263">      } else {</span>
<span class="fc" id="L264">        cs = prepareCall(statementScope.getSession(), conn, sql);</span>
      }
<span class="fc" id="L266">      setStatementTimeout(statementScope.getStatement(), cs);</span>
<span class="fc" id="L267">      Integer fetchSize = statementScope.getStatement().getFetchSize();</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">      if (fetchSize != null) {</span>
<span class="nc" id="L269">        cs.setFetchSize(fetchSize.intValue());</span>
      }
<span class="fc" id="L271">      ParameterMap parameterMap = statementScope.getParameterMap();</span>
<span class="fc" id="L272">      ParameterMapping[] mappings = parameterMap.getParameterMappings();</span>
<span class="fc" id="L273">      errorContext.setMoreInfo(&quot;Check the output parameters (register output parameters failed).&quot;);</span>
<span class="fc" id="L274">      registerOutputParameters(cs, mappings);</span>
<span class="fc" id="L275">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="fc" id="L276">      parameterMap.setParameters(statementScope, cs, parameters);</span>
<span class="fc" id="L277">      errorContext.setMoreInfo(&quot;Check the statement (update procedure failed).&quot;);</span>
<span class="fc" id="L278">      cs.execute();</span>
<span class="fc" id="L279">      errorContext.setMoreInfo(&quot;Check the results (failed to retrieve results).&quot;);</span>

      // Begin ResultSet Handling
<span class="fc" id="L282">      rs = handleMultipleResults(cs, statementScope, skipResults, maxResults, callback);</span>
      // End ResultSet Handling
<span class="fc" id="L284">      errorContext.setMoreInfo(&quot;Check the output parameters (retrieval of output parameters failed).&quot;);</span>
<span class="fc" id="L285">      retrieveOutputParameters(statementScope, cs, mappings, parameters, callback);</span>

<span class="pc" id="L287">    } finally {</span>
      try {
<span class="pc" id="L289">        closeResultSet(rs);</span>
<span class="pc" id="L290">      } finally {</span>
<span class="pc" id="L291">        closeStatement(statementScope.getSession(), cs);</span>
<span class="pc" id="L292">        cleanupResultObjectFactory();</span>
<span class="nc" id="L293">      }</span>
<span class="nc" id="L294">    }</span>
<span class="fc" id="L295">  }</span>
  
  public void init(SqlMapConfiguration config, Properties globalProps) {
    // No implementation is required in DefaultSqlExecutor.
<span class="nc" id="L299">  }</span>

  private ResultSet handleMultipleResults(PreparedStatement ps, StatementScope statementScope, int skipResults, int maxResults, RowHandlerCallback callback) throws SQLException {
    ResultSet rs;
<span class="fc" id="L303">    rs = getFirstResultSet(statementScope, ps);</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">    if (rs != null) {</span>
<span class="fc" id="L305">      handleResults(statementScope, rs, skipResults, maxResults, callback);</span>
    }

    // Multiple ResultSet handling
<span class="fc bfc" id="L309" title="All 2 branches covered.">    if (callback.getRowHandler() instanceof DefaultRowHandler) {</span>
<span class="fc" id="L310">      MappedStatement statement = statementScope.getStatement();</span>
<span class="fc" id="L311">      DefaultRowHandler defaultRowHandler = ((DefaultRowHandler) callback.getRowHandler());</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">      if (statement.hasMultipleResultMaps()) {</span>
<span class="fc" id="L313">        List multipleResults = new ArrayList();</span>
<span class="fc" id="L314">        multipleResults.add(defaultRowHandler.getList());</span>
<span class="fc" id="L315">        ResultMap[] resultMaps = statement.getAdditionalResultMaps();</span>
<span class="fc" id="L316">        int i = 0;</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        while (moveToNextResultsSafely(statementScope, ps)) {</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">          if (i &gt;= resultMaps.length) break;</span>
<span class="fc" id="L319">          ResultMap rm = resultMaps[i];</span>
<span class="fc" id="L320">          statementScope.setResultMap(rm);</span>
<span class="fc" id="L321">          rs = ps.getResultSet();</span>
<span class="fc" id="L322">          DefaultRowHandler rh = new DefaultRowHandler();</span>
<span class="fc" id="L323">          handleResults(statementScope, rs, skipResults, maxResults, new RowHandlerCallback(rm, null, rh));</span>
<span class="fc" id="L324">          multipleResults.add(rh.getList());</span>
<span class="fc" id="L325">          i++;</span>
        }
<span class="fc" id="L327">        defaultRowHandler.setList(multipleResults);</span>
<span class="fc" id="L328">        statementScope.setResultMap(statement.getResultMap());</span>
<span class="fc" id="L329">      } else {</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        while (moveToNextResultsSafely(statementScope, ps)) ;</span>
      }
    }
    // End additional ResultSet handling
<span class="fc" id="L334">    return rs;</span>
  }

  private ResultSet getFirstResultSet(StatementScope scope, Statement stmt) throws SQLException {
<span class="fc" id="L338">    ResultSet rs = null;</span>
<span class="fc" id="L339">    boolean hasMoreResults = true;</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">    while (hasMoreResults) {</span>
<span class="fc" id="L341">      rs = stmt.getResultSet();</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">      if (rs != null) {</span>
<span class="fc" id="L343">        break;</span>
      }
<span class="nc" id="L345">      hasMoreResults = moveToNextResultsIfPresent(scope, stmt);</span>
    }
<span class="fc" id="L347">    return rs;</span>
  }

  private boolean moveToNextResultsIfPresent(StatementScope scope, Statement stmt) throws SQLException {
    boolean moreResults;
    // This is the messed up JDBC approach for determining if there are more results
<span class="nc" id="L353">    boolean movedToNextResultsSafely = moveToNextResultsSafely(scope, stmt);</span>
<span class="nc" id="L354">    int updateCount = stmt.getUpdateCount();</span>
    
<span class="nc bnc" id="L356" title="All 4 branches missed.">    moreResults = !(!movedToNextResultsSafely &amp;&amp; (updateCount == -1));</span>
    
    //ibatis-384: workaround for mysql not returning -1 for stmt.getUpdateCount()
<span class="nc bnc" id="L359" title="All 2 branches missed.">    if (moreResults == true){</span>
<span class="nc bnc" id="L360" title="All 4 branches missed.">	moreResults = !(!movedToNextResultsSafely &amp;&amp; !isMultipleResultSetSupportPresent(scope, stmt));</span>
    }
    
<span class="nc" id="L363">    return moreResults;</span>
  }

  private boolean moveToNextResultsSafely(StatementScope scope, Statement stmt) throws SQLException {
<span class="fc bfc" id="L367" title="All 2 branches covered.">    if (isMultipleResultSetSupportPresent(scope, stmt)) {</span>
<span class="fc" id="L368">      return stmt.getMoreResults();</span>
    }
<span class="fc" id="L370">    return false;</span>
  }

  /**
   * checks whether multiple result set support is present - either by direct support of the database driver or by forcing it
   */
  private boolean isMultipleResultSetSupportPresent(StatementScope scope,
	  Statement stmt) throws SQLException {
<span class="pc bpc" id="L378" title="1 of 4 branches missed.">      return forceMultipleResultSetSupport(scope) || stmt.getConnection().getMetaData().supportsMultipleResultSets();</span>
  }

  private boolean forceMultipleResultSetSupport(StatementScope scope) {
<span class="fc" id="L382">    return ((SqlMapClientImpl)scope.getSession().getSqlMapClient()).getDelegate().isForceMultipleResultSetSupport();</span>
  }

  private void handleResults(StatementScope statementScope, ResultSet rs, int skipResults, int maxResults, RowHandlerCallback callback) throws SQLException {
    try {
<span class="fc" id="L387">      statementScope.setResultSet(rs);</span>
<span class="fc" id="L388">      ResultMap resultMap = statementScope.getResultMap();</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">      if (resultMap != null) {</span>
        // Skip Results
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (rs.getType() != ResultSet.TYPE_FORWARD_ONLY) {</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">          if (skipResults &gt; 0) {</span>
<span class="nc" id="L393">            rs.absolute(skipResults);</span>
          }
<span class="nc" id="L395">        } else {</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">          for (int i = 0; i &lt; skipResults; i++) {</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">            if (!rs.next()) {</span>
<span class="fc" id="L398">              return;</span>
            }
          }
        }

        // Get Results
<span class="fc" id="L404">        int resultsFetched = 0;</span>
<span class="fc bfc" id="L405" title="All 6 branches covered.">        while ((maxResults == NO_MAXIMUM_RESULTS || resultsFetched &lt; maxResults) &amp;&amp; rs.next()) {</span>
<span class="fc" id="L406">          Object[] columnValues = resultMap.resolveSubMap(statementScope, rs).getResults(statementScope, rs);</span>
<span class="fc" id="L407">          callback.handleResultObject(statementScope, columnValues, rs);</span>
<span class="fc" id="L408">          resultsFetched++;</span>
        }
      }
<span class="fc" id="L411">    } finally {</span>
<span class="fc" id="L412">      statementScope.setResultSet(null);</span>
<span class="fc" id="L413">    }</span>
<span class="fc" id="L414">  }</span>

  private void retrieveOutputParameters(StatementScope statementScope, CallableStatement cs, ParameterMapping[] mappings, Object[] parameters, RowHandlerCallback callback) throws SQLException {
<span class="fc bfc" id="L417" title="All 2 branches covered.">    for (int i = 0; i &lt; mappings.length; i++) {</span>
<span class="fc" id="L418">      ParameterMapping mapping = ((ParameterMapping) mappings[i]);</span>
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">      if (mapping.isOutputAllowed()) {</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (&quot;java.sql.ResultSet&quot;.equalsIgnoreCase(mapping.getJavaTypeName())) {</span>
<span class="nc" id="L421">          ResultSet rs = (ResultSet) cs.getObject(i + 1);</span>
          ResultMap resultMap;
<span class="nc bnc" id="L423" title="All 2 branches missed.">          if (mapping.getResultMapName() == null) {</span>
<span class="nc" id="L424">            resultMap = statementScope.getResultMap();</span>
<span class="nc" id="L425">            handleOutputParameterResults(statementScope, resultMap, rs, callback);</span>
<span class="nc" id="L426">          } else {</span>
<span class="nc" id="L427">            SqlMapClientImpl client = (SqlMapClientImpl) statementScope.getSession().getSqlMapClient();</span>
<span class="nc" id="L428">            resultMap = client.getDelegate().getResultMap(mapping.getResultMapName());</span>
<span class="nc" id="L429">            DefaultRowHandler rowHandler = new DefaultRowHandler();</span>
<span class="nc" id="L430">            RowHandlerCallback handlerCallback = new RowHandlerCallback(resultMap, null, rowHandler);</span>
<span class="nc" id="L431">            handleOutputParameterResults(statementScope, resultMap, rs, handlerCallback);</span>
<span class="nc" id="L432">            parameters[i] = rowHandler.getList();</span>
          }
<span class="nc" id="L434">          rs.close();</span>
<span class="nc" id="L435">        } else {</span>
<span class="nc" id="L436">          parameters[i] = mapping.getTypeHandler().getResult(cs, i + 1);</span>
        }
      }
    }
<span class="fc" id="L440">  }</span>

  private void registerOutputParameters(CallableStatement cs, ParameterMapping[] mappings) throws SQLException {
<span class="fc bfc" id="L443" title="All 2 branches covered.">    for (int i = 0; i &lt; mappings.length; i++) {</span>
<span class="fc" id="L444">      ParameterMapping mapping = ((ParameterMapping) mappings[i]);</span>
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">      if (mapping.isOutputAllowed()) {</span>
<span class="nc bnc" id="L446" title="All 4 branches missed.">        if (null != mapping.getTypeName() &amp;&amp; !mapping.getTypeName().equals(&quot;&quot;)) { //@added</span>
<span class="nc" id="L447">          cs.registerOutParameter(i + 1, mapping.getJdbcType(), mapping.getTypeName());</span>
<span class="nc" id="L448">        } else {</span>
<span class="nc bnc" id="L449" title="All 6 branches missed.">          if (mapping.getNumericScale() != null &amp;&amp; (mapping.getJdbcType() == Types.NUMERIC || mapping.getJdbcType() == Types.DECIMAL))</span>
          {
<span class="nc" id="L451">            cs.registerOutParameter(i + 1, mapping.getJdbcType(), mapping.getNumericScale().intValue());</span>
<span class="nc" id="L452">          } else {</span>
<span class="nc" id="L453">            cs.registerOutParameter(i + 1, mapping.getJdbcType());</span>
          }
        }
      }
    }
<span class="fc" id="L458">  }</span>

  private void handleOutputParameterResults(StatementScope statementScope, ResultMap resultMap, ResultSet rs, RowHandlerCallback callback) throws SQLException {
<span class="nc" id="L461">    ResultMap orig = statementScope.getResultMap();</span>
    try {
<span class="nc" id="L463">      statementScope.setResultSet(rs);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">      if (resultMap != null) {</span>
<span class="nc" id="L465">        statementScope.setResultMap(resultMap);</span>

        // Get Results
<span class="nc bnc" id="L468" title="All 2 branches missed.">        while (rs.next()) {</span>
<span class="nc" id="L469">          Object[] columnValues = resultMap.resolveSubMap(statementScope, rs).getResults(statementScope, rs);</span>
<span class="nc" id="L470">          callback.handleResultObject(statementScope, columnValues, rs);</span>
        }
      }
<span class="nc" id="L473">    } finally {</span>
<span class="nc" id="L474">      statementScope.setResultSet(null);</span>
<span class="nc" id="L475">      statementScope.setResultMap(orig);</span>
<span class="nc" id="L476">    }</span>
<span class="nc" id="L477">  }</span>

  /**
   * Clean up any batches on the session
   *
   * @param sessionScope - the session to clean up
   */
  public void cleanup(SessionScope sessionScope) {
<span class="fc" id="L485">    Batch batch = (Batch) sessionScope.getBatch();</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">    if (batch != null) {</span>
<span class="fc" id="L487">      batch.cleanupBatch(sessionScope);</span>
<span class="fc" id="L488">      sessionScope.setBatch(null);</span>
    }
<span class="fc" id="L490">  }</span>

  private PreparedStatement prepareStatement(SessionScope sessionScope, Connection conn, String sql, Integer rsType) throws SQLException {
<span class="nc" id="L493">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="nc" id="L495">      return sessionScope.getPreparedStatement((sql));</span>
    } else {
<span class="nc" id="L497">      PreparedStatement ps = conn.prepareStatement(sql, rsType.intValue(), ResultSet.CONCUR_READ_ONLY);</span>
<span class="nc" id="L498">      sessionScope.putPreparedStatement(delegate, sql, ps);</span>
<span class="nc" id="L499">      return ps;</span>
    }
  }

  private CallableStatement prepareCall(SessionScope sessionScope, Connection conn, String sql, Integer rsType) throws SQLException {
<span class="nc" id="L504">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="nc" id="L506">      return (CallableStatement) sessionScope.getPreparedStatement((sql));</span>
    } else {
<span class="nc" id="L508">      CallableStatement cs = conn.prepareCall(sql, rsType.intValue(), ResultSet.CONCUR_READ_ONLY);</span>
<span class="nc" id="L509">      sessionScope.putPreparedStatement(delegate, sql, cs);</span>
<span class="nc" id="L510">      return cs;</span>
    }
  }

  private static PreparedStatement prepareStatement(SessionScope sessionScope, Connection conn, String sql) throws SQLException {
<span class="fc" id="L515">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="fc" id="L517">      return sessionScope.getPreparedStatement((sql));</span>
    } else {
<span class="fc" id="L519">      PreparedStatement ps = conn.prepareStatement(sql);</span>
<span class="fc" id="L520">      sessionScope.putPreparedStatement(delegate, sql, ps);</span>
<span class="fc" id="L521">      return ps;</span>
    }
  }

  private CallableStatement prepareCall(SessionScope sessionScope, Connection conn, String sql) throws SQLException {
<span class="fc" id="L526">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="nc" id="L528">      return (CallableStatement) sessionScope.getPreparedStatement((sql));</span>
    } else {
<span class="fc" id="L530">      CallableStatement cs = conn.prepareCall(sql);</span>
<span class="fc" id="L531">      sessionScope.putPreparedStatement(delegate, sql, cs);</span>
<span class="fc" id="L532">      return cs;</span>
    }
  }

  private static void closeStatement(SessionScope sessionScope, PreparedStatement ps) {
<span class="fc bfc" id="L537" title="All 2 branches covered.">    if (ps != null) {</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">      if (!sessionScope.hasPreparedStatement(ps)) {</span>
        try {
<span class="fc" id="L540">          ps.close();</span>
<span class="pc" id="L541">        } catch (SQLException e) {</span>
          // ignore
        }
      }
    }
<span class="fc" id="L546">  }</span>

  /**
   * @param rs
   */
  private static void closeResultSet(ResultSet rs) {
<span class="fc bfc" id="L552" title="All 2 branches covered.">    if (rs != null) {</span>
      try {
<span class="fc" id="L554">        rs.close();</span>
<span class="pc" id="L555">      } catch (SQLException e) {</span>
        // ignore
      }
    }
<span class="fc" id="L559">  }</span>

  private static void setStatementTimeout(MappedStatement mappedStatement, Statement statement) throws SQLException {
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">    if (mappedStatement.getTimeout() != null) {</span>
<span class="nc" id="L563">      statement.setQueryTimeout(mappedStatement.getTimeout().intValue());</span>
    }
<span class="fc" id="L565">  }</span>

  //
  // Inner Classes
  //

  private static class Batch {
    private String currentSql;
<span class="fc" id="L573">    private List statementList = new ArrayList();</span>
<span class="fc" id="L574">    private List batchResultList = new ArrayList();</span>
    private int size;

    /**
     * Create a new batch
     */
<span class="fc" id="L580">    public Batch() {</span>
<span class="fc" id="L581">      this.size = 0;</span>
<span class="fc" id="L582">    }</span>

    /**
     * Getter for the batch size
     *
     * @return - the batch size
     */
    public int getSize() {
<span class="nc" id="L590">      return size;</span>
    }

    /**
     * Add a prepared statement to the batch
     *
     * @param statementScope    - the request scope
     * @param conn       - the database connection
     * @param sql        - the SQL to add
     * @param parameters - the parameters for the SQL
     * @throws SQLException - if the prepare for the SQL fails
     */
    public void addBatch(StatementScope statementScope, Connection conn, String sql, Object[] parameters) throws SQLException {
<span class="fc" id="L603">      PreparedStatement ps = null;</span>
<span class="fc bfc" id="L604" title="All 4 branches covered.">      if (currentSql != null &amp;&amp; currentSql.equals(sql)) {</span>
<span class="fc" id="L605">        int last = statementList.size() - 1;</span>
<span class="fc" id="L606">        ps = (PreparedStatement) statementList.get(last);</span>
<span class="fc" id="L607">      } else {</span>
<span class="fc" id="L608">        ps = prepareStatement(statementScope.getSession(), conn, sql);</span>
<span class="fc" id="L609">        setStatementTimeout(statementScope.getStatement(), ps);</span>
<span class="fc" id="L610">        currentSql = sql;</span>
<span class="fc" id="L611">        statementList.add(ps);</span>
<span class="fc" id="L612">        batchResultList.add(new BatchResult(statementScope.getStatement().getId(), sql));</span>
      }
<span class="fc" id="L614">      statementScope.getParameterMap().setParameters(statementScope, ps, parameters);</span>
<span class="fc" id="L615">      ps.addBatch();</span>
<span class="fc" id="L616">      size++;</span>
<span class="fc" id="L617">    }</span>

    /**
     * TODO (Jeff Butler) - maybe this method should be deprecated in some release,
     * and then removed in some even later release.  executeBatchDetailed gives
     * much more complete information.
     * &lt;p/&gt;
     * Execute the current session's batch
     *
     * @return - the number of rows updated
     * @throws SQLException - if the batch fails
     */
    public int executeBatch() throws SQLException {
<span class="fc" id="L630">      int totalRowCount = 0;</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">      for (int i = 0, n = statementList.size(); i &lt; n; i++) {</span>
<span class="fc" id="L632">        PreparedStatement ps = (PreparedStatement) statementList.get(i);</span>
<span class="fc" id="L633">        int[] rowCounts = ps.executeBatch();</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">        for (int j = 0; j &lt; rowCounts.length; j++) {</span>
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">          if (rowCounts[j] == Statement.SUCCESS_NO_INFO) {</span>
            // do nothing
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">          } else if (rowCounts[j] == Statement.EXECUTE_FAILED) {</span>
<span class="nc" id="L638">            throw new SQLException(&quot;The batched statement at index &quot; + j + &quot; failed to execute.&quot;);</span>
          } else {
<span class="fc" id="L640">            totalRowCount += rowCounts[j];</span>
          }
        }
      }
<span class="fc" id="L644">      return totalRowCount;</span>
    }

    /**
     * Batch execution method that returns all the information
     * the driver has to offer.
     *
     * @return a List of BatchResult objects
     * @throws BatchException (an SQLException sub class) if any nested
     *                        batch fails
     * @throws SQLException   if a database access error occurs, or the drive
     *                        does not support batch statements
     * @throws BatchException if the driver throws BatchUpdateException
     */
    public List executeBatchDetailed() throws SQLException, BatchException {
<span class="fc" id="L659">      List answer = new ArrayList();</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">      for (int i = 0, n = statementList.size(); i &lt; n; i++) {</span>
<span class="fc" id="L661">        BatchResult br = (BatchResult) batchResultList.get(i);</span>
<span class="fc" id="L662">        PreparedStatement ps = (PreparedStatement) statementList.get(i);</span>
        try {
<span class="fc" id="L664">          br.setUpdateCounts(ps.executeBatch());</span>
<span class="fc" id="L665">        } catch (BatchUpdateException e) {</span>
<span class="fc" id="L666">          StringBuffer message = new StringBuffer();</span>
<span class="fc" id="L667">          message.append(&quot;Sub batch number &quot;);</span>
<span class="fc" id="L668">          message.append(i + 1);</span>
<span class="fc" id="L669">          message.append(&quot; failed.&quot;);</span>
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">          if (i &gt; 0) {</span>
<span class="fc" id="L671">            message.append(&quot; &quot;);</span>
<span class="fc" id="L672">            message.append(i);</span>
<span class="fc" id="L673">            message.append(&quot; prior sub batch(s) completed successfully, but will be rolled back.&quot;);</span>
          }
<span class="fc" id="L675">          throw new BatchException(message.toString(), e, answer, br.getStatementId(), br.getSql());</span>
        }
<span class="fc" id="L677">        answer.add(br);</span>
      }
<span class="fc" id="L679">      return answer;</span>
    }

    /**
     * Close all the statements in the batch and clear all the statements
     *
     * @param sessionScope
     */
    public void cleanupBatch(SessionScope sessionScope) {
<span class="fc bfc" id="L688" title="All 2 branches covered.">      for (int i = 0, n = statementList.size(); i &lt; n; i++) {</span>
<span class="fc" id="L689">        PreparedStatement ps = (PreparedStatement) statementList.get(i);</span>
<span class="fc" id="L690">        closeStatement(sessionScope, ps);</span>
      }
<span class="fc" id="L692">      currentSql = null;</span>
<span class="fc" id="L693">      statementList.clear();</span>
<span class="fc" id="L694">      batchResultList.clear();</span>
<span class="fc" id="L695">      size = 0;</span>
<span class="fc" id="L696">    }</span>
  }

  private void setupResultObjectFactory(StatementScope statementScope) {
<span class="fc" id="L700">    SqlMapClientImpl client = (SqlMapClientImpl) statementScope.getSession().getSqlMapClient();</span>
<span class="fc" id="L701">    ResultObjectFactoryUtil.setupResultObjectFactory(client.getResultObjectFactory(),</span>
<span class="fc" id="L702">        statementScope.getStatement().getId());</span>
<span class="fc" id="L703">  }</span>
  
  private void cleanupResultObjectFactory() {
<span class="fc" id="L706">    ResultObjectFactoryUtil.cleanupResultObjectFactory();</span>
<span class="fc" id="L707">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>