<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ResultMap.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.mapping.result</a> &gt; <span class="el_source">ResultMap.java</span></div><h1>ResultMap.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2004-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.mapping.result;

import com.ibatis.common.beans.Probe;
import com.ibatis.common.beans.ProbeFactory;
import com.ibatis.common.jdbc.exception.NestedSQLException;

import com.ibatis.sqlmap.client.SqlMapException;
import com.ibatis.sqlmap.engine.exchange.DataExchange;
import com.ibatis.sqlmap.engine.impl.SqlMapClientImpl;
import com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate;
import com.ibatis.sqlmap.engine.mapping.result.loader.ResultLoader;
import com.ibatis.sqlmap.engine.mapping.sql.Sql;
import com.ibatis.sqlmap.engine.mapping.statement.MappedStatement;
import com.ibatis.sqlmap.engine.scope.ErrorContext;
import com.ibatis.sqlmap.engine.scope.StatementScope;
import com.ibatis.sqlmap.engine.type.DomCollectionTypeMarker;
import com.ibatis.sqlmap.engine.type.DomTypeMarker;
import com.ibatis.sqlmap.engine.type.TypeHandler;
import com.ibatis.sqlmap.engine.type.TypeHandlerFactory;
import org.w3c.dom.Document;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

/**
 * Basic implementation of ResultMap interface
<span class="fc" id="L53"> */</span>
public class ResultMap {

  private static final Probe PROBE = ProbeFactory.getProbe();
  private static final String KEY_SEPARATOR = &quot;\002&quot;;

  private String id;
  private Class resultClass;
<span class="fc" id="L61"></span>
  // DO NOT ACCESS EITHER OF THESE OUTSIDE OF THEIR BEAN GETTER/SETTER
  private ResultMapping[] resultMappings;
  private ThreadLocal remappableResultMappings = new ThreadLocal();

  private DataExchange dataExchange;

  private List nestedResultMappings;

  private Discriminator discriminator;

  private Set groupByProps;

  private String xmlName;

  private String resource;
<span class="fc" id="L77"></span>
<span class="fc" id="L78">  protected SqlMapExecutorDelegate delegate;</span>

  protected boolean allowRemapping = false;
  public static final Object NO_VALUE = new Object();

  /**
   * Constructor to pass a SqlMapExecutorDelegate in
   *
<span class="fc" id="L86">   * @param delegate</span>
<span class="fc" id="L87">   *          - the SqlMapExecutorDelegate</span>
<span class="fc" id="L88">   */</span>
  public ResultMap(SqlMapExecutorDelegate delegate) {
    this.delegate = delegate;
  }

  /**
   * Getter for the SqlMapExecutorDelegate
   *
<span class="fc" id="L96">   * @return - the delegate</span>
   */
  public SqlMapExecutorDelegate getDelegate() {
    return delegate;
<span class="fc" id="L100">  }</span>

  public String getId() {
    return id;
  }

  /**
   * Setter for the ID
   *
   * @param id
<span class="fc" id="L110">   *          - the new ID</span>
<span class="fc" id="L111">   */</span>
  public void setId(String id) {
    this.id = id;
<span class="fc" id="L114">  }</span>

  public Class getResultClass() {
    return resultClass;
<span class="fc bfc" id="L118" title="All 2 branches covered.">  }</span>

<span class="fc bfc" id="L120" title="All 2 branches covered.">  public Object getUniqueKey(String keyPrefix, Object[] values) {</span>
<span class="fc" id="L121">    if (groupByProps != null) {</span>
      StringBuffer keyBuffer;
<span class="fc" id="L123">      if (keyPrefix != null)</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        keyBuffer = new StringBuffer(keyPrefix);</span>
<span class="fc" id="L125">      else</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        keyBuffer = new StringBuffer();</span>
<span class="fc" id="L127">      for (int i = 0; i &lt; getResultMappings().length; i++) {</span>
<span class="fc" id="L128">        String propertyName = getResultMappings()[i].getPropertyName();</span>
        if (groupByProps.contains(propertyName)) {
          keyBuffer.append(values[i]);
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">          keyBuffer.append('-');</span>
<span class="nc" id="L132">        }</span>
      }
      if (keyBuffer.length() &lt; 1) {
<span class="fc" id="L135">        return null;</span>
<span class="fc" id="L136">      } else {</span>
        // seperator value not likely to appear in a database
        keyBuffer.append(KEY_SEPARATOR);
<span class="fc" id="L139">        return keyBuffer.toString();</span>
      }
    } else {
      return null;
    }
<span class="nc" id="L144">  }</span>

  public Object getUniqueKey(Object[] values) {
    return getUniqueKey(null, values);
  }

  /**
   * Setter for the result class (what the results will be mapped into)
   *
   * @param resultClass
<span class="fc" id="L154">   *          - the result class</span>
<span class="fc" id="L155">   */</span>
  public void setResultClass(Class resultClass) {
    this.resultClass = resultClass;
  }

  /**
   * Getter for the DataExchange object to be used
   *
<span class="nc" id="L163">   * @return - the DataExchange object</span>
   */
  public DataExchange getDataExchange() {
    return dataExchange;
  }

  /**
   * Setter for the DataExchange object to be used
   *
   * @param dataExchange
<span class="nc" id="L173">   *          - the new DataExchange object</span>
<span class="nc" id="L174">   */</span>
  public void setDataExchange(DataExchange dataExchange) {
    this.dataExchange = dataExchange;
  }

  /**
   * Getter (used by DomDataExchange) for the xml name of the results
   *
<span class="fc" id="L182">   * @return - the name</span>
   */
  public String getXmlName() {
    return xmlName;
  }

  /**
   * Setter (used by the SqlMapBuilder) for the xml name of the results
   *
   * @param xmlName
<span class="fc" id="L192">   *          - the name</span>
<span class="fc" id="L193">   */</span>
  public void setXmlName(String xmlName) {
    this.xmlName = xmlName;
  }

  /**
   * Getter for the resource (used to report errors)
   *
<span class="fc" id="L201">   * @return - the resource</span>
   */
  public String getResource() {
    return resource;
  }

  /**
   * Setter for the resource (used by the SqlMapBuilder)
   *
   * @param resource
<span class="fc" id="L211">   *          - the resource name</span>
<span class="fc" id="L212">   */</span>
  public void setResource(String resource) {
    this.resource = resource;
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">  }</span>
<span class="fc" id="L216"></span>
  public void addGroupByProperty(String name) {
<span class="fc" id="L218">    if (groupByProps == null) {</span>
<span class="fc" id="L219">      groupByProps = new HashSet();</span>
    }
    groupByProps.add(name);
<span class="pc bpc" id="L222" title="1 of 4 branches missed.">  }</span>

  public boolean hasGroupBy() {
    return groupByProps != null &amp;&amp; groupByProps.size() &gt; 0;
<span class="fc" id="L226">  }</span>

  public Iterator groupByProps() {
    return groupByProps.iterator();
<span class="fc bfc" id="L230" title="All 2 branches covered.">  }</span>
<span class="fc" id="L231"></span>
  public void addNestedResultMappings(ResultMapping mapping) {
<span class="fc" id="L233">    if (nestedResultMappings == null) {</span>
<span class="fc" id="L234">      nestedResultMappings = new ArrayList();</span>
    }
    nestedResultMappings.add(mapping);
<span class="fc" id="L237">  }</span>

  public List getNestedResultMappings() {
    return nestedResultMappings;
<span class="fc bfc" id="L241" title="All 2 branches covered.">  }</span>
<span class="fc" id="L242"></span>
  public ResultMapping[] getResultMappings() {
<span class="fc" id="L244">    if (allowRemapping) {</span>
      return (ResultMapping[]) remappableResultMappings.get();
    } else {
      return resultMappings;
    }
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">  }</span>
<span class="nc" id="L250"></span>
  public void setDiscriminator(Discriminator discriminator) {
<span class="fc" id="L252">    if (this.discriminator != null) {</span>
<span class="fc" id="L253">      throw new SqlMapException(&quot;A discriminator may only be set once per result map.&quot;);</span>
    }
    this.discriminator = discriminator;
<span class="fc" id="L256">  }</span>

  public Discriminator getDiscriminator() {
    return discriminator;
<span class="fc" id="L260">  }</span>
<span class="fc bfc" id="L261" title="All 2 branches covered."></span>
<span class="fc" id="L262">  public ResultMap resolveSubMap(StatementScope statementScope, ResultSet rs) throws SQLException {</span>
<span class="fc" id="L263">    ResultMap subMap = this;</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">    if (discriminator != null) {</span>
<span class="nc" id="L265">      ResultMapping mapping = (ResultMapping) discriminator.getResultMapping();</span>
      Object value = getPrimitiveResultMappingValue(rs, mapping);
<span class="fc" id="L267">      if (value == null) {</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        value = doNullMapping(value, mapping);</span>
<span class="fc" id="L269">      }</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">      subMap = discriminator.getSubMap(String.valueOf(value));</span>
<span class="fc" id="L271">      if (subMap == null) {</span>
        subMap = this;
      } else if (subMap != this) {
<span class="fc" id="L274">        subMap = subMap.resolveSubMap(statementScope, rs);</span>
      }
    }
    return subMap;
  }

  /**
   * Setter for a list of the individual ResultMapping objects
   *
   * @param resultMappingList
<span class="fc bfc" id="L284" title="All 2 branches covered.">   *          - the list</span>
<span class="fc" id="L285">   */</span>
  public void setResultMappingList(List resultMappingList) {
    if (allowRemapping) {
<span class="fc" id="L288">      this.remappableResultMappings.set((ResultMapping[]) resultMappingList.toArray(new ResultMapping[resultMappingList</span>
          .size()]));
    } else {
<span class="fc" id="L291">      this.resultMappings = (ResultMapping[]) resultMappingList.toArray(new ResultMapping[resultMappingList.size()]);</span>
<span class="fc" id="L292">    }</span>
<span class="fc" id="L293"></span>
<span class="fc" id="L294">    Map props = new HashMap();</span>
<span class="fc" id="L295">    props.put(&quot;map&quot;, this);</span>
    dataExchange = getDelegate().getDataExchangeFactory().getDataExchangeForClass(resultClass);
    dataExchange.initialize(props);
  }

  /**
   * Getter for the number of ResultMapping objects
   *
<span class="nc" id="L303">   * @return - the count</span>
   */
  public int getResultCount() {
    return this.getResultMappings().length;
  }

  /**
   * Read a row from a resultset and map results to an array.
   *
   * @param statementScope
   *          scope of the request
   * @param rs
   *          ResultSet to read from
   *
   * @return row read as an array of column values.
   *
<span class="fc" id="L319">   * @throws java.sql.SQLException</span>
<span class="fc" id="L320">   */</span>
<span class="fc" id="L321">  public Object[] getResults(StatementScope statementScope, ResultSet rs) throws SQLException {</span>
<span class="fc" id="L322">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L323">    errorContext.setActivity(&quot;applying a result map&quot;);</span>
    errorContext.setObjectId(this.getId());
<span class="fc" id="L325">    errorContext.setResource(this.getResource());</span>
<span class="fc" id="L326">    errorContext.setMoreInfo(&quot;Check the result map.&quot;);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered."></span>
<span class="fc" id="L328">    boolean foundData = false;</span>
<span class="fc" id="L329">    Object[] columnValues = new Object[getResultMappings().length];</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">    for (int i = 0; i &lt; getResultMappings().length; i++) {</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">      ResultMapping mapping = (ResultMapping) getResultMappings()[i];</span>
<span class="nc" id="L332">      errorContext.setMoreInfo(mapping.getErrorString());</span>
      if (mapping.getStatementName() != null) {
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        if (resultClass == null) {</span>
<span class="nc" id="L335">          throw new SqlMapException(&quot;The result class was null when trying to get results for ResultMap named &quot;</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">              + getId() + &quot;.&quot;);</span>
<span class="nc" id="L337">        } else if (Map.class.isAssignableFrom(resultClass)) {</span>
          Class javaType = mapping.getJavaType();
<span class="nc" id="L339">          if (javaType == null) {</span>
<span class="pc bfc" id="L340" title="All 2 branches covered.">            javaType = Object.class;</span>
<span class="fc" id="L341">          }</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">          columnValues[i] = getNestedSelectMappingValue(statementScope, rs, mapping, javaType);</span>
<span class="fc" id="L343">        } else if (DomTypeMarker.class.isAssignableFrom(resultClass)) {</span>
          Class javaType = mapping.getJavaType();
<span class="fc" id="L345">          if (javaType == null) {</span>
<span class="fc" id="L346">            javaType = DomTypeMarker.class;</span>
<span class="fc" id="L347">          }</span>
<span class="fc" id="L348">          columnValues[i] = getNestedSelectMappingValue(statementScope, rs, mapping, javaType);</span>
<span class="fc" id="L349">        } else {</span>
          Probe p = ProbeFactory.getProbe(resultClass);
<span class="pc bpc" id="L351" title="3 of 4 branches missed.">          Class type = p.getPropertyTypeForSetter(resultClass, mapping.getPropertyName());</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">          columnValues[i] = getNestedSelectMappingValue(statementScope, rs, mapping, type);</span>
<span class="fc" id="L353">        }</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        foundData = foundData || columnValues[i] != null;</span>
<span class="fc" id="L355">      } else if (mapping.getNestedResultMapName() == null) {</span>
        columnValues[i] = getPrimitiveResultMappingValue(rs, mapping);
<span class="fc" id="L357">        if (columnValues[i] == null) {</span>
          columnValues[i] = doNullMapping(columnValues[i], mapping);
        } else {
          foundData = true;
        }
<span class="fc" id="L362">      }</span>
    }
<span class="fc" id="L364"></span>
    statementScope.setRowDataFound(foundData);

    return columnValues;
<span class="fc" id="L368">  }</span>
<span class="fc" id="L369"></span>
<span class="fc" id="L370">  public Object setResultObjectValues(StatementScope statementScope, Object resultObject, Object[] values) {</span>
<span class="fc" id="L371">    final String previousNestedKey = statementScope.getCurrentNestedKey();</span>
<span class="fc bfc" id="L372" title="All 4 branches covered.">    String ukey = (String) getUniqueKey(statementScope.getCurrentNestedKey(), values);</span>
    Map uniqueKeys = statementScope.getUniqueKeys(this);
    statementScope.setCurrentNestedKey(ukey);
<span class="fc" id="L375">    if (uniqueKeys != null &amp;&amp; uniqueKeys.containsKey(ukey)) {</span>
<span class="fc" id="L376">      // Unique key is already known, so get the existing result object and process additional</span>
<span class="fc" id="L377">      // results.</span>
<span class="pc bpc" id="L378" title="1 of 6 branches missed.">      resultObject = uniqueKeys.get(ukey);</span>
      applyNestedResultMap(statementScope, resultObject, values);
      resultObject = NO_VALUE;
<span class="fc" id="L381">    } else if (ukey == null || uniqueKeys == null || !uniqueKeys.containsKey(ukey)) {</span>
      // Unique key is NOT known, so create a new result object and then process additional
<span class="fc bfc" id="L383" title="All 2 branches covered.">      // results.</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">      resultObject = dataExchange.setData(statementScope, this, resultObject, values);</span>
<span class="fc" id="L385">      // Lazy init key set, only if we're grouped by something (i.e. ukey != null)</span>
<span class="fc" id="L386">      if (ukey != null) {</span>
        if (uniqueKeys == null) {
<span class="fc" id="L388">          uniqueKeys = new HashMap();</span>
          statementScope.setUniqueKeys(this, uniqueKeys);
<span class="fc" id="L390">        }</span>
        uniqueKeys.put(ukey, resultObject);
      }
<span class="nc" id="L393">      applyNestedResultMap(statementScope, resultObject, values);</span>
    } else {
      // Otherwise, we don't care about these results.
<span class="fc" id="L396">      resultObject = NO_VALUE;</span>
<span class="fc" id="L397">    }</span>

    statementScope.setCurrentNestedKey(previousNestedKey);
    return resultObject;
<span class="pc bpc" id="L401" title="1 of 4 branches missed.">  }</span>
<span class="fc bfc" id="L402" title="All 2 branches covered."></span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">  private void applyNestedResultMap(StatementScope statementScope, Object resultObject, Object[] values) {</span>
<span class="fc" id="L404">    if (resultObject != null &amp;&amp; resultObject != NO_VALUE) {</span>
<span class="fc" id="L405">      if (nestedResultMappings != null) {</span>
        for (int i = 0, n = nestedResultMappings.size(); i &lt; n; i++) {
          ResultMapping resultMapping = (ResultMapping) nestedResultMappings.get(i);
          setNestedResultMappingValue(resultMapping, statementScope, resultObject, values);
<span class="fc" id="L409">        }</span>
      }
    }
  }

  /**
   * Some changes in this method for IBATIS-225:
   * &lt;ul&gt;
   * &lt;li&gt;We no longer require the nested property to be a collection. This will allow reuses of resultMaps on 1:1
   * relationships&lt;/li&gt;
   * &lt;li&gt;If the nested property is not a collection, then it will be created/replaced by the values generated from the
   * current row.&lt;/li&gt;
   * &lt;/ul&gt;
   * 
   * @param mapping
   * @param statementScope
   * @param resultObject
   * @param values
   */
  protected void setNestedResultMappingValue(ResultMapping mapping, StatementScope statementScope, Object resultObject,
<span class="fc" id="L429">      Object[] values) {</span>
<span class="fc" id="L430">    try {</span>

<span class="fc" id="L432">      String resultMapName = mapping.getNestedResultMapName();</span>
      ResultMap resultMap = getDelegate().getResultMap(resultMapName);
<span class="fc" id="L434">      // get the discriminated submap if it exists</span>
<span class="fc" id="L435">      resultMap = resultMap.resolveSubMap(statementScope, statementScope.getResultSet());</span>

<span class="fc" id="L437">      Class type = mapping.getJavaType();</span>
      String propertyName = mapping.getPropertyName();
<span class="fc bfc" id="L439" title="All 2 branches covered."></span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">      Object obj = PROBE.getObject(resultObject, propertyName);</span>
<span class="fc" id="L441"></span>
      if (obj == null) {
        if (type == null) {
          type = PROBE.getPropertyTypeForSetter(resultObject, propertyName);
        }

        try {
<span class="fc bfc" id="L448" title="All 2 branches covered.">          // create the object if is it a Collection. If not a Collection</span>
<span class="fc" id="L449">          // then we will just set the property to the object created</span>
<span class="fc" id="L450">          // in processing the nested result map</span>
          if (Collection.class.isAssignableFrom(type)) {
<span class="nc" id="L452">            obj = ResultObjectFactoryUtil.createObjectThroughFactory(type);</span>
<span class="nc" id="L453">            PROBE.setObject(resultObject, propertyName, obj);</span>
          }
<span class="fc" id="L455">        } catch (Exception e) {</span>
          throw new SqlMapException(&quot;Error instantiating collection property for mapping '&quot; + mapping.getPropertyName()
              + &quot;'.  Cause: &quot; + e, e);
        }
      }
<span class="fc" id="L460"></span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">      // JIRA 375</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">      // &quot;Provide a way for not creating items from nested ResultMaps when the items contain only null values&quot;</span>
<span class="nc" id="L463">      boolean subResultObjectAbsent = false;</span>
      if (mapping.getNotNullColumn() != null) {
        if (statementScope.getResultSet().getObject(mapping.getNotNullColumn()) == null) {
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">          subResultObjectAbsent = true;</span>
<span class="fc" id="L467">        }</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">      }</span>
<span class="fc" id="L469">      if (!subResultObjectAbsent) {</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">        values = resultMap.getResults(statementScope, statementScope.getResultSet());</span>
<span class="fc bfc" id="L471" title="All 4 branches covered.">        if (statementScope.isRowDataFound()) {</span>
<span class="fc" id="L472">          Object o = resultMap.setResultObjectValues(statementScope, null, values);</span>
          if (o != NO_VALUE) {
<span class="fc" id="L474">            if (obj != null &amp;&amp; obj instanceof Collection) {</span>
              ((Collection) obj).add(o);
            } else {
              PROBE.setObject(resultObject, propertyName, o);
            }
<span class="nc" id="L479">          }</span>
<span class="nc" id="L480">        }</span>
      }
<span class="fc" id="L482">    } catch (SQLException e) {</span>
<span class="fc" id="L483">      throw new SqlMapException(&quot;Error getting nested result map values for '&quot; + mapping.getPropertyName()</span>
          + &quot;'.  Cause: &quot; + e, e);
    }
  }

<span class="fc" id="L488">  protected Object getNestedSelectMappingValue(StatementScope statementScope, ResultSet rs, ResultMapping mapping,</span>
      Class targetType) throws SQLException {
<span class="fc" id="L490">    try {</span>
<span class="fc" id="L491">      TypeHandlerFactory typeHandlerFactory = getDelegate().getTypeHandlerFactory();</span>

<span class="fc" id="L493">      String statementName = mapping.getStatementName();</span>
<span class="fc" id="L494">      SqlMapClientImpl client = (SqlMapClientImpl) statementScope.getSession().getSqlMapClient();</span>
<span class="fc" id="L495"></span>
      MappedStatement mappedStatement = client.getMappedStatement(statementName);
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">      Class parameterType = mappedStatement.getParameterClass();</span>
<span class="nc" id="L498">      Object parameterObject = null;</span>

<span class="fc bfc" id="L500" title="All 2 branches covered.">      if (parameterType == null) {</span>
<span class="fc" id="L501">        parameterObject = prepareBeanParameterObject(statementScope, rs, mapping, parameterType);</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">      } else {</span>
<span class="fc" id="L503">        if (typeHandlerFactory.hasTypeHandler(parameterType)) {</span>
          parameterObject = preparePrimitiveParameterObject(rs, mapping, parameterType);
<span class="fc" id="L505">        } else if (DomTypeMarker.class.isAssignableFrom(parameterType)) {</span>
          parameterObject = prepareDomParameterObject(rs, mapping);
        } else {
          parameterObject = prepareBeanParameterObject(statementScope, rs, mapping, parameterType);
<span class="fc" id="L509">        }</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">      }</span>

<span class="fc" id="L512">      Object result = null;</span>
<span class="fc" id="L513">      if (parameterObject != null) {</span>
<span class="fc" id="L514"></span>
        Sql sql = mappedStatement.getSql();
<span class="pc bpc" id="L516" title="1 of 4 branches missed.">        ResultMap resultMap = sql.getResultMap(statementScope, parameterObject);</span>
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">        Class resultClass = resultMap.getResultClass();</span>
<span class="nc" id="L518"></span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">        if (resultClass != null &amp;&amp; !DomTypeMarker.class.isAssignableFrom(targetType)) {</span>
<span class="nc" id="L520">          if (DomCollectionTypeMarker.class.isAssignableFrom(resultClass)) {</span>
            targetType = DomCollectionTypeMarker.class;
          } else if (DomTypeMarker.class.isAssignableFrom(resultClass)) {
            targetType = DomTypeMarker.class;
<span class="fc" id="L524">          }</span>
        }
<span class="fc" id="L526"></span>
<span class="pc bpc" id="L527" title="3 of 4 branches missed.">        result = ResultLoader.loadResult(client, statementName, parameterObject, targetType);</span>
<span class="nc" id="L528"></span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">        String nullValue = mapping.getNullValue();</span>
<span class="nc" id="L530">        if (result == null &amp;&amp; nullValue != null) {</span>
          TypeHandler typeHandler = typeHandlerFactory.getTypeHandler(targetType);
          if (typeHandler != null) {
            result = typeHandler.valueOf(nullValue);
<span class="fc" id="L534">          }</span>
<span class="nc" id="L535">        }</span>
<span class="nc" id="L536">      }</span>
<span class="nc" id="L537">      return result;</span>
<span class="nc" id="L538">    } catch (InstantiationException e) {</span>
      throw new NestedSQLException(&quot;Error setting nested bean property.  Cause: &quot; + e, e);
    } catch (IllegalAccessException e) {
      throw new NestedSQLException(&quot;Error setting nested bean property.  Cause: &quot; + e, e);
    }

  }

<span class="fc" id="L546">  private Object preparePrimitiveParameterObject(ResultSet rs, ResultMapping mapping, Class parameterType)</span>
<span class="fc" id="L547">      throws SQLException {</span>
<span class="fc" id="L548">    Object parameterObject;</span>
<span class="fc" id="L549">    TypeHandlerFactory typeHandlerFactory = getDelegate().getTypeHandlerFactory();</span>
    TypeHandler th = typeHandlerFactory.getTypeHandler(parameterType);
    parameterObject = th.getResult(rs, mapping.getColumnName());
    return parameterObject;
  }
<span class="fc" id="L554"></span>
<span class="fc" id="L555">  private Document newDocument(String root) {</span>
<span class="fc" id="L556">    try {</span>
<span class="nc" id="L557">      Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();</span>
<span class="nc" id="L558">      doc.appendChild(doc.createElement(root));</span>
      return doc;
    } catch (ParserConfigurationException e) {
      throw new RuntimeException(&quot;Error creating XML document.  Cause: &quot; + e);
    }
<span class="fc" id="L563">  }</span>

<span class="fc" id="L565">  private Object prepareDomParameterObject(ResultSet rs, ResultMapping mapping) throws SQLException {</span>
<span class="fc" id="L566">    TypeHandlerFactory typeHandlerFactory = getDelegate().getTypeHandlerFactory();</span>

<span class="fc" id="L568">    Document doc = newDocument(&quot;parameter&quot;);</span>
    Probe probe = ProbeFactory.getProbe(doc);
<span class="fc" id="L570"></span>
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">    String complexName = mapping.getColumnName();</span>

<span class="fc" id="L573">    TypeHandler stringTypeHandler = typeHandlerFactory.getTypeHandler(String.class);</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">    if (complexName.indexOf('=') &gt; -1) {</span>
<span class="fc" id="L575">      // old 1.x style multiple params</span>
<span class="fc" id="L576">      StringTokenizer parser = new StringTokenizer(complexName, &quot;{}=, &quot;, false);</span>
<span class="fc" id="L577">      while (parser.hasMoreTokens()) {</span>
<span class="fc" id="L578">        String propName = parser.nextToken();</span>
<span class="fc" id="L579">        String colName = parser.nextToken();</span>
<span class="fc" id="L580">        Object propValue = stringTypeHandler.getResult(rs, colName);</span>
        probe.setObject(doc, propName, propValue.toString());
<span class="nc" id="L582">      }</span>
<span class="nc" id="L583">    } else {</span>
      // single param
      Object propValue = stringTypeHandler.getResult(rs, complexName);
<span class="fc" id="L586">      probe.setObject(doc, &quot;value&quot;, propValue.toString());</span>
    }

    return doc;
  }
<span class="fc" id="L591"></span>
  private Object prepareBeanParameterObject(StatementScope statementScope, ResultSet rs, ResultMapping mapping,
      Class parameterType) throws InstantiationException, IllegalAccessException, SQLException {
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">    TypeHandlerFactory typeHandlerFactory = getDelegate().getTypeHandlerFactory();</span>
<span class="nc" id="L595"></span>
    Object parameterObject;
<span class="fc" id="L597">    if (parameterType == null) {</span>
      parameterObject = new HashMap();
<span class="fc" id="L599">    } else {</span>
      parameterObject = ResultObjectFactoryUtil.createObjectThroughFactory(parameterType);
<span class="pc bpc" id="L601" title="3 of 4 branches missed.">    }</span>
<span class="fc" id="L602">    String complexName = mapping.getColumnName();</span>
<span class="fc bfc" id="L603" title="All 2 branches covered."></span>
<span class="fc" id="L604">    if (complexName.indexOf('=') &gt; -1 || complexName.indexOf(',') &gt; -1) {</span>
<span class="fc" id="L605">      StringTokenizer parser = new StringTokenizer(complexName, &quot;{}=, &quot;, false);</span>
<span class="fc" id="L606">      while (parser.hasMoreTokens()) {</span>
<span class="fc" id="L607">        String propName = parser.nextToken();</span>
<span class="fc" id="L608">        String colName = parser.nextToken();</span>
<span class="fc" id="L609">        Class propType = PROBE.getPropertyTypeForSetter(parameterObject, propName);</span>
<span class="fc" id="L610">        TypeHandler propTypeHandler = typeHandlerFactory.getTypeHandler(propType);</span>
<span class="fc" id="L611">        Object propValue = propTypeHandler.getResult(rs, colName);</span>
        PROBE.setObject(parameterObject, propName, propValue);
<span class="nc" id="L613">      }</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">    } else {</span>
<span class="nc" id="L615">      // single param</span>
      TypeHandler propTypeHandler = typeHandlerFactory.getTypeHandler(parameterType);
<span class="nc" id="L617">      if (propTypeHandler == null) {</span>
        propTypeHandler = typeHandlerFactory.getUnkownTypeHandler();
      }
<span class="fc" id="L620">      parameterObject = propTypeHandler.getResult(rs, complexName);</span>
    }

    return parameterObject;
<span class="fc" id="L624">  }</span>
<span class="fc" id="L625"></span>
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">  protected Object getPrimitiveResultMappingValue(ResultSet rs, ResultMapping mapping) throws SQLException {</span>
<span class="fc" id="L627">    Object value = null;</span>
<span class="fc" id="L628">    TypeHandler typeHandler = mapping.getTypeHandler();</span>
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">    if (typeHandler != null) {</span>
<span class="nc" id="L630">      String columnName = mapping.getColumnName();</span>
      int columnIndex = mapping.getColumnIndex();
<span class="fc" id="L632">      if (columnName == null) {</span>
        value = typeHandler.getResult(rs, columnIndex);
<span class="fc" id="L634">      } else {</span>
<span class="nc" id="L635">        value = typeHandler.getResult(rs, columnName);</span>
      }
    } else {
      throw new SqlMapException(&quot;No type handler could be found to map the property '&quot; + mapping.getPropertyName()
<span class="fc" id="L639">          + &quot;' to the column '&quot; + mapping.getColumnName()</span>
          + &quot;'.  One or both of the types, or the combination of types is not supported.&quot;);
    }
    return value;
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">  }</span>
<span class="fc" id="L644"></span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">  protected Object doNullMapping(Object value, ResultMapping mapping) throws SqlMapException {</span>
<span class="fc" id="L646">    if (value == null) {</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">      TypeHandler typeHandler = mapping.getTypeHandler();</span>
<span class="fc" id="L648">      if (typeHandler != null) {</span>
<span class="fc" id="L649">        String nullValue = mapping.getNullValue();</span>
        if (nullValue != null)
<span class="nc" id="L651">          value = typeHandler.valueOf(nullValue);</span>
        return value;
      } else {
        throw new SqlMapException(&quot;No type handler could be found to map the property '&quot; + mapping.getPropertyName()
            + &quot;' to the column '&quot; + mapping.getColumnName()
<span class="nc" id="L656">            + &quot;'.  One or both of the types, or the combination of types is not supported.&quot;);</span>
      }
    } else {
      return value;
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>