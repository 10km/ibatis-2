<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ResultMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.mapping.result</a> &gt; <span class="el_source">ResultMap.java</span></div><h1>ResultMap.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2004-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.mapping.result;

import com.ibatis.common.beans.Probe;
import com.ibatis.common.beans.ProbeFactory;
import com.ibatis.common.jdbc.exception.NestedSQLException;

import com.ibatis.sqlmap.client.SqlMapException;
import com.ibatis.sqlmap.engine.exchange.DataExchange;
import com.ibatis.sqlmap.engine.impl.SqlMapClientImpl;
import com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate;
import com.ibatis.sqlmap.engine.mapping.result.loader.ResultLoader;
import com.ibatis.sqlmap.engine.mapping.sql.Sql;
import com.ibatis.sqlmap.engine.mapping.statement.MappedStatement;
import com.ibatis.sqlmap.engine.scope.ErrorContext;
import com.ibatis.sqlmap.engine.scope.StatementScope;
import com.ibatis.sqlmap.engine.type.DomCollectionTypeMarker;
import com.ibatis.sqlmap.engine.type.DomTypeMarker;
import com.ibatis.sqlmap.engine.type.TypeHandler;
import com.ibatis.sqlmap.engine.type.TypeHandlerFactory;
import org.w3c.dom.Document;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

/**
 * Basic implementation of ResultMap interface.
 */
public class ResultMap {

  /** The Constant PROBE. */
<span class="fc" id="L57">  private static final Probe PROBE = ProbeFactory.getProbe();</span>

  /** The Constant KEY_SEPARATOR. */
  private static final String KEY_SEPARATOR = &quot;\002&quot;;

  /** The id. */
  private String id;

  /** The result class. */
  private Class resultClass;

  /** The result mappings. */
  // DO NOT ACCESS EITHER OF THESE OUTSIDE OF THEIR BEAN GETTER/SETTER
  private ResultMapping[] resultMappings;

  /** The remappable result mappings. */
<span class="fc" id="L73">  private ThreadLocal remappableResultMappings = new ThreadLocal();</span>

  /** The data exchange. */
  private DataExchange dataExchange;

  /** The nested result mappings. */
  private List nestedResultMappings;

  /** The discriminator. */
  private Discriminator discriminator;

  /** The group by props. */
  private Set groupByProps;

  /** The xml name. */
  private String xmlName;

  /** The resource. */
  private String resource;

  /** The delegate. */
  protected SqlMapExecutorDelegate delegate;

  /** The allow remapping. */
<span class="fc" id="L97">  protected boolean allowRemapping = false;</span>

  /** The Constant NO_VALUE. */
<span class="fc" id="L100">  public static final Object NO_VALUE = new Object();</span>

  /**
   * Constructor to pass a SqlMapExecutorDelegate in.
   *
   * @param delegate
   *          - the SqlMapExecutorDelegate
   */
<span class="fc" id="L108">  public ResultMap(SqlMapExecutorDelegate delegate) {</span>
<span class="fc" id="L109">    this.delegate = delegate;</span>
<span class="fc" id="L110">  }</span>

  /**
   * Getter for the SqlMapExecutorDelegate.
   *
   * @return - the delegate
   */
  public SqlMapExecutorDelegate getDelegate() {
<span class="fc" id="L118">    return delegate;</span>
  }

  /**
   * Gets the id.
   *
   * @return the id
   */
  public String getId() {
<span class="fc" id="L127">    return id;</span>
  }

  /**
   * Setter for the ID.
   *
   * @param id
   *          - the new ID
   */
  public void setId(String id) {
<span class="fc" id="L137">    this.id = id;</span>
<span class="fc" id="L138">  }</span>

  /**
   * Gets the result class.
   *
   * @return the result class
   */
  public Class getResultClass() {
<span class="fc" id="L146">    return resultClass;</span>
  }

  /**
   * Gets the unique key.
   *
   * @param keyPrefix
   *          the key prefix
   * @param values
   *          the values
   * @return the unique key
   */
  public Object getUniqueKey(String keyPrefix, Object[] values) {
<span class="fc bfc" id="L159" title="All 2 branches covered.">    if (groupByProps != null) {</span>
      StringBuilder keyBuffer;
<span class="fc bfc" id="L161" title="All 2 branches covered.">      if (keyPrefix != null)</span>
<span class="fc" id="L162">        keyBuffer = new StringBuilder(keyPrefix);</span>
      else
<span class="fc" id="L164">        keyBuffer = new StringBuilder();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">      for (int i = 0; i &lt; getResultMappings().length; i++) {</span>
<span class="fc" id="L166">        String propertyName = getResultMappings()[i].getPropertyName();</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (groupByProps.contains(propertyName)) {</span>
<span class="fc" id="L168">          keyBuffer.append(values[i]);</span>
<span class="fc" id="L169">          keyBuffer.append('-');</span>
        }
      }
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">      if (keyBuffer.length() &lt; 1) {</span>
<span class="nc" id="L173">        return null;</span>
      } else {
        // seperator value not likely to appear in a database
<span class="fc" id="L176">        keyBuffer.append(KEY_SEPARATOR);</span>
<span class="fc" id="L177">        return keyBuffer.toString();</span>
      }
    } else {
<span class="fc" id="L180">      return null;</span>
    }
  }

  /**
   * Gets the unique key.
   *
   * @param values
   *          the values
   * @return the unique key
   */
  public Object getUniqueKey(Object[] values) {
<span class="nc" id="L192">    return getUniqueKey(null, values);</span>
  }

  /**
   * Setter for the result class (what the results will be mapped into).
   *
   * @param resultClass
   *          - the result class
   */
  public void setResultClass(Class resultClass) {
<span class="fc" id="L202">    this.resultClass = resultClass;</span>
<span class="fc" id="L203">  }</span>

  /**
   * Getter for the DataExchange object to be used.
   *
   * @return - the DataExchange object
   */
  public DataExchange getDataExchange() {
<span class="nc" id="L211">    return dataExchange;</span>
  }

  /**
   * Setter for the DataExchange object to be used.
   *
   * @param dataExchange
   *          - the new DataExchange object
   */
  public void setDataExchange(DataExchange dataExchange) {
<span class="nc" id="L221">    this.dataExchange = dataExchange;</span>
<span class="nc" id="L222">  }</span>

  /**
   * Getter (used by DomDataExchange) for the xml name of the results.
   *
   * @return - the name
   */
  public String getXmlName() {
<span class="fc" id="L230">    return xmlName;</span>
  }

  /**
   * Setter (used by the SqlMapBuilder) for the xml name of the results.
   *
   * @param xmlName
   *          - the name
   */
  public void setXmlName(String xmlName) {
<span class="fc" id="L240">    this.xmlName = xmlName;</span>
<span class="fc" id="L241">  }</span>

  /**
   * Getter for the resource (used to report errors).
   *
   * @return - the resource
   */
  public String getResource() {
<span class="fc" id="L249">    return resource;</span>
  }

  /**
   * Setter for the resource (used by the SqlMapBuilder).
   *
   * @param resource
   *          - the resource name
   */
  public void setResource(String resource) {
<span class="fc" id="L259">    this.resource = resource;</span>
<span class="fc" id="L260">  }</span>

  /**
   * Adds the group by property.
   *
   * @param name
   *          the name
   */
  public void addGroupByProperty(String name) {
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">    if (groupByProps == null) {</span>
<span class="fc" id="L270">      groupByProps = new HashSet();</span>
    }
<span class="fc" id="L272">    groupByProps.add(name);</span>
<span class="fc" id="L273">  }</span>

  /**
   * Checks for group by.
   *
   * @return true, if successful
   */
  public boolean hasGroupBy() {
<span class="pc bpc" id="L281" title="1 of 4 branches missed.">    return groupByProps != null &amp;&amp; groupByProps.size() &gt; 0;</span>
  }

  /**
   * Group by props.
   *
   * @return the iterator
   */
  public Iterator groupByProps() {
<span class="fc" id="L290">    return groupByProps.iterator();</span>
  }

  /**
   * Adds the nested result mappings.
   *
   * @param mapping
   *          the mapping
   */
  public void addNestedResultMappings(ResultMapping mapping) {
<span class="fc bfc" id="L300" title="All 2 branches covered.">    if (nestedResultMappings == null) {</span>
<span class="fc" id="L301">      nestedResultMappings = new ArrayList();</span>
    }
<span class="fc" id="L303">    nestedResultMappings.add(mapping);</span>
<span class="fc" id="L304">  }</span>

  /**
   * Gets the nested result mappings.
   *
   * @return the nested result mappings
   */
  public List getNestedResultMappings() {
<span class="fc" id="L312">    return nestedResultMappings;</span>
  }

  /**
   * Gets the result mappings.
   *
   * @return the result mappings
   */
  public ResultMapping[] getResultMappings() {
<span class="fc bfc" id="L321" title="All 2 branches covered.">    if (allowRemapping) {</span>
<span class="fc" id="L322">      return (ResultMapping[]) remappableResultMappings.get();</span>
    } else {
<span class="fc" id="L324">      return resultMappings;</span>
    }
  }

  /**
   * Sets the discriminator.
   *
   * @param discriminator
   *          the new discriminator
   */
  public void setDiscriminator(Discriminator discriminator) {
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">    if (this.discriminator != null) {</span>
<span class="nc" id="L336">      throw new SqlMapException(&quot;A discriminator may only be set once per result map.&quot;);</span>
    }
<span class="fc" id="L338">    this.discriminator = discriminator;</span>
<span class="fc" id="L339">  }</span>

  /**
   * Gets the discriminator.
   *
   * @return the discriminator
   */
  public Discriminator getDiscriminator() {
<span class="fc" id="L347">    return discriminator;</span>
  }

  /**
   * Resolve sub map.
   *
   * @param statementScope
   *          the statement scope
   * @param rs
   *          the rs
   * @return the result map
   * @throws SQLException
   *           the SQL exception
   */
  public ResultMap resolveSubMap(StatementScope statementScope, ResultSet rs) throws SQLException {
<span class="fc" id="L362">    ResultMap subMap = this;</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">    if (discriminator != null) {</span>
<span class="fc" id="L364">      ResultMapping mapping = (ResultMapping) discriminator.getResultMapping();</span>
<span class="fc" id="L365">      Object value = getPrimitiveResultMappingValue(rs, mapping);</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L367">        value = doNullMapping(value, mapping);</span>
      }
<span class="fc" id="L369">      subMap = discriminator.getSubMap(String.valueOf(value));</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">      if (subMap == null) {</span>
<span class="fc" id="L371">        subMap = this;</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">      } else if (subMap != this) {</span>
<span class="fc" id="L373">        subMap = subMap.resolveSubMap(statementScope, rs);</span>
      }
    }
<span class="fc" id="L376">    return subMap;</span>
  }

  /**
   * Setter for a list of the individual ResultMapping objects.
   *
   * @param resultMappingList
   *          - the list
   */
  public void setResultMappingList(List resultMappingList) {
<span class="fc bfc" id="L386" title="All 2 branches covered.">    if (allowRemapping) {</span>
<span class="fc" id="L387">      this.remappableResultMappings</span>
<span class="fc" id="L388">          .set((ResultMapping[]) resultMappingList.toArray(new ResultMapping[resultMappingList.size()]));</span>
    } else {
<span class="fc" id="L390">      this.resultMappings = (ResultMapping[]) resultMappingList.toArray(new ResultMapping[resultMappingList.size()]);</span>
    }

<span class="fc" id="L393">    Map props = new HashMap();</span>
<span class="fc" id="L394">    props.put(&quot;map&quot;, this);</span>
<span class="fc" id="L395">    dataExchange = getDelegate().getDataExchangeFactory().getDataExchangeForClass(resultClass);</span>
<span class="fc" id="L396">    dataExchange.initialize(props);</span>
<span class="fc" id="L397">  }</span>

  /**
   * Getter for the number of ResultMapping objects.
   *
   * @return - the count
   */
  public int getResultCount() {
<span class="nc" id="L405">    return this.getResultMappings().length;</span>
  }

  /**
   * Read a row from a resultset and map results to an array.
   *
   * @param statementScope
   *          scope of the request
   * @param rs
   *          ResultSet to read from
   * @return row read as an array of column values.
   * @throws SQLException
   *           the SQL exception
   */
  public Object[] getResults(StatementScope statementScope, ResultSet rs) throws SQLException {
<span class="fc" id="L420">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L421">    errorContext.setActivity(&quot;applying a result map&quot;);</span>
<span class="fc" id="L422">    errorContext.setObjectId(this.getId());</span>
<span class="fc" id="L423">    errorContext.setResource(this.getResource());</span>
<span class="fc" id="L424">    errorContext.setMoreInfo(&quot;Check the result map.&quot;);</span>

<span class="fc" id="L426">    boolean foundData = false;</span>
<span class="fc" id="L427">    Object[] columnValues = new Object[getResultMappings().length];</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">    for (int i = 0; i &lt; getResultMappings().length; i++) {</span>
<span class="fc" id="L429">      ResultMapping mapping = (ResultMapping) getResultMappings()[i];</span>
<span class="fc" id="L430">      errorContext.setMoreInfo(mapping.getErrorString());</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">      if (mapping.getStatementName() != null) {</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        if (resultClass == null) {</span>
<span class="nc" id="L433">          throw new SqlMapException(</span>
<span class="nc" id="L434">              &quot;The result class was null when trying to get results for ResultMap named &quot; + getId() + &quot;.&quot;);</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">        } else if (Map.class.isAssignableFrom(resultClass)) {</span>
<span class="nc" id="L436">          Class javaType = mapping.getJavaType();</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">          if (javaType == null) {</span>
<span class="nc" id="L438">            javaType = Object.class;</span>
          }
<span class="nc" id="L440">          columnValues[i] = getNestedSelectMappingValue(statementScope, rs, mapping, javaType);</span>
<span class="pc bfc" id="L441" title="All 2 branches covered.">        } else if (DomTypeMarker.class.isAssignableFrom(resultClass)) {</span>
<span class="fc" id="L442">          Class javaType = mapping.getJavaType();</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">          if (javaType == null) {</span>
<span class="fc" id="L444">            javaType = DomTypeMarker.class;</span>
          }
<span class="fc" id="L446">          columnValues[i] = getNestedSelectMappingValue(statementScope, rs, mapping, javaType);</span>
<span class="fc" id="L447">        } else {</span>
<span class="fc" id="L448">          Probe p = ProbeFactory.getProbe(resultClass);</span>
<span class="fc" id="L449">          Class type = p.getPropertyTypeForSetter(resultClass, mapping.getPropertyName());</span>
<span class="fc" id="L450">          columnValues[i] = getNestedSelectMappingValue(statementScope, rs, mapping, type);</span>
        }
<span class="pc bpc" id="L452" title="3 of 4 branches missed.">        foundData = foundData || columnValues[i] != null;</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">      } else if (mapping.getNestedResultMapName() == null) {</span>
<span class="fc" id="L454">        columnValues[i] = getPrimitiveResultMappingValue(rs, mapping);</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">        if (columnValues[i] == null) {</span>
<span class="fc" id="L456">          columnValues[i] = doNullMapping(columnValues[i], mapping);</span>
        } else {
<span class="fc" id="L458">          foundData = true;</span>
        }
      }
    }

<span class="fc" id="L463">    statementScope.setRowDataFound(foundData);</span>

<span class="fc" id="L465">    return columnValues;</span>
  }

  /**
   * Sets the result object values.
   *
   * @param statementScope
   *          the statement scope
   * @param resultObject
   *          the result object
   * @param values
   *          the values
   * @return the object
   */
  public Object setResultObjectValues(StatementScope statementScope, Object resultObject, Object[] values) {
<span class="fc" id="L480">    final String previousNestedKey = statementScope.getCurrentNestedKey();</span>
<span class="fc" id="L481">    String ukey = (String) getUniqueKey(statementScope.getCurrentNestedKey(), values);</span>
<span class="fc" id="L482">    Map uniqueKeys = statementScope.getUniqueKeys(this);</span>
<span class="fc" id="L483">    statementScope.setCurrentNestedKey(ukey);</span>
<span class="fc bfc" id="L484" title="All 4 branches covered.">    if (uniqueKeys != null &amp;&amp; uniqueKeys.containsKey(ukey)) {</span>
      // Unique key is already known, so get the existing result object and process additional
      // results.
<span class="fc" id="L487">      resultObject = uniqueKeys.get(ukey);</span>
<span class="fc" id="L488">      applyNestedResultMap(statementScope, resultObject, values);</span>
<span class="fc" id="L489">      resultObject = NO_VALUE;</span>
<span class="pc bpc" id="L490" title="1 of 6 branches missed.">    } else if (ukey == null || uniqueKeys == null || !uniqueKeys.containsKey(ukey)) {</span>
      // Unique key is NOT known, so create a new result object and then process additional
      // results.
<span class="fc" id="L493">      resultObject = dataExchange.setData(statementScope, this, resultObject, values);</span>
      // Lazy init key set, only if we're grouped by something (i.e. ukey != null)
<span class="fc bfc" id="L495" title="All 2 branches covered.">      if (ukey != null) {</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        if (uniqueKeys == null) {</span>
<span class="fc" id="L497">          uniqueKeys = new HashMap();</span>
<span class="fc" id="L498">          statementScope.setUniqueKeys(this, uniqueKeys);</span>
        }
<span class="fc" id="L500">        uniqueKeys.put(ukey, resultObject);</span>
      }
<span class="fc" id="L502">      applyNestedResultMap(statementScope, resultObject, values);</span>
    } else {
      // Otherwise, we don't care about these results.
<span class="nc" id="L505">      resultObject = NO_VALUE;</span>
    }

<span class="fc" id="L508">    statementScope.setCurrentNestedKey(previousNestedKey);</span>
<span class="fc" id="L509">    return resultObject;</span>
  }

  /**
   * Apply nested result map.
   *
   * @param statementScope
   *          the statement scope
   * @param resultObject
   *          the result object
   * @param values
   *          the values
   */
  private void applyNestedResultMap(StatementScope statementScope, Object resultObject, Object[] values) {
<span class="pc bpc" id="L523" title="1 of 4 branches missed.">    if (resultObject != null &amp;&amp; resultObject != NO_VALUE) {</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">      if (nestedResultMappings != null) {</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">        for (int i = 0, n = nestedResultMappings.size(); i &lt; n; i++) {</span>
<span class="fc" id="L526">          ResultMapping resultMapping = (ResultMapping) nestedResultMappings.get(i);</span>
<span class="fc" id="L527">          setNestedResultMappingValue(resultMapping, statementScope, resultObject, values);</span>
        }
      }
    }
<span class="fc" id="L531">  }</span>

  /**
   * Some changes in this method for IBATIS-225:
   * &lt;ul&gt;
   * &lt;li&gt;We no longer require the nested property to be a collection. This will allow reuses of resultMaps on 1:1
   * relationships&lt;/li&gt;
   * &lt;li&gt;If the nested property is not a collection, then it will be created/replaced by the values generated from the
   * current row.&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @param mapping
   *          the mapping
   * @param statementScope
   *          the statement scope
   * @param resultObject
   *          the result object
   * @param values
   *          the values
   */
  protected void setNestedResultMappingValue(ResultMapping mapping, StatementScope statementScope, Object resultObject,
      Object[] values) {
    try {

<span class="fc" id="L555">      String resultMapName = mapping.getNestedResultMapName();</span>
<span class="fc" id="L556">      ResultMap resultMap = getDelegate().getResultMap(resultMapName);</span>
      // get the discriminated submap if it exists
<span class="fc" id="L558">      resultMap = resultMap.resolveSubMap(statementScope, statementScope.getResultSet());</span>

<span class="fc" id="L560">      Class type = mapping.getJavaType();</span>
<span class="fc" id="L561">      String propertyName = mapping.getPropertyName();</span>

<span class="fc" id="L563">      Object obj = PROBE.getObject(resultObject, propertyName);</span>

<span class="fc bfc" id="L565" title="All 2 branches covered.">      if (obj == null) {</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">        if (type == null) {</span>
<span class="fc" id="L567">          type = PROBE.getPropertyTypeForSetter(resultObject, propertyName);</span>
        }

        try {
          // create the object if is it a Collection. If not a Collection
          // then we will just set the property to the object created
          // in processing the nested result map
<span class="fc bfc" id="L574" title="All 2 branches covered.">          if (Collection.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L575">            obj = ResultObjectFactoryUtil.createObjectThroughFactory(type);</span>
<span class="fc" id="L576">            PROBE.setObject(resultObject, propertyName, obj);</span>
          }
<span class="nc" id="L578">        } catch (Exception e) {</span>
<span class="nc" id="L579">          throw new SqlMapException(</span>
<span class="nc" id="L580">              &quot;Error instantiating collection property for mapping '&quot; + mapping.getPropertyName() + &quot;'.  Cause: &quot; + e,</span>
              e);
<span class="fc" id="L582">        }</span>
      }

      // JIRA 375
      // &quot;Provide a way for not creating items from nested ResultMaps when the items contain only null values&quot;
<span class="fc" id="L587">      boolean subResultObjectAbsent = false;</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">      if (mapping.getNotNullColumn() != null) {</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">        if (statementScope.getResultSet().getObject(mapping.getNotNullColumn()) == null) {</span>
<span class="nc" id="L590">          subResultObjectAbsent = true;</span>
        }
      }
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">      if (!subResultObjectAbsent) {</span>
<span class="fc" id="L594">        values = resultMap.getResults(statementScope, statementScope.getResultSet());</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">        if (statementScope.isRowDataFound()) {</span>
<span class="fc" id="L596">          Object o = resultMap.setResultObjectValues(statementScope, null, values);</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">          if (o != NO_VALUE) {</span>
<span class="fc bfc" id="L598" title="All 4 branches covered.">            if (obj != null &amp;&amp; obj instanceof Collection) {</span>
<span class="fc" id="L599">              ((Collection) obj).add(o);</span>
            } else {
<span class="fc" id="L601">              PROBE.setObject(resultObject, propertyName, o);</span>
            }
          }
        }
      }
<span class="nc" id="L606">    } catch (SQLException e) {</span>
<span class="nc" id="L607">      throw new SqlMapException(</span>
<span class="nc" id="L608">          &quot;Error getting nested result map values for '&quot; + mapping.getPropertyName() + &quot;'.  Cause: &quot; + e, e);</span>
<span class="fc" id="L609">    }</span>
<span class="fc" id="L610">  }</span>

  /**
   * Gets the nested select mapping value.
   *
   * @param statementScope
   *          the statement scope
   * @param rs
   *          the rs
   * @param mapping
   *          the mapping
   * @param targetType
   *          the target type
   * @return the nested select mapping value
   * @throws SQLException
   *           the SQL exception
   */
  protected Object getNestedSelectMappingValue(StatementScope statementScope, ResultSet rs, ResultMapping mapping,
      Class targetType) throws SQLException {
    try {
<span class="fc" id="L630">      TypeHandlerFactory typeHandlerFactory = getDelegate().getTypeHandlerFactory();</span>

<span class="fc" id="L632">      String statementName = mapping.getStatementName();</span>
<span class="fc" id="L633">      SqlMapClientImpl client = (SqlMapClientImpl) statementScope.getSession().getSqlMapClient();</span>

<span class="fc" id="L635">      MappedStatement mappedStatement = client.getMappedStatement(statementName);</span>
<span class="fc" id="L636">      Class parameterType = mappedStatement.getParameterClass();</span>
<span class="fc" id="L637">      Object parameterObject = null;</span>

<span class="pc bpc" id="L639" title="1 of 2 branches missed.">      if (parameterType == null) {</span>
<span class="nc" id="L640">        parameterObject = prepareBeanParameterObject(statementScope, rs, mapping, parameterType);</span>
      } else {
<span class="fc bfc" id="L642" title="All 2 branches covered.">        if (typeHandlerFactory.hasTypeHandler(parameterType)) {</span>
<span class="fc" id="L643">          parameterObject = preparePrimitiveParameterObject(rs, mapping, parameterType);</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">        } else if (DomTypeMarker.class.isAssignableFrom(parameterType)) {</span>
<span class="fc" id="L645">          parameterObject = prepareDomParameterObject(rs, mapping);</span>
        } else {
<span class="fc" id="L647">          parameterObject = prepareBeanParameterObject(statementScope, rs, mapping, parameterType);</span>
        }
      }

<span class="fc" id="L651">      Object result = null;</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">      if (parameterObject != null) {</span>

<span class="fc" id="L654">        Sql sql = mappedStatement.getSql();</span>
<span class="fc" id="L655">        ResultMap resultMap = sql.getResultMap(statementScope, parameterObject);</span>
<span class="fc" id="L656">        Class resultClass = resultMap.getResultClass();</span>

<span class="pc bpc" id="L658" title="1 of 4 branches missed.">        if (resultClass != null &amp;&amp; !DomTypeMarker.class.isAssignableFrom(targetType)) {</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">          if (DomCollectionTypeMarker.class.isAssignableFrom(resultClass)) {</span>
<span class="nc" id="L660">            targetType = DomCollectionTypeMarker.class;</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">          } else if (DomTypeMarker.class.isAssignableFrom(resultClass)) {</span>
<span class="nc" id="L662">            targetType = DomTypeMarker.class;</span>
          }
        }

<span class="fc" id="L666">        result = ResultLoader.loadResult(client, statementName, parameterObject, targetType);</span>

<span class="fc" id="L668">        String nullValue = mapping.getNullValue();</span>
<span class="pc bpc" id="L669" title="3 of 4 branches missed.">        if (result == null &amp;&amp; nullValue != null) {</span>
<span class="nc" id="L670">          TypeHandler typeHandler = typeHandlerFactory.getTypeHandler(targetType);</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">          if (typeHandler != null) {</span>
<span class="nc" id="L672">            result = typeHandler.valueOf(nullValue);</span>
          }
        }
      }
<span class="fc" id="L676">      return result;</span>
<span class="nc" id="L677">    } catch (InstantiationException e) {</span>
<span class="nc" id="L678">      throw new NestedSQLException(&quot;Error setting nested bean property.  Cause: &quot; + e, e);</span>
<span class="nc" id="L679">    } catch (IllegalAccessException e) {</span>
<span class="nc" id="L680">      throw new NestedSQLException(&quot;Error setting nested bean property.  Cause: &quot; + e, e);</span>
    }

  }

  /**
   * Prepare primitive parameter object.
   *
   * @param rs
   *          the rs
   * @param mapping
   *          the mapping
   * @param parameterType
   *          the parameter type
   * @return the object
   * @throws SQLException
   *           the SQL exception
   */
  private Object preparePrimitiveParameterObject(ResultSet rs, ResultMapping mapping, Class parameterType)
      throws SQLException {
    Object parameterObject;
<span class="fc" id="L701">    TypeHandlerFactory typeHandlerFactory = getDelegate().getTypeHandlerFactory();</span>
<span class="fc" id="L702">    TypeHandler th = typeHandlerFactory.getTypeHandler(parameterType);</span>
<span class="fc" id="L703">    parameterObject = th.getResult(rs, mapping.getColumnName());</span>
<span class="fc" id="L704">    return parameterObject;</span>
  }

  /**
   * New document.
   *
   * @param root
   *          the root
   * @return the document
   */
  private Document newDocument(String root) {
    try {
<span class="fc" id="L716">      Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();</span>
<span class="fc" id="L717">      doc.appendChild(doc.createElement(root));</span>
<span class="fc" id="L718">      return doc;</span>
<span class="nc" id="L719">    } catch (ParserConfigurationException e) {</span>
<span class="nc" id="L720">      throw new RuntimeException(&quot;Error creating XML document.  Cause: &quot; + e);</span>
    }
  }

  /**
   * Prepare dom parameter object.
   *
   * @param rs
   *          the rs
   * @param mapping
   *          the mapping
   * @return the object
   * @throws SQLException
   *           the SQL exception
   */
  private Object prepareDomParameterObject(ResultSet rs, ResultMapping mapping) throws SQLException {
<span class="fc" id="L736">    TypeHandlerFactory typeHandlerFactory = getDelegate().getTypeHandlerFactory();</span>

<span class="fc" id="L738">    Document doc = newDocument(&quot;parameter&quot;);</span>
<span class="fc" id="L739">    Probe probe = ProbeFactory.getProbe(doc);</span>

<span class="fc" id="L741">    String complexName = mapping.getColumnName();</span>

<span class="fc" id="L743">    TypeHandler stringTypeHandler = typeHandlerFactory.getTypeHandler(String.class);</span>
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">    if (complexName.indexOf('=') &gt; -1) {</span>
      // old 1.x style multiple params
<span class="fc" id="L746">      StringTokenizer parser = new StringTokenizer(complexName, &quot;{}=, &quot;, false);</span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">      while (parser.hasMoreTokens()) {</span>
<span class="fc" id="L748">        String propName = parser.nextToken();</span>
<span class="fc" id="L749">        String colName = parser.nextToken();</span>
<span class="fc" id="L750">        Object propValue = stringTypeHandler.getResult(rs, colName);</span>
<span class="fc" id="L751">        probe.setObject(doc, propName, propValue.toString());</span>
<span class="fc" id="L752">      }</span>
<span class="fc" id="L753">    } else {</span>
      // single param
<span class="nc" id="L755">      Object propValue = stringTypeHandler.getResult(rs, complexName);</span>
<span class="nc" id="L756">      probe.setObject(doc, &quot;value&quot;, propValue.toString());</span>
    }

<span class="fc" id="L759">    return doc;</span>
  }

  /**
   * Prepare bean parameter object.
   *
   * @param statementScope
   *          the statement scope
   * @param rs
   *          the rs
   * @param mapping
   *          the mapping
   * @param parameterType
   *          the parameter type
   * @return the object
   * @throws InstantiationException
   *           the instantiation exception
   * @throws IllegalAccessException
   *           the illegal access exception
   * @throws SQLException
   *           the SQL exception
   */
  private Object prepareBeanParameterObject(StatementScope statementScope, ResultSet rs, ResultMapping mapping,
      Class parameterType) throws InstantiationException, IllegalAccessException, SQLException {
<span class="fc" id="L783">    TypeHandlerFactory typeHandlerFactory = getDelegate().getTypeHandlerFactory();</span>

    Object parameterObject;
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">    if (parameterType == null) {</span>
<span class="nc" id="L787">      parameterObject = new HashMap();</span>
    } else {
<span class="fc" id="L789">      parameterObject = ResultObjectFactoryUtil.createObjectThroughFactory(parameterType);</span>
    }
<span class="fc" id="L791">    String complexName = mapping.getColumnName();</span>

<span class="pc bpc" id="L793" title="3 of 4 branches missed.">    if (complexName.indexOf('=') &gt; -1 || complexName.indexOf(',') &gt; -1) {</span>
<span class="fc" id="L794">      StringTokenizer parser = new StringTokenizer(complexName, &quot;{}=, &quot;, false);</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">      while (parser.hasMoreTokens()) {</span>
<span class="fc" id="L796">        String propName = parser.nextToken();</span>
<span class="fc" id="L797">        String colName = parser.nextToken();</span>
<span class="fc" id="L798">        Class propType = PROBE.getPropertyTypeForSetter(parameterObject, propName);</span>
<span class="fc" id="L799">        TypeHandler propTypeHandler = typeHandlerFactory.getTypeHandler(propType);</span>
<span class="fc" id="L800">        Object propValue = propTypeHandler.getResult(rs, colName);</span>
<span class="fc" id="L801">        PROBE.setObject(parameterObject, propName, propValue);</span>
<span class="fc" id="L802">      }</span>
<span class="fc" id="L803">    } else {</span>
      // single param
<span class="nc" id="L805">      TypeHandler propTypeHandler = typeHandlerFactory.getTypeHandler(parameterType);</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">      if (propTypeHandler == null) {</span>
<span class="nc" id="L807">        propTypeHandler = typeHandlerFactory.getUnkownTypeHandler();</span>
      }
<span class="nc" id="L809">      parameterObject = propTypeHandler.getResult(rs, complexName);</span>
    }

<span class="fc" id="L812">    return parameterObject;</span>
  }

  /**
   * Gets the primitive result mapping value.
   *
   * @param rs
   *          the rs
   * @param mapping
   *          the mapping
   * @return the primitive result mapping value
   * @throws SQLException
   *           the SQL exception
   */
  protected Object getPrimitiveResultMappingValue(ResultSet rs, ResultMapping mapping) throws SQLException {
<span class="fc" id="L827">    Object value = null;</span>
<span class="fc" id="L828">    TypeHandler typeHandler = mapping.getTypeHandler();</span>
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">    if (typeHandler != null) {</span>
<span class="fc" id="L830">      String columnName = mapping.getColumnName();</span>
<span class="fc" id="L831">      int columnIndex = mapping.getColumnIndex();</span>
<span class="pc bpc" id="L832" title="1 of 2 branches missed.">      if (columnName == null) {</span>
<span class="nc" id="L833">        value = typeHandler.getResult(rs, columnIndex);</span>
      } else {
<span class="fc" id="L835">        value = typeHandler.getResult(rs, columnName);</span>
      }
<span class="fc" id="L837">    } else {</span>
<span class="nc" id="L838">      throw new SqlMapException(&quot;No type handler could be found to map the property '&quot; + mapping.getPropertyName()</span>
<span class="nc" id="L839">          + &quot;' to the column '&quot; + mapping.getColumnName()</span>
          + &quot;'.  One or both of the types, or the combination of types is not supported.&quot;);
    }
<span class="fc" id="L842">    return value;</span>
  }

  /**
   * Do null mapping.
   *
   * @param value
   *          the value
   * @param mapping
   *          the mapping
   * @return the object
   * @throws SqlMapException
   *           the sql map exception
   */
  protected Object doNullMapping(Object value, ResultMapping mapping) throws SqlMapException {
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="fc" id="L858">      TypeHandler typeHandler = mapping.getTypeHandler();</span>
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">      if (typeHandler != null) {</span>
<span class="fc" id="L860">        String nullValue = mapping.getNullValue();</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">        if (nullValue != null)</span>
<span class="fc" id="L862">          value = typeHandler.valueOf(nullValue);</span>
<span class="fc" id="L863">        return value;</span>
      } else {
<span class="nc" id="L865">        throw new SqlMapException(&quot;No type handler could be found to map the property '&quot; + mapping.getPropertyName()</span>
<span class="nc" id="L866">            + &quot;' to the column '&quot; + mapping.getColumnName()</span>
            + &quot;'.  One or both of the types, or the combination of types is not supported.&quot;);
      }
    } else {
<span class="nc" id="L870">      return value;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>