<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CacheModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.cache</a> &gt; <span class="el_source">CacheModel.java</span></div><h1>CacheModel.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2004-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.cache;

import com.ibatis.common.logging.Log;
import com.ibatis.common.logging.LogFactory;
import com.ibatis.sqlmap.engine.mapping.statement.ExecuteListener;
import com.ibatis.sqlmap.engine.mapping.statement.MappedStatement;

import java.io.*;
import java.util.*;

/**
 * Wrapper for Caches.
<span class="fc" id="L28"> */</span>
public class CacheModel implements ExecuteListener {

  private static final Log log = LogFactory.getLog(CacheModel.class);

  private static final int MAX_OBJECT_LOG_SIZE = 200;

<span class="fc" id="L35">  /**</span>
<span class="fc" id="L36">   * This is used to represent null objects that are returned from the cache so that they can be cached, too.</span>
<span class="fc" id="L37">   */</span>
  public static final Object NULL_OBJECT = new String(&quot;SERIALIZABLE_NULL_OBJECT&quot;);
  private int requests = 0;
  private int hits = 0;

  /**
   * Constant to turn off periodic cache flushes
   */
  private static final long NO_FLUSH_INTERVAL = -99999;

  private String id;

  private boolean readOnly;
  private boolean serialize;

  private long lastFlush;
  private long flushInterval;
  private long flushIntervalSeconds;
  private Set flushTriggerStatements;

  private CacheController controller;

  private String resource;

<span class="fc" id="L61">  /**</span>
<span class="fc" id="L62">   * Default constructor</span>
<span class="fc" id="L63">   */</span>
<span class="fc" id="L64">  public CacheModel() {</span>
<span class="fc" id="L65">    this.flushInterval = NO_FLUSH_INTERVAL;</span>
<span class="fc" id="L66">    this.flushIntervalSeconds = NO_FLUSH_INTERVAL;</span>
    this.lastFlush = System.currentTimeMillis();
    this.flushTriggerStatements = new HashSet();
  }

  /**
   * Getter for the cache model's id
   *
<span class="fc" id="L74">   * @return the id</span>
   */
  public String getId() {
    return id;
  }

  /**
   * Setter for the cache model's id
   *
   * @param id
<span class="fc" id="L84">   *          - the new id</span>
<span class="fc" id="L85">   */</span>
  public void setId(String id) {
    this.id = id;
  }

  /**
   * Getter for read-only property
   *
<span class="fc" id="L93">   * @return true if a read-only model</span>
   */
  public boolean isReadOnly() {
    return readOnly;
  }

  /**
   * Setter for read-only property
   *
   * @param readOnly
<span class="fc" id="L103">   *          - the new setting</span>
<span class="fc" id="L104">   */</span>
  public void setReadOnly(boolean readOnly) {
    this.readOnly = readOnly;
  }

  /**
   * Getter to tell if the cache serializes
   *
<span class="fc" id="L112">   * @return true if the cache model serializes objects</span>
   */
  public boolean isSerialize() {
    return serialize;
  }

  /**
   * Setter to tell the cache to serialize objects
   *
   * @param serialize
<span class="fc" id="L122">   *          - if the cache model is to serialize objects</span>
<span class="fc" id="L123">   */</span>
  public void setSerialize(boolean serialize) {
    this.serialize = serialize;
  }

  /**
   * Getter for resource property
   *
<span class="nc" id="L131">   * @return the value of the resource property</span>
   */
  public String getResource() {
    return resource;
  }

  /**
   * Setter for resource property
   *
   * @param resource
<span class="fc" id="L141">   *          - the new value</span>
<span class="fc" id="L142">   */</span>
  public void setResource(String resource) {
    this.resource = resource;
  }

  /**
   * Sets up the controller for the cache model
   *
   * @throws ClassNotFoundException
   *           - if the class cannot be found
   * @throws InstantiationException
   *           - if the class cannot be instantiated
   * @throws IllegalAccessException
   *           - if the classes constructor is not accessible
<span class="fc" id="L156">   */</span>
<span class="fc" id="L157">  public void setCacheController(CacheController controller) throws ClassNotFoundException, InstantiationException,</span>
      IllegalAccessException {
    this.controller = controller;
  }

  /**
   * Getter for flushInterval property
   *
<span class="nc" id="L165">   * @return The flushInterval (in milliseconds)</span>
   */
  public long getFlushInterval() {
    return flushInterval;
  }

  /**
   * Getter for flushInterval property
   *
<span class="nc" id="L174">   * @return The flushInterval (in milliseconds)</span>
   */
  public long getFlushIntervalSeconds() {
    return flushIntervalSeconds;
  }

  /**
   * Setter for flushInterval property
   *
   * @param flushInterval
<span class="fc" id="L184">   *          The new flushInterval (in milliseconds)</span>
<span class="fc" id="L185">   */</span>
<span class="fc" id="L186">  public void setFlushInterval(long flushInterval) {</span>
    this.flushInterval = flushInterval;
    this.flushIntervalSeconds = flushInterval / 1000;
  }

  /**
   * Adds a flushTriggerStatment. When a flushTriggerStatment is executed, the cache is flushed (cleared).
   *
   * @param statementName
<span class="fc" id="L195">   *          The statement to add.</span>
<span class="fc" id="L196">   */</span>
  public void addFlushTriggerStatement(String statementName) {
    flushTriggerStatements.add(statementName);
  }

  /**
   * Gets an Iterator containing all flushTriggerStatment objects for this cache.
   *
<span class="fc" id="L204">   * @return The Iterator</span>
   */
  public Iterator getFlushTriggerStatementNames() {
    return flushTriggerStatements.iterator();
  }

  /**
   * ExecuteListener event. This will be called by a MappedStatement for which this cache is registered as a
   * ExecuteListener. It will be called each time an executeXXXXXX method is called. In the case of the Cache class, it
   * is registered in order to flush the cache whenever a certain statement is executed. (i.e. the flushOnExecute cache
   * policy)
   *
   * @param statement
<span class="fc" id="L217">   *          The statement to execute</span>
<span class="fc" id="L218">   */</span>
  public void onExecuteStatement(MappedStatement statement) {
    flush();
  }

  /**
   * Returns statistical information about the cache.
   *
<span class="nc" id="L226">   * @return the number of cache hits divided by the total requests</span>
   */
  public double getHitRatio() {
    return (double) hits / (double) requests;
  }

  /**
   * Configures the cache
   *
<span class="nc" id="L235">   * @param props</span>
<span class="nc" id="L236">   */</span>
  public void configure(Properties props) {
    controller.setProperties(props);
  }

  /**
<span class="fc" id="L242">   * Clears the cache</span>
<span class="fc" id="L243">   */</span>
<span class="fc" id="L244">  public void flush() {</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">    synchronized (this) {</span>
<span class="nc" id="L246">      controller.flush(this);</span>
      lastFlush = System.currentTimeMillis();
<span class="pc" id="L248">      if (log.isDebugEnabled()) {</span>
<span class="fc" id="L249">        log(&quot;flushed&quot;, false, null);</span>
      }
    }
  }

  /**
   * Get an object out of the cache. A side effect of this method is that is may clear the cache if it has not been
   * cleared in the flushInterval.
   *
   * @param key
   *          The key of the object to be returned
<span class="fc" id="L260">   * @return The cached object (or null)</span>
<span class="fc" id="L261">   */</span>
<span class="pc bpc" id="L262" title="2 of 4 branches missed.">  public Object getObject(CacheKey key) {</span>
<span class="nc" id="L263">    Object value = null;</span>
    synchronized (this) {
      if (flushInterval != NO_FLUSH_INTERVAL &amp;&amp; System.currentTimeMillis() - lastFlush &gt; flushInterval) {
<span class="fc" id="L266">        flush();</span>
<span class="pc bpc" id="L267" title="2 of 8 branches missed.">      }</span>

<span class="fc" id="L269">      value = controller.getObject(this, key);</span>
<span class="fc" id="L270">      if (serialize &amp;&amp; !readOnly &amp;&amp; (value != NULL_OBJECT &amp;&amp; value != null)) {</span>
<span class="fc" id="L271">        try {</span>
<span class="fc" id="L272">          ByteArrayInputStream bis = new ByteArrayInputStream((byte[]) value);</span>
<span class="nc" id="L273">          ObjectInputStream ois = new ObjectInputStream(bis);</span>
<span class="nc" id="L274">          value = ois.readObject();</span>
          ois.close();
<span class="fc" id="L276">        } catch (Exception e) {</span>
          throw new RuntimeException(&quot;Error caching serializable object.  Be sure you're not attempting to use &quot;
<span class="fc" id="L278">              + &quot;a serialized cache for an object that may be taking advantage of lazy loading.  Cause: &quot; + e, e);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        }</span>
<span class="fc" id="L280">      }</span>
      requests++;
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">      if (value != null) {</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">        hits++;</span>
<span class="nc" id="L284">      }</span>
      if (log.isDebugEnabled()) {
<span class="nc" id="L286">        if (value != null) {</span>
          log(&quot;retrieved object&quot;, true, value);
        } else {
<span class="pc" id="L289">          log(&quot;cache miss&quot;, false, null);</span>
<span class="fc" id="L290">        }</span>
      }
    }
    return value;
  }

  /**
   * Add an object to the cache
   *
   * @param key
   *          The key of the object to be cached
   * @param value
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">   *          The object to be cached</span>
<span class="nc" id="L303">   */</span>
<span class="fc" id="L304">  public void putObject(CacheKey key, Object value) {</span>
<span class="pc bpc" id="L305" title="2 of 6 branches missed.">    if (null == value)</span>
      value = NULL_OBJECT;
<span class="fc" id="L307">    synchronized (this) {</span>
<span class="fc" id="L308">      if (serialize &amp;&amp; !readOnly &amp;&amp; value != NULL_OBJECT) {</span>
<span class="fc" id="L309">        try {</span>
<span class="fc" id="L310">          ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="fc" id="L311">          ObjectOutputStream oos = new ObjectOutputStream(bos);</span>
<span class="fc" id="L312">          oos.writeObject(value);</span>
<span class="nc" id="L313">          oos.flush();</span>
<span class="nc" id="L314">          oos.close();</span>
<span class="fc" id="L315">          value = bos.toByteArray();</span>
        } catch (IOException e) {
<span class="fc" id="L317">          throw new RuntimeException(&quot;Error caching serializable object.  Cause: &quot; + e, e);</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">        }</span>
<span class="nc" id="L319">      }</span>
      controller.putObject(this, key, value);
<span class="pc" id="L321">      if (log.isDebugEnabled()) {</span>
<span class="fc" id="L322">        log(&quot;stored object&quot;, true, value);</span>
      }
    }
  }

  /**
   * Get the maximum size of an object in the log output.
   *
<span class="nc" id="L330">   * @return Maximum size of a logged object in the output</span>
   */
  protected int getMaxObjectLogSize() {
    return MAX_OBJECT_LOG_SIZE;
  }

  /**
   * Log a cache action. Since this method is pretty heavy weight, it's best to enclose it with a log.isDebugEnabled()
   * when called.
   *
   * @param action
   *          String to output
   * @param addValue
   *          Add the value being cached to the log
   * @param cacheValue
<span class="nc" id="L345">   *          The value being logged</span>
<span class="nc" id="L346">   */</span>
<span class="nc" id="L347">  protected void log(String action, boolean addValue, Object cacheValue) {</span>
<span class="nc" id="L348">    StringBuffer output = new StringBuffer(&quot;Cache '&quot;);</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">    output.append(getId());</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">    output.append(&quot;': &quot;);</span>
<span class="nc" id="L351">    output.append(action);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">    if (addValue) {</span>
<span class="nc" id="L353">      String cacheObjectStr = (cacheValue == null ? &quot;null&quot; : cacheValue.toString());</span>
      output.append(&quot; '&quot;);
<span class="nc" id="L355">      if (cacheObjectStr.length() &lt; getMaxObjectLogSize()) {</span>
<span class="nc" id="L356">        output.append(cacheObjectStr.toString());</span>
      } else {
<span class="nc" id="L358">        output.append(cacheObjectStr.substring(1, getMaxObjectLogSize()));</span>
        output.append(&quot;...&quot;);
<span class="nc" id="L360">      }</span>
<span class="nc" id="L361">      output.append(&quot;'&quot;);</span>
    }
    log.debug(output.toString());
<span class="fc" id="L364">  }</span>
<span class="fc" id="L365"></span>
  public void setControllerProperties(Properties cacheProps) {
    controller.setProperties(cacheProps);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>