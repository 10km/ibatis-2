<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CacheModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.cache</a> &gt; <span class="el_source">CacheModel.java</span></div><h1>CacheModel.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2004-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.cache;

import com.ibatis.common.logging.Log;
import com.ibatis.common.logging.LogFactory;
import com.ibatis.sqlmap.engine.mapping.statement.ExecuteListener;
import com.ibatis.sqlmap.engine.mapping.statement.MappedStatement;

import java.io.*;
import java.util.*;

/**
 * Wrapper for Caches.
 */
public class CacheModel implements ExecuteListener {

  /** The Constant log. */
<span class="fc" id="L32">  private static final Log log = LogFactory.getLog(CacheModel.class);</span>

  /** The Constant MAX_OBJECT_LOG_SIZE. */
  private static final int MAX_OBJECT_LOG_SIZE = 200;

  /**
   * This is used to represent null objects that are returned from the cache so that they can be cached, too.
   */
<span class="fc" id="L40">  public static final Object NULL_OBJECT = &quot;SERIALIZABLE_NULL_OBJECT&quot;;</span>

  /** The requests. */
<span class="fc" id="L43">  private int requests = 0;</span>

  /** The hits. */
<span class="fc" id="L46">  private int hits = 0;</span>

  /** Constant to turn off periodic cache flushes. */
  private static final long NO_FLUSH_INTERVAL = -99999;

  /** The id. */
  private String id;

  /** The read only. */
  private boolean readOnly;

  /** The serialize. */
  private boolean serialize;

  /** The last flush. */
  private long lastFlush;

  /** The flush interval. */
  private long flushInterval;

  /** The flush interval seconds. */
  private long flushIntervalSeconds;

  /** The flush trigger statements. */
  private Set flushTriggerStatements;

  /** The controller. */
  private CacheController controller;

  /** The resource. */
  private String resource;

  /**
   * Default constructor.
   */
<span class="fc" id="L81">  public CacheModel() {</span>
<span class="fc" id="L82">    this.flushInterval = NO_FLUSH_INTERVAL;</span>
<span class="fc" id="L83">    this.flushIntervalSeconds = NO_FLUSH_INTERVAL;</span>
<span class="fc" id="L84">    this.lastFlush = System.currentTimeMillis();</span>
<span class="fc" id="L85">    this.flushTriggerStatements = new HashSet();</span>
<span class="fc" id="L86">  }</span>

  /**
   * Getter for the cache model's id.
   *
   * @return the id
   */
  public String getId() {
<span class="fc" id="L94">    return id;</span>
  }

  /**
   * Setter for the cache model's id.
   *
   * @param id
   *          - the new id
   */
  public void setId(String id) {
<span class="fc" id="L104">    this.id = id;</span>
<span class="fc" id="L105">  }</span>

  /**
   * Getter for read-only property.
   *
   * @return true if a read-only model
   */
  public boolean isReadOnly() {
<span class="fc" id="L113">    return readOnly;</span>
  }

  /**
   * Setter for read-only property.
   *
   * @param readOnly
   *          - the new setting
   */
  public void setReadOnly(boolean readOnly) {
<span class="fc" id="L123">    this.readOnly = readOnly;</span>
<span class="fc" id="L124">  }</span>

  /**
   * Getter to tell if the cache serializes.
   *
   * @return true if the cache model serializes objects
   */
  public boolean isSerialize() {
<span class="fc" id="L132">    return serialize;</span>
  }

  /**
   * Setter to tell the cache to serialize objects.
   *
   * @param serialize
   *          - if the cache model is to serialize objects
   */
  public void setSerialize(boolean serialize) {
<span class="fc" id="L142">    this.serialize = serialize;</span>
<span class="fc" id="L143">  }</span>

  /**
   * Getter for resource property.
   *
   * @return the value of the resource property
   */
  public String getResource() {
<span class="nc" id="L151">    return resource;</span>
  }

  /**
   * Setter for resource property.
   *
   * @param resource
   *          - the new value
   */
  public void setResource(String resource) {
<span class="fc" id="L161">    this.resource = resource;</span>
<span class="fc" id="L162">  }</span>

  /**
   * Sets up the controller for the cache model.
   *
   * @param controller
   *          the new cache controller
   * @throws ClassNotFoundException
   *           - if the class cannot be found
   * @throws InstantiationException
   *           - if the class cannot be instantiated
   * @throws IllegalAccessException
   *           - if the classes constructor is not accessible
   */
  public void setCacheController(CacheController controller)
      throws ClassNotFoundException, InstantiationException, IllegalAccessException {
<span class="fc" id="L178">    this.controller = controller;</span>
<span class="fc" id="L179">  }</span>

  /**
   * Getter for flushInterval property.
   *
   * @return The flushInterval (in milliseconds)
   */
  public long getFlushInterval() {
<span class="nc" id="L187">    return flushInterval;</span>
  }

  /**
   * Getter for flushInterval property.
   *
   * @return The flushInterval (in milliseconds)
   */
  public long getFlushIntervalSeconds() {
<span class="nc" id="L196">    return flushIntervalSeconds;</span>
  }

  /**
   * Setter for flushInterval property.
   *
   * @param flushInterval
   *          The new flushInterval (in milliseconds)
   */
  public void setFlushInterval(long flushInterval) {
<span class="fc" id="L206">    this.flushInterval = flushInterval;</span>
<span class="fc" id="L207">    this.flushIntervalSeconds = flushInterval / 1000;</span>
<span class="fc" id="L208">  }</span>

  /**
   * Adds a flushTriggerStatment. When a flushTriggerStatment is executed, the cache is flushed (cleared).
   *
   * @param statementName
   *          The statement to add.
   */
  public void addFlushTriggerStatement(String statementName) {
<span class="fc" id="L217">    flushTriggerStatements.add(statementName);</span>
<span class="fc" id="L218">  }</span>

  /**
   * Gets an Iterator containing all flushTriggerStatment objects for this cache.
   *
   * @return The Iterator
   */
  public Iterator getFlushTriggerStatementNames() {
<span class="fc" id="L226">    return flushTriggerStatements.iterator();</span>
  }

  /**
   * ExecuteListener event. This will be called by a MappedStatement for which this cache is registered as a
   * ExecuteListener. It will be called each time an executeXXXXXX method is called. In the case of the Cache class, it
   * is registered in order to flush the cache whenever a certain statement is executed. (i.e. the flushOnExecute cache
   * policy)
   *
   * @param statement
   *          The statement to execute
   */
  public void onExecuteStatement(MappedStatement statement) {
<span class="fc" id="L239">    flush();</span>
<span class="fc" id="L240">  }</span>

  /**
   * Returns statistical information about the cache.
   *
   * @return the number of cache hits divided by the total requests
   */
  public double getHitRatio() {
<span class="nc" id="L248">    return (double) hits / (double) requests;</span>
  }

  /**
   * Configures the cache.
   *
   * @param props
   *          the props
   */
  public void configure(Properties props) {
<span class="nc" id="L258">    controller.setProperties(props);</span>
<span class="nc" id="L259">  }</span>

  /**
   * Clears the cache.
   */
  public void flush() {
<span class="fc" id="L265">    synchronized (this) {</span>
<span class="fc" id="L266">      controller.flush(this);</span>
<span class="fc" id="L267">      lastFlush = System.currentTimeMillis();</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">      if (log.isDebugEnabled()) {</span>
<span class="nc" id="L269">        log(&quot;flushed&quot;, false, null);</span>
      }
<span class="fc" id="L271">    }</span>
<span class="fc" id="L272">  }</span>

  /**
   * Get an object out of the cache. A side effect of this method is that is may clear the cache if it has not been
   * cleared in the flushInterval.
   *
   * @param key
   *          The key of the object to be returned
   * @return The cached object (or null)
   */
  public Object getObject(CacheKey key) {
<span class="fc" id="L283">    Object value = null;</span>
<span class="fc" id="L284">    synchronized (this) {</span>
<span class="pc bpc" id="L285" title="2 of 4 branches missed.">      if (flushInterval != NO_FLUSH_INTERVAL &amp;&amp; System.currentTimeMillis() - lastFlush &gt; flushInterval) {</span>
<span class="nc" id="L286">        flush();</span>
      }

<span class="fc" id="L289">      value = controller.getObject(this, key);</span>
<span class="pc bpc" id="L290" title="2 of 8 branches missed.">      if (serialize &amp;&amp; !readOnly &amp;&amp; (value != NULL_OBJECT &amp;&amp; value != null)) {</span>
        try {
<span class="fc" id="L292">          ByteArrayInputStream bis = new ByteArrayInputStream((byte[]) value);</span>
<span class="fc" id="L293">          ObjectInputStream ois = new ObjectInputStream(bis);</span>
<span class="fc" id="L294">          value = ois.readObject();</span>
<span class="fc" id="L295">          ois.close();</span>
<span class="nc" id="L296">        } catch (Exception e) {</span>
<span class="nc" id="L297">          throw new RuntimeException(&quot;Error caching serializable object.  Be sure you're not attempting to use &quot;</span>
              + &quot;a serialized cache for an object that may be taking advantage of lazy loading.  Cause: &quot; + e, e);
<span class="fc" id="L299">        }</span>
      }
<span class="fc" id="L301">      requests++;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">      if (value != null) {</span>
<span class="fc" id="L303">        hits++;</span>
      }
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">      if (log.isDebugEnabled()) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L307">          log(&quot;retrieved object&quot;, true, value);</span>
        } else {
<span class="nc" id="L309">          log(&quot;cache miss&quot;, false, null);</span>
        }
      }
<span class="fc" id="L312">    }</span>
<span class="fc" id="L313">    return value;</span>
  }

  /**
   * Add an object to the cache.
   *
   * @param key
   *          The key of the object to be cached
   * @param value
   *          The object to be cached
   */
  public void putObject(CacheKey key, Object value) {
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">    if (null == value)</span>
<span class="nc" id="L326">      value = NULL_OBJECT;</span>
<span class="fc" id="L327">    synchronized (this) {</span>
<span class="pc bpc" id="L328" title="2 of 6 branches missed.">      if (serialize &amp;&amp; !readOnly &amp;&amp; value != NULL_OBJECT) {</span>
        try {
<span class="fc" id="L330">          ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="fc" id="L331">          ObjectOutputStream oos = new ObjectOutputStream(bos);</span>
<span class="fc" id="L332">          oos.writeObject(value);</span>
<span class="fc" id="L333">          oos.flush();</span>
<span class="fc" id="L334">          oos.close();</span>
<span class="fc" id="L335">          value = bos.toByteArray();</span>
<span class="nc" id="L336">        } catch (IOException e) {</span>
<span class="nc" id="L337">          throw new RuntimeException(&quot;Error caching serializable object.  Cause: &quot; + e, e);</span>
<span class="fc" id="L338">        }</span>
      }
<span class="fc" id="L340">      controller.putObject(this, key, value);</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">      if (log.isDebugEnabled()) {</span>
<span class="nc" id="L342">        log(&quot;stored object&quot;, true, value);</span>
      }
<span class="fc" id="L344">    }</span>
<span class="fc" id="L345">  }</span>

  /**
   * Get the maximum size of an object in the log output.
   *
   * @return Maximum size of a logged object in the output
   */
  protected int getMaxObjectLogSize() {
<span class="nc" id="L353">    return MAX_OBJECT_LOG_SIZE;</span>
  }

  /**
   * Log a cache action. Since this method is pretty heavy weight, it's best to enclose it with a log.isDebugEnabled()
   * when called.
   *
   * @param action
   *          String to output
   * @param addValue
   *          Add the value being cached to the log
   * @param cacheValue
   *          The value being logged
   */
  protected void log(String action, boolean addValue, Object cacheValue) {
<span class="nc" id="L368">    StringBuilder output = new StringBuilder(&quot;Cache '&quot;);</span>
<span class="nc" id="L369">    output.append(getId());</span>
<span class="nc" id="L370">    output.append(&quot;': &quot;);</span>
<span class="nc" id="L371">    output.append(action);</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">    if (addValue) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">      String cacheObjectStr = (cacheValue == null ? &quot;null&quot; : cacheValue.toString());</span>
<span class="nc" id="L374">      output.append(&quot; '&quot;);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">      if (cacheObjectStr.length() &lt; getMaxObjectLogSize()) {</span>
<span class="nc" id="L376">        output.append(cacheObjectStr);</span>
      } else {
<span class="nc" id="L378">        output.append(cacheObjectStr.substring(1, getMaxObjectLogSize()));</span>
<span class="nc" id="L379">        output.append(&quot;...&quot;);</span>
      }
<span class="nc" id="L381">      output.append(&quot;'&quot;);</span>
    }
<span class="nc" id="L383">    log.debug(output.toString());</span>
<span class="nc" id="L384">  }</span>

  /**
   * Sets the controller properties.
   *
   * @param cacheProps
   *          the new controller properties
   */
  public void setControllerProperties(Properties cacheProps) {
<span class="fc" id="L393">    controller.setProperties(cacheProps);</span>
<span class="fc" id="L394">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>