<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MappedStatement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.mapping.statement</a> &gt; <span class="el_source">MappedStatement.java</span></div><h1>MappedStatement.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2004-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.mapping.statement;

import com.ibatis.common.jdbc.exception.NestedSQLException;
import com.ibatis.common.io.ReaderInputStream;

import com.ibatis.sqlmap.client.event.RowHandler;
import com.ibatis.sqlmap.client.*;
import com.ibatis.sqlmap.engine.execution.SqlExecutor;
import com.ibatis.sqlmap.engine.mapping.parameter.ParameterMap;
import com.ibatis.sqlmap.engine.mapping.result.ResultMap;
import com.ibatis.sqlmap.engine.mapping.sql.Sql;
import com.ibatis.sqlmap.engine.scope.ErrorContext;
import com.ibatis.sqlmap.engine.scope.StatementScope;
import com.ibatis.sqlmap.engine.transaction.Transaction;
import com.ibatis.sqlmap.engine.transaction.TransactionException;
import com.ibatis.sqlmap.engine.type.*;
import com.ibatis.sqlmap.engine.cache.*;
import com.ibatis.sqlmap.engine.impl.*;
import org.w3c.dom.Document;

import javax.xml.parsers.*;
import java.sql.Connection;
import java.sql.SQLException;
<span class="fc" id="L39">import java.util.*;</span>
import java.io.*;

public class MappedStatement {
  private String id;
  private Integer resultSetType;
  private Integer fetchSize;
  private ResultMap resultMap;
  private ParameterMap parameterMap;
  private Class parameterClass;
  private Sql sql;
<span class="fc" id="L50">  private int baseCacheKey;</span>
<span class="fc" id="L51">  private SqlMapClientImpl sqlMapClient;</span>
  private Integer timeout;
  private ResultMap[] additionalResultMaps = new ResultMap[0];
  private List executeListeners = new ArrayList();
<span class="nc" id="L55">  private String resource;</span>

  public StatementType getStatementType() {
    return StatementType.UNKNOWN;
  }
<span class="fc" id="L60"></span>
<span class="fc" id="L61">  public int executeUpdate(StatementScope statementScope, Transaction trans, Object parameterObject)</span>
<span class="fc" id="L62">      throws SQLException {</span>
<span class="fc" id="L63">    ErrorContext errorContext = statementScope.getErrorContext();</span>
    errorContext.setActivity(&quot;preparing the mapped statement for execution&quot;);
<span class="fc" id="L65">    errorContext.setObjectId(this.getId());</span>
    errorContext.setResource(this.getResource());

<span class="fc" id="L68">    statementScope.getSession().setCommitRequired(true);</span>

<span class="fc" id="L70">    try {</span>
      parameterObject = validateParameter(parameterObject);
<span class="fc" id="L72"></span>
<span class="fc" id="L73">      Sql sql = getSql();</span>

<span class="fc" id="L75">      errorContext.setMoreInfo(&quot;Check the parameter map.&quot;);</span>
<span class="fc" id="L76">      ParameterMap parameterMap = sql.getParameterMap(statementScope, parameterObject);</span>

<span class="fc" id="L78">      errorContext.setMoreInfo(&quot;Check the result map.&quot;);</span>
<span class="fc" id="L79">      ResultMap resultMap = sql.getResultMap(statementScope, parameterObject);</span>

<span class="fc" id="L81">      statementScope.setResultMap(resultMap);</span>
      statementScope.setParameterMap(parameterMap);
<span class="fc" id="L83"></span>
<span class="fc" id="L84">      int rows = 0;</span>

<span class="fc" id="L86">      errorContext.setMoreInfo(&quot;Check the parameter map.&quot;);</span>
<span class="fc" id="L87">      Object[] parameters = parameterMap.getParameterObjectValues(statementScope, parameterObject);</span>

<span class="fc" id="L89">      errorContext.setMoreInfo(&quot;Check the SQL statement.&quot;);</span>
<span class="fc" id="L90">      String sqlString = sql.getSql(statementScope, parameterObject);</span>
<span class="fc" id="L91"></span>
      errorContext.setActivity(&quot;executing mapped statement&quot;);
<span class="fc" id="L93">      errorContext.setMoreInfo(&quot;Check the statement or the result map.&quot;);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">      rows = sqlExecuteUpdate(statementScope, trans.getConnection(), sqlString, parameters);</span>
<span class="fc" id="L95"></span>
      errorContext.setMoreInfo(&quot;Check the output parameters.&quot;);
      if (parameterObject != null) {
<span class="fc" id="L98">        postProcessParameterObject(statementScope, parameterObject, parameters);</span>
<span class="fc" id="L99">      }</span>
<span class="fc" id="L100"></span>
<span class="fc" id="L101">      errorContext.reset();</span>
<span class="fc" id="L102">      sql.cleanup(statementScope);</span>
<span class="fc" id="L103">      notifyListeners();</span>
<span class="fc" id="L104">      return rows;</span>
<span class="fc" id="L105">    } catch (SQLException e) {</span>
<span class="fc" id="L106">      errorContext.setCause(e);</span>
<span class="fc" id="L107">      throw new NestedSQLException(errorContext.toString(), e.getSQLState(), e.getErrorCode(), e);</span>
    } catch (Exception e) {
      errorContext.setCause(e);
      throw new NestedSQLException(errorContext.toString(), e);
    }
  }

<span class="fc" id="L114">  public Object executeQueryForObject(StatementScope statementScope, Transaction trans, Object parameterObject,</span>
      Object resultObject) throws SQLException {
<span class="fc" id="L116">    try {</span>
<span class="fc" id="L117">      Object object = null;</span>

<span class="fc" id="L119">      DefaultRowHandler rowHandler = new DefaultRowHandler();</span>
      executeQueryWithCallback(statementScope, trans.getConnection(), parameterObject, resultObject, rowHandler,
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">          SqlExecutor.NO_SKIPPED_RESULTS, SqlExecutor.NO_MAXIMUM_RESULTS);</span>
<span class="nc" id="L122">      List list = rowHandler.getList();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered."></span>
<span class="fc" id="L124">      if (list.size() &gt; 1) {</span>
        throw new SQLException(&quot;Error: executeQueryForObject returned too many results.&quot;);
      } else if (list.size() &gt; 0) {
<span class="fc" id="L127">        object = list.get(0);</span>
<span class="nc" id="L128">      }</span>
<span class="nc" id="L129"></span>
      return object;
    } catch (TransactionException e) {
      throw new NestedSQLException(&quot;Error getting Connection from Transaction.  Cause: &quot; + e, e);
    }
  }

<span class="fc" id="L136">  public List executeQueryForList(StatementScope statementScope, Transaction trans, Object parameterObject,</span>
<span class="fc" id="L137">      int skipResults, int maxResults) throws SQLException {</span>
    try {
<span class="fc" id="L139">      DefaultRowHandler rowHandler = new DefaultRowHandler();</span>
<span class="nc" id="L140">      executeQueryWithCallback(statementScope, trans.getConnection(), parameterObject, null, rowHandler, skipResults,</span>
<span class="nc" id="L141">          maxResults);</span>
      return rowHandler.getList();
    } catch (TransactionException e) {
      throw new NestedSQLException(&quot;Error getting Connection from Transaction.  Cause: &quot; + e, e);
    }
  }

<span class="fc" id="L148">  public void executeQueryWithRowHandler(StatementScope statementScope, Transaction trans, Object parameterObject,</span>
      RowHandler rowHandler) throws SQLException {
<span class="nc" id="L150">    try {</span>
<span class="nc" id="L151">      executeQueryWithCallback(statementScope, trans.getConnection(), parameterObject, null, rowHandler,</span>
<span class="fc" id="L152">          SqlExecutor.NO_SKIPPED_RESULTS, SqlExecutor.NO_MAXIMUM_RESULTS);</span>
<span class="fc" id="L153">    } catch (TransactionException e) {</span>
      throw new NestedSQLException(&quot;Error getting Connection from Transaction.  Cause: &quot; + e, e);
    }
  }

  //
  // PROTECTED METHODS
  //
<span class="fc" id="L161"></span>
<span class="fc" id="L162">  protected void executeQueryWithCallback(StatementScope statementScope, Connection conn, Object parameterObject,</span>
<span class="fc" id="L163">      Object resultObject, RowHandler rowHandler, int skipResults, int maxResults) throws SQLException {</span>
<span class="fc" id="L164">    ErrorContext errorContext = statementScope.getErrorContext();</span>
    errorContext.setActivity(&quot;preparing the mapped statement for execution&quot;);
    errorContext.setObjectId(this.getId());
<span class="fc" id="L167">    errorContext.setResource(this.getResource());</span>

<span class="fc" id="L169">    try {</span>
      parameterObject = validateParameter(parameterObject);
<span class="fc" id="L171"></span>
<span class="fc" id="L172">      Sql sql = getSql();</span>

<span class="fc" id="L174">      errorContext.setMoreInfo(&quot;Check the parameter map.&quot;);</span>
<span class="fc" id="L175">      ParameterMap parameterMap = sql.getParameterMap(statementScope, parameterObject);</span>

<span class="fc" id="L177">      errorContext.setMoreInfo(&quot;Check the result map.&quot;);</span>
<span class="fc" id="L178">      ResultMap resultMap = sql.getResultMap(statementScope, parameterObject);</span>

<span class="fc" id="L180">      statementScope.setResultMap(resultMap);</span>
<span class="fc" id="L181">      statementScope.setParameterMap(parameterMap);</span>

<span class="fc" id="L183">      errorContext.setMoreInfo(&quot;Check the parameter map.&quot;);</span>
<span class="fc" id="L184">      Object[] parameters = parameterMap.getParameterObjectValues(statementScope, parameterObject);</span>

<span class="fc" id="L186">      errorContext.setMoreInfo(&quot;Check the SQL statement.&quot;);</span>
<span class="fc" id="L187">      String sqlString = sql.getSql(statementScope, parameterObject);</span>
<span class="fc" id="L188"></span>
<span class="fc" id="L189">      errorContext.setActivity(&quot;executing mapped statement&quot;);</span>
      errorContext.setMoreInfo(&quot;Check the SQL statement or the result map.&quot;);
<span class="fc" id="L191">      RowHandlerCallback callback = new RowHandlerCallback(resultMap, resultObject, rowHandler);</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">      sqlExecuteQuery(statementScope, conn, sqlString, parameters, skipResults, maxResults, callback);</span>
<span class="fc" id="L193"></span>
      errorContext.setMoreInfo(&quot;Check the output parameters.&quot;);
      if (parameterObject != null) {
<span class="fc" id="L196">        postProcessParameterObject(statementScope, parameterObject, parameters);</span>
<span class="fc" id="L197">      }</span>
<span class="fc" id="L198"></span>
<span class="fc" id="L199">      errorContext.reset();</span>
<span class="fc" id="L200">      sql.cleanup(statementScope);</span>
<span class="fc" id="L201">      notifyListeners();</span>
<span class="nc" id="L202">    } catch (SQLException e) {</span>
<span class="nc" id="L203">      errorContext.setCause(e);</span>
<span class="nc" id="L204">      throw new NestedSQLException(errorContext.toString(), e.getSQLState(), e.getErrorCode(), e);</span>
<span class="fc" id="L205">    } catch (Exception e) {</span>
<span class="fc" id="L206">      errorContext.setCause(e);</span>
      throw new NestedSQLException(errorContext.toString(), e);
    }
<span class="fc" id="L209">  }</span>

  protected void postProcessParameterObject(StatementScope statementScope, Object parameterObject, Object[] parameters) {
  }
<span class="fc bfc" id="L213" title="All 2 branches covered."></span>
<span class="fc" id="L214">  protected int sqlExecuteUpdate(StatementScope statementScope, Connection conn, String sqlString, Object[] parameters)</span>
<span class="fc" id="L215">      throws SQLException {</span>
    if (statementScope.getSession().isInBatch()) {
<span class="fc" id="L217">      getSqlExecutor().addBatch(statementScope, conn, sqlString, parameters);</span>
      return 0;
    } else {
      return getSqlExecutor().executeUpdate(statementScope, conn, sqlString, parameters);
    }
  }
<span class="fc" id="L223"></span>
<span class="fc" id="L224">  protected void sqlExecuteQuery(StatementScope statementScope, Connection conn, String sqlString, Object[] parameters,</span>
      int skipResults, int maxResults, RowHandlerCallback callback) throws SQLException {
    getSqlExecutor().executeQuery(statementScope, conn, sqlString, parameters, skipResults, maxResults, callback);
<span class="fc" id="L227">  }</span>
<span class="fc" id="L228"></span>
<span class="fc bfc" id="L229" title="All 4 branches covered.">  protected Object validateParameter(Object param) throws SQLException {</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">    Object newParam = param;</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">    Class parameterClass = getParameterClass();</span>
<span class="pc bpc" id="L232" title="1 of 4 branches missed.">    if (newParam != null &amp;&amp; parameterClass != null) {</span>
<span class="nc" id="L233">      if (DomTypeMarker.class.isAssignableFrom(parameterClass)) {</span>
<span class="nc" id="L234">        if (XmlTypeMarker.class.isAssignableFrom(parameterClass)) {</span>
          if (!(newParam instanceof String) &amp;&amp; !(newParam instanceof Document)) {
<span class="fc bfc" id="L236" title="All 2 branches covered.">            throw new SQLException(&quot;Invalid parameter object type.  Expected '&quot; + String.class.getName() + &quot;' or '&quot;</span>
<span class="fc" id="L237">                + Document.class.getName() + &quot;' but found '&quot; + newParam.getClass().getName() + &quot;'.&quot;);</span>
          }
          if (!(newParam instanceof Document)) {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">            newParam = stringToDocument((String) newParam);</span>
<span class="nc" id="L241">          }</span>
<span class="nc" id="L242">        } else {</span>
          if (!Document.class.isAssignableFrom(newParam.getClass())) {
            throw new SQLException(&quot;Invalid parameter object type.  Expected '&quot; + Document.class.getName()
                + &quot;' but found '&quot; + newParam.getClass().getName() + &quot;'.&quot;);
<span class="fc bfc" id="L246" title="All 2 branches covered.">          }</span>
<span class="fc" id="L247">        }</span>
<span class="fc" id="L248">      } else {</span>
        if (!parameterClass.isAssignableFrom(newParam.getClass())) {
          throw new SQLException(&quot;Invalid parameter object type.  Expected '&quot; + parameterClass.getName()
              + &quot;' but found '&quot; + newParam.getClass().getName() + &quot;'.&quot;);
<span class="fc" id="L252">        }</span>
      }
    }
    return newParam;
  }
<span class="fc" id="L257"></span>
<span class="fc" id="L258">  private Document stringToDocument(String s) {</span>
<span class="fc" id="L259">    try {</span>
<span class="nc" id="L260">      DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L261">      DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();</span>
      return documentBuilder.parse(new ReaderInputStream(new StringReader(s)));
    } catch (Exception e) {
      throw new RuntimeException(&quot;Error occurred.  Cause: &quot; + e, e);
    }
<span class="fc" id="L266">  }</span>

  public String getId() {
    return id;
<span class="fc" id="L270">  }</span>

  public Integer getResultSetType() {
    return resultSetType;
<span class="nc" id="L274">  }</span>
<span class="nc" id="L275"></span>
  public void setResultSetType(Integer resultSetType) {
    this.resultSetType = resultSetType;
<span class="fc" id="L278">  }</span>

  public Integer getFetchSize() {
    return fetchSize;
<span class="nc" id="L282">  }</span>
<span class="nc" id="L283"></span>
  public void setFetchSize(Integer fetchSize) {
    this.fetchSize = fetchSize;
<span class="fc" id="L286">  }</span>
<span class="fc" id="L287"></span>
  public void setId(String id) {
    this.id = id;
<span class="fc" id="L290">  }</span>

  public Sql getSql() {
    return sql;
<span class="fc" id="L294">  }</span>
<span class="fc" id="L295"></span>
  public void setSql(Sql sql) {
    this.sql = sql;
<span class="fc" id="L298">  }</span>

  public ResultMap getResultMap() {
    return resultMap;
<span class="fc" id="L302">  }</span>
<span class="fc" id="L303"></span>
  public void setResultMap(ResultMap resultMap) {
    this.resultMap = resultMap;
<span class="fc" id="L306">  }</span>

  public ParameterMap getParameterMap() {
    return parameterMap;
<span class="fc" id="L310">  }</span>
<span class="fc" id="L311"></span>
  public void setParameterMap(ParameterMap parameterMap) {
    this.parameterMap = parameterMap;
<span class="fc" id="L314">  }</span>

  public Class getParameterClass() {
    return parameterClass;
<span class="fc" id="L318">  }</span>
<span class="fc" id="L319"></span>
  public void setParameterClass(Class parameterClass) {
    this.parameterClass = parameterClass;
<span class="fc" id="L322">  }</span>

  public String getResource() {
    return resource;
<span class="fc" id="L326">  }</span>
<span class="fc" id="L327"></span>
  public void setResource(String resource) {
    this.resource = resource;
<span class="fc" id="L330">  }</span>
<span class="fc" id="L331"></span>
<span class="fc" id="L332">  public CacheKey getCacheKey(StatementScope statementScope, Object parameterObject) {</span>
<span class="fc" id="L333">    Sql sql = statementScope.getSql();</span>
    ParameterMap pmap = sql.getParameterMap(statementScope, parameterObject);
    CacheKey cacheKey = pmap.getCacheKey(statementScope, parameterObject);
    cacheKey.update(id);

    // I am not sure how any clustered cache solution would ever have had any cache hits against
    // replicated objects. I could not make it happen
    // The baseCacheKey value which was being used in the update below is consistent across
    // JVMInstances on the same machine
    // but it's not consistent across machines, and therefore breaks clustered caching.

    // What would happen is the cache values were being replicated across machines but there
    // were never any cache hits for cached objects on
    // anything but the original machine an object was created on.

    // After reviewing this implementation I could not figure out why baseCacheKey is used for
    // this anyway as it's not needed, so I removed it.
    // The values used from the pmap.getCacheKey, plus id, plus the params below are unique and
    // the same accross machines, so now I get replicated
    // cache hits when I force failover in my cluster

    // I wish I could make a unit test for this, but I can't do it as the old implementaion
<span class="fc" id="L355">    // works on 1 machine, but fails across machines.</span>
<span class="fc" id="L356">    // cacheKey.update(baseCacheKey);</span>

    cacheKey.update(sql.getSql(statementScope, parameterObject)); // Fixes bug 953001
    return cacheKey;
<span class="fc" id="L360">  }</span>
<span class="fc" id="L361"></span>
  public void setBaseCacheKey(int base) {
    this.baseCacheKey = base;
<span class="fc" id="L364">  }</span>
<span class="fc" id="L365"></span>
  public void addExecuteListener(ExecuteListener listener) {
    executeListeners.add(listener);
<span class="fc bfc" id="L368" title="All 2 branches covered.">  }</span>
<span class="fc" id="L369"></span>
  public void notifyListeners() {
<span class="fc" id="L371">    for (int i = 0, n = executeListeners.size(); i &lt; n; i++) {</span>
      ((ExecuteListener) executeListeners.get(i)).onExecuteStatement(this);
    }
<span class="fc" id="L374">  }</span>

  public SqlExecutor getSqlExecutor() {
    return sqlMapClient.getSqlExecutor();
<span class="nc" id="L378">  }</span>

  public SqlMapClient getSqlMapClient() {
    return sqlMapClient;
<span class="fc" id="L382">  }</span>
<span class="fc" id="L383"></span>
  public void setSqlMapClient(SqlMapClient sqlMapClient) {
    this.sqlMapClient = (SqlMapClientImpl) sqlMapClient;
<span class="fc" id="L386">  }</span>
<span class="fc" id="L387"></span>
<span class="fc" id="L388">  public void initRequest(StatementScope statementScope) {</span>
<span class="fc" id="L389">    statementScope.setStatement(this);</span>
<span class="fc" id="L390">    statementScope.setParameterMap(parameterMap);</span>
    statementScope.setResultMap(resultMap);
    statementScope.setSql(sql);
<span class="fc" id="L393">  }</span>

  public Integer getTimeout() {
    return timeout;
<span class="fc" id="L397">  }</span>
<span class="fc" id="L398"></span>
  public void setTimeout(Integer timeout) {
    this.timeout = timeout;
<span class="fc" id="L401">  }</span>
<span class="fc" id="L402"></span>
<span class="fc" id="L403">  public void addResultMap(ResultMap resultMap) {</span>
<span class="fc" id="L404">    List resultMapList = Arrays.asList(additionalResultMaps);</span>
<span class="fc" id="L405">    resultMapList = new ArrayList(resultMapList);</span>
    resultMapList.add(resultMap);
    additionalResultMaps = (ResultMap[]) resultMapList.toArray(new ResultMap[resultMapList.size()]);
<span class="fc bfc" id="L408" title="All 2 branches covered.">  }</span>

  public boolean hasMultipleResultMaps() {
    return additionalResultMaps.length &gt; 0;
<span class="fc" id="L412">  }</span>

  public ResultMap[] getAdditionalResultMaps() {
    return additionalResultMaps;
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>