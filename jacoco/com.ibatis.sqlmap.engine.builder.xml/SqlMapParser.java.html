<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SqlMapParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.builder.xml</a> &gt; <span class="el_source">SqlMapParser.java</span></div><h1>SqlMapParser.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">/**</span>
 *    Copyright 2004-2015 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.ibatis.sqlmap.engine.builder.xml;

import com.ibatis.common.xml.*;
import com.ibatis.common.resources.*;
import com.ibatis.sqlmap.client.*;
import com.ibatis.sqlmap.engine.config.*;
import com.ibatis.sqlmap.engine.mapping.statement.*;
import com.ibatis.sqlmap.engine.cache.*;
import org.w3c.dom.Node;

import java.io.*;
import java.util.Properties;

public class SqlMapParser {

  private final NodeletParser parser;
  private XmlParserState state;
  private SqlStatementParser statementParser;

<span class="fc" id="L35">  public SqlMapParser(XmlParserState state) {</span>
<span class="fc" id="L36">    this.parser = new NodeletParser();</span>
<span class="fc" id="L37">    this.state = state;</span>

<span class="fc" id="L39">    parser.setValidation(true);</span>
<span class="fc" id="L40">    parser.setEntityResolver(new SqlMapClasspathEntityResolver());</span>

<span class="fc" id="L42">    statementParser = new SqlStatementParser(this.state);</span>

<span class="fc" id="L44">    addSqlMapNodelets();</span>
<span class="fc" id="L45">    addSqlNodelets();</span>
<span class="fc" id="L46">    addTypeAliasNodelets();</span>
<span class="fc" id="L47">    addCacheModelNodelets();</span>
<span class="fc" id="L48">    addParameterMapNodelets();</span>
<span class="fc" id="L49">    addResultMapNodelets();</span>
<span class="fc" id="L50">    addStatementNodelets();</span>

<span class="fc" id="L52">  }</span>

  public void parse(Reader reader) throws NodeletException {
<span class="fc" id="L55">    parser.parse(reader);</span>
<span class="fc" id="L56">  }</span>

  public void parse(InputStream inputStream) throws NodeletException {
<span class="nc" id="L59">    parser.parse(inputStream);</span>
<span class="nc" id="L60">  }</span>

  private void addSqlMapNodelets() {
<span class="fc" id="L63">    parser.addNodelet(&quot;/sqlMap&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L65">        Properties attributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());</span>
<span class="fc" id="L66">        state.setNamespace(attributes.getProperty(&quot;namespace&quot;));</span>
<span class="fc" id="L67">      }</span>
    });
<span class="fc" id="L69">  }</span>

  private void addSqlNodelets() {
<span class="fc" id="L72">    parser.addNodelet(&quot;/sqlMap/sql&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L74">        Properties attributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());</span>
<span class="fc" id="L75">        String id = attributes.getProperty(&quot;id&quot;);</span>
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        if (state.isUseStatementNamespaces()) {</span>
<span class="nc" id="L77">          id = state.applyNamespace(id);</span>
        }
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if (state.getSqlIncludes().containsKey(id)) {</span>
<span class="nc" id="L80">          throw new SqlMapException(&quot;Duplicate &lt;sql&gt;-include '&quot; + id + &quot;' found.&quot;);</span>
        } else {
<span class="fc" id="L82">          state.getSqlIncludes().put(id, node);</span>
        }
<span class="fc" id="L84">      }</span>
    });
<span class="fc" id="L86">  }</span>

  private void addTypeAliasNodelets() {
<span class="fc" id="L89">    parser.addNodelet(&quot;/sqlMap/typeAlias&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L91">        Properties prop = NodeletUtils.parseAttributes(node, state.getGlobalProps());</span>
<span class="fc" id="L92">        String alias = prop.getProperty(&quot;alias&quot;);</span>
<span class="fc" id="L93">        String type = prop.getProperty(&quot;type&quot;);</span>
<span class="fc" id="L94">        state.getConfig().getTypeHandlerFactory().putTypeAlias(alias, type);</span>
<span class="fc" id="L95">      }</span>
    });
<span class="fc" id="L97">  }</span>

  private void addCacheModelNodelets() {
<span class="fc" id="L100">    parser.addNodelet(&quot;/sqlMap/cacheModel&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L102">        Properties attributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());</span>
<span class="fc" id="L103">        String id = state.applyNamespace(attributes.getProperty(&quot;id&quot;));</span>
<span class="fc" id="L104">        String type = attributes.getProperty(&quot;type&quot;);</span>
<span class="fc" id="L105">        String readOnlyAttr = attributes.getProperty(&quot;readOnly&quot;);</span>
<span class="pc bpc" id="L106" title="1 of 4 branches missed.">        Boolean readOnly = readOnlyAttr == null || readOnlyAttr.length() &lt;= 0 ? null : new Boolean(&quot;true&quot;.equals(readOnlyAttr));</span>
<span class="fc" id="L107">        String serializeAttr = attributes.getProperty(&quot;serialize&quot;);</span>
<span class="pc bpc" id="L108" title="1 of 4 branches missed.">        Boolean serialize = serializeAttr == null || serializeAttr.length() &lt;= 0 ? null : new Boolean(&quot;true&quot;.equals(serializeAttr));</span>
<span class="fc" id="L109">        type = state.getConfig().getTypeHandlerFactory().resolveAlias(type);</span>
<span class="fc" id="L110">        Class clazz = Resources.classForName(type);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (readOnly == null) {</span>
<span class="fc" id="L112">          readOnly = Boolean.TRUE;</span>
        }
<span class="fc bfc" id="L114" title="All 2 branches covered.">        if (serialize == null) {</span>
<span class="fc" id="L115">          serialize = Boolean.FALSE;</span>
        }
<span class="fc" id="L117">        CacheModelConfig cacheConfig = state.getConfig().newCacheModelConfig(id, (CacheController) Resources.instantiate(clazz), readOnly.booleanValue(), serialize.booleanValue());</span>
<span class="fc" id="L118">        state.setCacheConfig(cacheConfig);</span>
<span class="fc" id="L119">      }</span>
    });
<span class="fc" id="L121">    parser.addNodelet(&quot;/sqlMap/cacheModel/end()&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L123">        state.getCacheConfig().setControllerProperties(state.getCacheProps());</span>
<span class="fc" id="L124">      }</span>
    });
<span class="fc" id="L126">    parser.addNodelet(&quot;/sqlMap/cacheModel/property&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L128">        state.getConfig().getErrorContext().setMoreInfo(&quot;Check the cache model properties.&quot;);</span>
<span class="fc" id="L129">        Properties attributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());</span>
<span class="fc" id="L130">        String name = attributes.getProperty(&quot;name&quot;);</span>
<span class="fc" id="L131">        String value = NodeletUtils.parsePropertyTokens(attributes.getProperty(&quot;value&quot;), state.getGlobalProps());</span>
<span class="fc" id="L132">        state.getCacheProps().setProperty(name, value);</span>
<span class="fc" id="L133">      }</span>
    });
<span class="fc" id="L135">    parser.addNodelet(&quot;/sqlMap/cacheModel/flushOnExecute&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L137">        Properties childAttributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());</span>
<span class="fc" id="L138">        String statement = childAttributes.getProperty(&quot;statement&quot;);</span>
<span class="fc" id="L139">        state.getCacheConfig().addFlushTriggerStatement(statement);</span>
<span class="fc" id="L140">      }</span>
    });
<span class="fc" id="L142">    parser.addNodelet(&quot;/sqlMap/cacheModel/flushInterval&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L144">        Properties childAttributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());</span>
        try {
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">          int milliseconds = childAttributes.getProperty(&quot;milliseconds&quot;) == null ? 0 : Integer.parseInt(childAttributes.getProperty(&quot;milliseconds&quot;));</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">          int seconds = childAttributes.getProperty(&quot;seconds&quot;) == null ? 0 : Integer.parseInt(childAttributes.getProperty(&quot;seconds&quot;));</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">          int minutes = childAttributes.getProperty(&quot;minutes&quot;) == null ? 0 : Integer.parseInt(childAttributes.getProperty(&quot;minutes&quot;));</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">          int hours = childAttributes.getProperty(&quot;hours&quot;) == null ? 0 : Integer.parseInt(childAttributes.getProperty(&quot;hours&quot;));</span>
<span class="fc" id="L150">          state.getCacheConfig().setFlushInterval(hours, minutes, seconds, milliseconds);</span>
<span class="pc" id="L151">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L152">          throw new RuntimeException(&quot;Error building cache in '&quot; + &quot;resourceNAME&quot; + &quot;'.  Flush interval milliseconds must be a valid long integer value.  Cause: &quot; + e, e);</span>
        }
<span class="fc" id="L154">      }</span>
    });
<span class="fc" id="L156">  }</span>

  private void addParameterMapNodelets() {
<span class="fc" id="L159">    parser.addNodelet(&quot;/sqlMap/parameterMap/end()&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L161">        state.getConfig().getErrorContext().setMoreInfo(null);</span>
<span class="fc" id="L162">        state.getConfig().getErrorContext().setObjectId(null);</span>
<span class="fc" id="L163">        state.setParamConfig(null);</span>
<span class="fc" id="L164">      }</span>
    });
<span class="fc" id="L166">    parser.addNodelet(&quot;/sqlMap/parameterMap&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L168">        Properties attributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());</span>
<span class="fc" id="L169">        String id = state.applyNamespace(attributes.getProperty(&quot;id&quot;));</span>
<span class="fc" id="L170">        String parameterClassName = attributes.getProperty(&quot;class&quot;);</span>
<span class="fc" id="L171">        parameterClassName = state.getConfig().getTypeHandlerFactory().resolveAlias(parameterClassName);</span>
        try {
<span class="fc" id="L173">          state.getConfig().getErrorContext().setMoreInfo(&quot;Check the parameter class.&quot;);</span>
<span class="fc" id="L174">          ParameterMapConfig paramConf = state.getConfig().newParameterMapConfig(id, Resources.classForName(parameterClassName));</span>
<span class="fc" id="L175">          state.setParamConfig(paramConf);</span>
<span class="pc" id="L176">        } catch (Exception e) {</span>
<span class="nc" id="L177">          throw new SqlMapException(&quot;Error configuring ParameterMap.  Could not set ParameterClass.  Cause: &quot; + e, e);</span>
        }
<span class="fc" id="L179">      }</span>
    });
<span class="fc" id="L181">    parser.addNodelet(&quot;/sqlMap/parameterMap/parameter&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L183">        Properties childAttributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());</span>
<span class="fc" id="L184">        String propertyName = childAttributes.getProperty(&quot;property&quot;);</span>
<span class="fc" id="L185">        String jdbcType = childAttributes.getProperty(&quot;jdbcType&quot;);</span>
<span class="fc" id="L186">        String type = childAttributes.getProperty(&quot;typeName&quot;);</span>
<span class="fc" id="L187">        String javaType = childAttributes.getProperty(&quot;javaType&quot;);</span>
<span class="fc" id="L188">        String resultMap = state.applyNamespace(childAttributes.getProperty(&quot;resultMap&quot;));</span>
<span class="fc" id="L189">        String nullValue = childAttributes.getProperty(&quot;nullValue&quot;);</span>
<span class="fc" id="L190">        String mode = childAttributes.getProperty(&quot;mode&quot;);</span>
<span class="fc" id="L191">        String callback = childAttributes.getProperty(&quot;typeHandler&quot;);</span>
<span class="fc" id="L192">        String numericScaleProp = childAttributes.getProperty(&quot;numericScale&quot;);</span>

<span class="fc" id="L194">        callback = state.getConfig().getTypeHandlerFactory().resolveAlias(callback);</span>
<span class="fc" id="L195">        Object typeHandlerImpl = null;</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (callback != null) {</span>
<span class="fc" id="L197">          typeHandlerImpl = Resources.instantiate(callback);</span>
        }

<span class="fc" id="L200">        javaType = state.getConfig().getTypeHandlerFactory().resolveAlias(javaType);</span>
<span class="fc" id="L201">        Class javaClass = null;</span>
        try {
<span class="pc bpc" id="L203" title="1 of 4 branches missed.">          if (javaType != null &amp;&amp; javaType.length() &gt; 0) {</span>
<span class="fc" id="L204">            javaClass = Resources.classForName(javaType);</span>
          }
<span class="pc" id="L206">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L207">          throw new RuntimeException(&quot;Error setting javaType on parameter mapping.  Cause: &quot; + e);</span>
        }

<span class="fc" id="L210">        Integer numericScale = null;</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        if (numericScaleProp != null) {</span>
<span class="nc" id="L212">          numericScale = new Integer(numericScaleProp);</span>
        }

<span class="fc" id="L215">        state.getParamConfig().addParameterMapping(propertyName, javaClass, jdbcType, nullValue, mode, type, numericScale, typeHandlerImpl, resultMap);</span>
<span class="fc" id="L216">      }</span>
    });
<span class="fc" id="L218">  }</span>


  private void addResultMapNodelets() {
<span class="fc" id="L222">    parser.addNodelet(&quot;/sqlMap/resultMap/end()&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L224">        state.getConfig().getErrorContext().setMoreInfo(null);</span>
<span class="fc" id="L225">        state.getConfig().getErrorContext().setObjectId(null);</span>
<span class="fc" id="L226">      }</span>
    });
<span class="fc" id="L228">    parser.addNodelet(&quot;/sqlMap/resultMap&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L230">        Properties attributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());</span>
<span class="fc" id="L231">        String id = state.applyNamespace(attributes.getProperty(&quot;id&quot;));</span>
<span class="fc" id="L232">        String resultClassName = attributes.getProperty(&quot;class&quot;);</span>
<span class="fc" id="L233">        String extended = state.applyNamespace(attributes.getProperty(&quot;extends&quot;));</span>
<span class="fc" id="L234">        String xmlName = attributes.getProperty(&quot;xmlName&quot;);</span>
<span class="fc" id="L235">        String groupBy = attributes.getProperty(&quot;groupBy&quot;);</span>

<span class="fc" id="L237">        resultClassName = state.getConfig().getTypeHandlerFactory().resolveAlias(resultClassName);</span>
        Class resultClass;
        try {
<span class="fc" id="L240">          state.getConfig().getErrorContext().setMoreInfo(&quot;Check the result class.&quot;);</span>
<span class="fc" id="L241">          resultClass = Resources.classForName(resultClassName);</span>
<span class="pc" id="L242">        } catch (Exception e) {</span>
<span class="nc" id="L243">          throw new RuntimeException(&quot;Error configuring Result.  Could not set ResultClass.  Cause: &quot; + e, e);</span>
        }
<span class="fc" id="L245">        ResultMapConfig resultConf = state.getConfig().newResultMapConfig(id, resultClass, groupBy, extended, xmlName);</span>
<span class="fc" id="L246">        state.setResultConfig(resultConf);</span>
<span class="fc" id="L247">      }</span>
    });
<span class="fc" id="L249">    parser.addNodelet(&quot;/sqlMap/resultMap/result&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L251">        Properties childAttributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());</span>
<span class="fc" id="L252">        String propertyName = childAttributes.getProperty(&quot;property&quot;);</span>
<span class="fc" id="L253">        String nullValue = childAttributes.getProperty(&quot;nullValue&quot;);</span>
<span class="fc" id="L254">        String jdbcType = childAttributes.getProperty(&quot;jdbcType&quot;);</span>
<span class="fc" id="L255">        String javaType = childAttributes.getProperty(&quot;javaType&quot;);</span>
<span class="fc" id="L256">        String columnName = childAttributes.getProperty(&quot;column&quot;);</span>
<span class="fc" id="L257">        String columnIndexProp = childAttributes.getProperty(&quot;columnIndex&quot;);</span>
<span class="fc" id="L258">        String statementName = childAttributes.getProperty(&quot;select&quot;);</span>
<span class="fc" id="L259">        String resultMapName = childAttributes.getProperty(&quot;resultMap&quot;);</span>
<span class="fc" id="L260">        String callback = childAttributes.getProperty(&quot;typeHandler&quot;);</span>
<span class="fc" id="L261">        String notNullColumn = childAttributes.getProperty(&quot;notNullColumn&quot;);</span>

<span class="fc" id="L263">        state.getConfig().getErrorContext().setMoreInfo(&quot;Check the result mapping property type or name.&quot;);</span>
<span class="fc" id="L264">        Class javaClass = null;</span>
        try {
<span class="fc" id="L266">          javaType = state.getConfig().getTypeHandlerFactory().resolveAlias(javaType);</span>
<span class="pc bpc" id="L267" title="1 of 4 branches missed.">          if (javaType != null &amp;&amp; javaType.length() &gt; 0) {</span>
<span class="fc" id="L268">            javaClass = Resources.classForName(javaType);</span>
          }
<span class="pc" id="L270">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L271">          throw new RuntimeException(&quot;Error setting java type on result discriminator mapping.  Cause: &quot; + e);</span>
        }

<span class="fc" id="L274">        state.getConfig().getErrorContext().setMoreInfo(&quot;Check the result mapping typeHandler attribute '&quot; + callback + &quot;' (must be a TypeHandler or TypeHandlerCallback implementation).&quot;);</span>
<span class="fc" id="L275">        Object typeHandlerImpl = null;</span>
        try {
<span class="pc bpc" id="L277" title="1 of 4 branches missed.">          if (callback != null &amp;&amp; callback.length() &gt; 0) {</span>
<span class="fc" id="L278">            callback = state.getConfig().getTypeHandlerFactory().resolveAlias(callback);</span>
<span class="fc" id="L279">            typeHandlerImpl = Resources.instantiate(callback);</span>
          }
<span class="pc" id="L281">        } catch (Exception e) {</span>
<span class="nc" id="L282">          throw new RuntimeException(&quot;Error occurred during custom type handler configuration.  Cause: &quot; + e, e);</span>
        }

<span class="fc" id="L285">        Integer columnIndex = null;</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (columnIndexProp != null) {</span>
          try {
<span class="fc" id="L288">            columnIndex = new Integer(columnIndexProp);</span>
<span class="pc" id="L289">          } catch (Exception e) {</span>
<span class="nc" id="L290">            throw new RuntimeException(&quot;Error parsing column index.  Cause: &quot; + e, e);</span>
          }
        }

<span class="fc" id="L294">        state.getResultConfig().addResultMapping(propertyName, columnName, columnIndex, javaClass, jdbcType, nullValue, notNullColumn, statementName, resultMapName, typeHandlerImpl);</span>
<span class="fc" id="L295">      }</span>
    });

<span class="fc" id="L298">    parser.addNodelet(&quot;/sqlMap/resultMap/discriminator/subMap&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L300">        Properties childAttributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());</span>
<span class="fc" id="L301">        String value = childAttributes.getProperty(&quot;value&quot;);</span>
<span class="fc" id="L302">        String resultMap = childAttributes.getProperty(&quot;resultMap&quot;);</span>
<span class="fc" id="L303">        resultMap = state.applyNamespace(resultMap);</span>
<span class="fc" id="L304">        state.getResultConfig().addDiscriminatorSubMap(value, resultMap);</span>
<span class="fc" id="L305">      }</span>
    });

<span class="fc" id="L308">    parser.addNodelet(&quot;/sqlMap/resultMap/discriminator&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L310">        Properties childAttributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());</span>
<span class="fc" id="L311">        String nullValue = childAttributes.getProperty(&quot;nullValue&quot;);</span>
<span class="fc" id="L312">        String jdbcType = childAttributes.getProperty(&quot;jdbcType&quot;);</span>
<span class="fc" id="L313">        String javaType = childAttributes.getProperty(&quot;javaType&quot;);</span>
<span class="fc" id="L314">        String columnName = childAttributes.getProperty(&quot;column&quot;);</span>
<span class="fc" id="L315">        String columnIndexProp = childAttributes.getProperty(&quot;columnIndex&quot;);</span>
<span class="fc" id="L316">        String callback = childAttributes.getProperty(&quot;typeHandler&quot;);</span>

<span class="fc" id="L318">        state.getConfig().getErrorContext().setMoreInfo(&quot;Check the disriminator type or name.&quot;);</span>
<span class="fc" id="L319">        Class javaClass = null;</span>
        try {
<span class="fc" id="L321">          javaType = state.getConfig().getTypeHandlerFactory().resolveAlias(javaType);</span>
<span class="pc bpc" id="L322" title="2 of 4 branches missed.">          if (javaType != null &amp;&amp; javaType.length() &gt; 0) {</span>
<span class="fc" id="L323">            javaClass = Resources.classForName(javaType);</span>
          }
<span class="pc" id="L325">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L326">          throw new RuntimeException(&quot;Error setting java type on result discriminator mapping.  Cause: &quot; + e);</span>
        }

<span class="fc" id="L329">        state.getConfig().getErrorContext().setMoreInfo(&quot;Check the result mapping discriminator typeHandler attribute '&quot; + callback + &quot;' (must be a TypeHandlerCallback implementation).&quot;);</span>
<span class="fc" id="L330">        Object typeHandlerImpl = null;</span>
        try {
<span class="pc bpc" id="L332" title="3 of 4 branches missed.">          if (callback != null &amp;&amp; callback.length() &gt; 0) {</span>
<span class="nc" id="L333">            callback = state.getConfig().getTypeHandlerFactory().resolveAlias(callback);</span>
<span class="nc" id="L334">            typeHandlerImpl = Resources.instantiate(callback);</span>
          }
<span class="nc" id="L336">        } catch (Exception e) {</span>
<span class="nc" id="L337">          throw new RuntimeException(&quot;Error occurred during custom type handler configuration.  Cause: &quot; + e, e);</span>
        }

<span class="fc" id="L340">        Integer columnIndex = null;</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        if (columnIndexProp != null) {</span>
          try {
<span class="nc" id="L343">            columnIndex = new Integer(columnIndexProp);</span>
<span class="nc" id="L344">          } catch (Exception e) {</span>
<span class="nc" id="L345">            throw new RuntimeException(&quot;Error parsing column index.  Cause: &quot; + e, e);</span>
          }
        }

<span class="fc" id="L349">        state.getResultConfig().setDiscriminator(columnName, columnIndex, javaClass, jdbcType, nullValue, typeHandlerImpl);</span>
<span class="fc" id="L350">      }</span>
    });
<span class="fc" id="L352">  }</span>

  protected void addStatementNodelets() {
<span class="fc" id="L355">    parser.addNodelet(&quot;/sqlMap/statement&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L357">        statementParser.parseGeneralStatement(node, new MappedStatement());</span>
<span class="fc" id="L358">      }</span>
    });
<span class="fc" id="L360">    parser.addNodelet(&quot;/sqlMap/insert&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L362">        statementParser.parseGeneralStatement(node, new InsertStatement());</span>
<span class="fc" id="L363">      }</span>
    });
<span class="fc" id="L365">    parser.addNodelet(&quot;/sqlMap/update&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L367">        statementParser.parseGeneralStatement(node, new UpdateStatement());</span>
<span class="fc" id="L368">      }</span>
    });
<span class="fc" id="L370">    parser.addNodelet(&quot;/sqlMap/delete&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L372">        statementParser.parseGeneralStatement(node, new DeleteStatement());</span>
<span class="fc" id="L373">      }</span>
    });
<span class="fc" id="L375">    parser.addNodelet(&quot;/sqlMap/select&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L377">        statementParser.parseGeneralStatement(node, new SelectStatement());</span>
<span class="fc" id="L378">      }</span>
    });
<span class="fc" id="L380">    parser.addNodelet(&quot;/sqlMap/procedure&quot;, new Nodelet() {</span>
      public void process(Node node) throws Exception {
<span class="fc" id="L382">        statementParser.parseGeneralStatement(node, new ProcedureStatement());</span>
<span class="fc" id="L383">      }</span>
    });
<span class="fc" id="L385">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>