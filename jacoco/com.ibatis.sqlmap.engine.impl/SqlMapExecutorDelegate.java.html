<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SqlMapExecutorDelegate.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.impl</a> &gt; <span class="el_source">SqlMapExecutorDelegate.java</span></div><h1>SqlMapExecutorDelegate.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2004-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.impl;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.sql.DataSource;

import com.ibatis.common.beans.Probe;
import com.ibatis.common.beans.ProbeFactory;
import com.ibatis.common.jdbc.exception.NestedSQLException;
import com.ibatis.common.util.PaginatedList;
import com.ibatis.sqlmap.client.SqlMapException;
import com.ibatis.sqlmap.client.event.RowHandler;
import com.ibatis.sqlmap.engine.cache.CacheKey;
import com.ibatis.sqlmap.engine.cache.CacheModel;
import com.ibatis.sqlmap.engine.exchange.DataExchangeFactory;
import com.ibatis.sqlmap.engine.execution.BatchException;
import com.ibatis.sqlmap.engine.execution.DefaultSqlExecutor;
import com.ibatis.sqlmap.engine.execution.SqlExecutor;
import com.ibatis.sqlmap.engine.mapping.parameter.ParameterMap;
import com.ibatis.sqlmap.engine.mapping.result.ResultMap;
import com.ibatis.sqlmap.engine.mapping.result.ResultObjectFactory;
import com.ibatis.sqlmap.engine.mapping.statement.InsertStatement;
import com.ibatis.sqlmap.engine.mapping.statement.MappedStatement;
import com.ibatis.sqlmap.engine.mapping.statement.PaginatedDataList;
import com.ibatis.sqlmap.engine.mapping.statement.SelectKeyStatement;
import com.ibatis.sqlmap.engine.scope.SessionScope;
import com.ibatis.sqlmap.engine.scope.StatementScope;
import com.ibatis.sqlmap.engine.transaction.Transaction;
import com.ibatis.sqlmap.engine.transaction.TransactionException;
import com.ibatis.sqlmap.engine.transaction.TransactionManager;
import com.ibatis.sqlmap.engine.transaction.TransactionState;
import com.ibatis.sqlmap.engine.transaction.user.UserProvidedTransaction;
import com.ibatis.sqlmap.engine.type.TypeHandlerFactory;

/**
 * The workhorse that really runs the SQL
<span class="fc" id="L57"> */</span>
public class SqlMapExecutorDelegate {
<span class="fc" id="L59"></span>
<span class="fc" id="L60">  private static final Probe PROBE = ProbeFactory.getProbe();</span>
<span class="fc" id="L61"></span>
<span class="fc" id="L62">  private boolean lazyLoadingEnabled = true;</span>
  private boolean cacheModelsEnabled = true;
  private boolean enhancementEnabled = false;
  private boolean useColumnLabel = true;
  private boolean forceMultipleResultSetSupport;

  private TransactionManager txManager;

  private HashMap mappedStatements;
  private HashMap cacheModels;
  private HashMap resultMaps;
  private HashMap parameterMaps;

  protected SqlExecutor sqlExecutor;
  private TypeHandlerFactory typeHandlerFactory;
<span class="fc" id="L77">  private DataExchangeFactory dataExchangeFactory;</span>

  private ResultObjectFactory resultObjectFactory;
  private boolean statementCacheEnabled = true;

<span class="fc" id="L82">  /**</span>
<span class="fc" id="L83">   * Default constructor</span>
<span class="fc" id="L84">   */</span>
<span class="fc" id="L85">  public SqlMapExecutorDelegate() {</span>
<span class="fc" id="L86">    mappedStatements = new HashMap();</span>
    cacheModels = new HashMap();
<span class="fc" id="L88">    resultMaps = new HashMap();</span>
<span class="fc" id="L89">    parameterMaps = new HashMap();</span>
<span class="fc" id="L90"></span>
<span class="fc" id="L91">    sqlExecutor = new DefaultSqlExecutor();</span>
    typeHandlerFactory = new TypeHandlerFactory();
    dataExchangeFactory = new DataExchangeFactory(typeHandlerFactory);
  }
<span class="nc" id="L95"></span>
<span class="nc" id="L96">  public void setCustomExecutor(String sqlExecutorClass) {</span>
<span class="nc" id="L97">    try {</span>
<span class="nc" id="L98">      Class factoryClass = Class.forName(sqlExecutorClass);</span>
      sqlExecutor = (SqlExecutor) factoryClass.newInstance();
<span class="nc" id="L100">    } catch (Exception e) {</span>
<span class="nc" id="L101">      throw new SqlMapException(&quot;Error instantiating &quot; + sqlExecutorClass</span>
          + &quot;. Please check the class given in properties file. Cause: &quot; + e, e);
    }
  }

  /**
   * DO NOT DEPEND ON THIS. Here to avoid breaking spring integration.
   * 
<span class="nc" id="L109">   * @deprecated</span>
   */
  public int getMaxTransactions() {
    return -1;
  }

  /**
   * Getter for the DataExchangeFactory
   *
<span class="fc" id="L118">   * @return - the DataExchangeFactory</span>
   */
  public DataExchangeFactory getDataExchangeFactory() {
    return dataExchangeFactory;
  }

  /**
   * Getter for the TypeHandlerFactory
   *
<span class="fc" id="L127">   * @return - the TypeHandlerFactory</span>
   */
  public TypeHandlerFactory getTypeHandlerFactory() {
    return typeHandlerFactory;
  }

  /**
   * Getter for the status of lazy loading
   *
<span class="fc" id="L136">   * @return - the status</span>
   */
  public boolean isLazyLoadingEnabled() {
    return lazyLoadingEnabled;
  }

  /**
   * Turn on or off lazy loading
   *
   * @param lazyLoadingEnabled
<span class="fc" id="L146">   *          - the new state of caching</span>
<span class="fc" id="L147">   */</span>
  public void setLazyLoadingEnabled(boolean lazyLoadingEnabled) {
    this.lazyLoadingEnabled = lazyLoadingEnabled;
  }

  /**
   * Getter for the status of caching
   *
<span class="fc" id="L155">   * @return - the status</span>
   */
  public boolean isCacheModelsEnabled() {
    return cacheModelsEnabled;
  }

  /**
   * Turn on or off caching
   *
   * @param cacheModelsEnabled
<span class="fc" id="L165">   *          - the new state of caching</span>
<span class="fc" id="L166">   */</span>
  public void setCacheModelsEnabled(boolean cacheModelsEnabled) {
    this.cacheModelsEnabled = cacheModelsEnabled;
  }

  /**
   * Getter for the status of CGLib enhancements
   *
<span class="fc" id="L174">   * @return - the status</span>
   */
  public boolean isEnhancementEnabled() {
    return enhancementEnabled;
  }

  /**
   * Turn on or off CGLib enhancements
   *
   * @param enhancementEnabled
<span class="fc" id="L184">   *          - the new state</span>
<span class="fc" id="L185">   */</span>
  public void setEnhancementEnabled(boolean enhancementEnabled) {
    this.enhancementEnabled = enhancementEnabled;
<span class="fc" id="L188">  }</span>

  public boolean isUseColumnLabel() {
    return useColumnLabel;
<span class="fc" id="L192">  }</span>
<span class="fc" id="L193"></span>
  public void setUseColumnLabel(boolean useColumnLabel) {
    this.useColumnLabel = useColumnLabel;
  }

  /**
   * Getter for the transaction manager
   *
<span class="fc" id="L201">   * @return - the transaction manager</span>
   */
  public TransactionManager getTxManager() {
    return txManager;
  }

  /**
   * Setter for the transaction manager
   *
   * @param txManager
<span class="fc" id="L211">   *          - the transaction manager</span>
<span class="fc" id="L212">   */</span>
  public void setTxManager(TransactionManager txManager) {
    this.txManager = txManager;
  }

  /**
   * Add a mapped statement
   *
   * @param ms
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">   *          - the mapped statement to add</span>
<span class="nc" id="L222">   */</span>
  public void addMappedStatement(MappedStatement ms) {
<span class="fc" id="L224">    if (mappedStatements.containsKey(ms.getId())) {</span>
<span class="fc" id="L225">      throw new SqlMapException(&quot;There is already a statement named &quot; + ms.getId() + &quot; in this SqlMap.&quot;);</span>
<span class="fc" id="L226">    }</span>
    ms.setBaseCacheKey(hashCode());
    mappedStatements.put(ms.getId(), ms);
  }

  /**
   * Get an iterator of the mapped statements
   *
<span class="nc" id="L234">   * @return - the iterator</span>
   */
  public Iterator getMappedStatementNames() {
    return mappedStatements.keySet().iterator();
  }

  /**
   * Get a mappedstatement by its ID
   *
   * @param id
   *          - the statement ID
<span class="fc" id="L245">   * @return - the mapped statement</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">   */</span>
<span class="nc" id="L247">  public MappedStatement getMappedStatement(String id) {</span>
    MappedStatement ms = (MappedStatement) mappedStatements.get(id);
<span class="fc" id="L249">    if (ms == null) {</span>
      throw new SqlMapException(&quot;There is no statement named &quot; + id + &quot; in this SqlMap.&quot;);
    }
    return ms;
  }

  /**
   * Add a cache model
   *
   * @param model
<span class="fc" id="L259">   *          - the model to add</span>
<span class="fc" id="L260">   */</span>
  public void addCacheModel(CacheModel model) {
    cacheModels.put(model.getId(), model);
  }

  /**
   * Get an iterator of the cache models
   *
<span class="fc" id="L268">   * @return - the cache models</span>
   */
  public Iterator getCacheModelNames() {
    return cacheModels.keySet().iterator();
  }

  /**
   * Get a cache model by ID
   *
   * @param id
   *          - the ID
<span class="fc" id="L279">   * @return - the cache model</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">   */</span>
<span class="nc" id="L281">  public CacheModel getCacheModel(String id) {</span>
    CacheModel model = (CacheModel) cacheModels.get(id);
<span class="fc" id="L283">    if (model == null) {</span>
      throw new SqlMapException(&quot;There is no cache model named &quot; + id + &quot; in this SqlMap.&quot;);
    }
    return model;
  }

  /**
   * Add a result map
   *
   * @param map
<span class="fc" id="L293">   *          - the result map to add</span>
<span class="fc" id="L294">   */</span>
  public void addResultMap(ResultMap map) {
    resultMaps.put(map.getId(), map);
  }

  /**
   * Get an iterator of the result maps
   *
<span class="fc" id="L302">   * @return - the result maps</span>
   */
  public Iterator getResultMapNames() {
    return resultMaps.keySet().iterator();
  }

  /**
   * Get a result map by ID
   *
   * @param id
   *          - the ID
<span class="fc" id="L313">   * @return - the result map</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">   */</span>
<span class="nc" id="L315">  public ResultMap getResultMap(String id) {</span>
    ResultMap map = (ResultMap) resultMaps.get(id);
<span class="fc" id="L317">    if (map == null) {</span>
      throw new SqlMapException(&quot;There is no result map named &quot; + id + &quot; in this SqlMap.&quot;);
    }
    return map;
  }

  /**
   * Add a parameter map
   *
   * @param map
<span class="fc" id="L327">   *          - the map to add</span>
<span class="fc" id="L328">   */</span>
  public void addParameterMap(ParameterMap map) {
    parameterMaps.put(map.getId(), map);
  }

  /**
   * Get an iterator of all of the parameter maps
   *
<span class="nc" id="L336">   * @return - the parameter maps</span>
   */
  public Iterator getParameterMapNames() {
    return parameterMaps.keySet().iterator();
  }

  /**
   * Get a parameter map by ID
   *
   * @param id
   *          - the ID
<span class="fc" id="L347">   * @return - the parameter map</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">   */</span>
<span class="nc" id="L349">  public ParameterMap getParameterMap(String id) {</span>
    ParameterMap map = (ParameterMap) parameterMaps.get(id);
<span class="fc" id="L351">    if (map == null) {</span>
      throw new SqlMapException(&quot;There is no parameter map named &quot; + id + &quot; in this SqlMap.&quot;);
    }
    return map;
  }

  /**
<span class="fc" id="L358">   * Flush all of the data caches</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">   */</span>
<span class="fc" id="L360">  public void flushDataCache() {</span>
    Iterator models = cacheModels.values().iterator();
<span class="fc" id="L362">    while (models.hasNext()) {</span>
      ((CacheModel) models.next()).flush();
    }
  }

  /**
   * Flush a single cache by ID
   *
   * @param id
<span class="nc" id="L371">   *          - the ID</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">   */</span>
<span class="nc" id="L373">  public void flushDataCache(String id) {</span>
    CacheModel model = getCacheModel(id);
<span class="nc" id="L375">    if (model != null) {</span>
      model.flush();
    }
  }

  // -- Basic Methods
  /**
   * Call an insert statement by ID
   *
   * @param sessionScope
   *          - the session
   * @param id
   *          - the statement ID
   * @param param
   *          - the parameter object
   * @return - the generated key (or null)
   * @throws SQLException
<span class="fc" id="L392">   *           - if the insert fails</span>
   */
<span class="fc" id="L394">  public Object insert(SessionScope sessionScope, String id, Object param) throws SQLException {</span>
<span class="fc" id="L395">    Object generatedKey = null;</span>
<span class="fc bfc" id="L396" title="All 2 branches covered."></span>
    MappedStatement ms = getMappedStatement(id);
    Transaction trans = getTransaction(sessionScope);
<span class="fc" id="L399">    boolean autoStart = trans == null;</span>

<span class="fc" id="L401">    try {</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">      trans = autoStartTransaction(sessionScope, autoStart, trans);</span>
<span class="fc" id="L403"></span>
      SelectKeyStatement selectKeyStatement = null;
      if (ms instanceof InsertStatement) {
        selectKeyStatement = ((InsertStatement) ms).getSelectKeyStatement();
      }

<span class="fc" id="L409">      // Here we get the old value for the key property. We'll want it later if for some</span>
<span class="fc" id="L410">      // reason the</span>
<span class="fc" id="L411">      // insert fails.</span>
<span class="fc bfc" id="L412" title="All 4 branches covered.">      Object oldKeyValue = null;</span>
<span class="fc" id="L413">      String keyProperty = null;</span>
<span class="fc" id="L414">      boolean resetKeyValueOnFailure = false;</span>
<span class="fc" id="L415">      if (selectKeyStatement != null &amp;&amp; !selectKeyStatement.isRunAfterSQL()) {</span>
<span class="fc" id="L416">        keyProperty = selectKeyStatement.getKeyProperty();</span>
        oldKeyValue = PROBE.getObject(param, keyProperty);
        generatedKey = executeSelectKey(sessionScope, trans, ms, param);
<span class="fc" id="L419">        resetKeyValueOnFailure = true;</span>
      }
<span class="fc" id="L421"></span>
<span class="fc" id="L422">      StatementScope statementScope = beginStatementScope(sessionScope, ms);</span>
      try {
        ms.executeUpdate(statementScope, trans, param);
      } catch (SQLException e) {
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        // uh-oh, the insert failed, so if we set the reset flag earlier, we'll put the old</span>
<span class="nc" id="L427">        // value</span>
        // back...
<span class="fc" id="L429">        if (resetKeyValueOnFailure)</span>
          PROBE.setObject(param, keyProperty, oldKeyValue);
<span class="fc" id="L431">        // ...and still throw the exception.</span>
<span class="fc" id="L432">        throw e;</span>
      } finally {
<span class="fc bfc" id="L434" title="All 4 branches covered.">        endStatementScope(statementScope);</span>
<span class="fc" id="L435">      }</span>

      if (selectKeyStatement != null &amp;&amp; selectKeyStatement.isRunAfterSQL()) {
<span class="fc" id="L438">        generatedKey = executeSelectKey(sessionScope, trans, ms, param);</span>
      }
<span class="fc" id="L440"></span>
<span class="fc" id="L441">      autoCommitTransaction(sessionScope, autoStart);</span>
    } finally {
<span class="fc" id="L443">      autoEndTransaction(sessionScope, autoStart);</span>
    }

    return generatedKey;
  }
<span class="fc" id="L448"></span>
  private Object executeSelectKey(SessionScope sessionScope, Transaction trans, MappedStatement ms, Object param)
<span class="fc" id="L450">      throws SQLException {</span>
<span class="fc" id="L451">    Object generatedKey = null;</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">    StatementScope statementScope;</span>
<span class="fc" id="L453">    InsertStatement insert = (InsertStatement) ms;</span>
    SelectKeyStatement selectKeyStatement = insert.getSelectKeyStatement();
<span class="fc" id="L455">    if (selectKeyStatement != null) {</span>
<span class="fc" id="L456">      statementScope = beginStatementScope(sessionScope, selectKeyStatement);</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">      try {</span>
<span class="fc" id="L458">        generatedKey = selectKeyStatement.executeQueryForObject(statementScope, trans, param, null);</span>
        String keyProp = selectKeyStatement.getKeyProperty();
        if (keyProp != null) {
<span class="pc" id="L461">          PROBE.setObject(param, keyProp, generatedKey);</span>
<span class="fc" id="L462">        }</span>
      } finally {
<span class="fc" id="L464">        endStatementScope(statementScope);</span>
      }
    }
    return generatedKey;
  }

  /**
   * Execute an update statement
   *
   * @param sessionScope
   *          - the session scope
   * @param id
   *          - the statement ID
   * @param param
   *          - the parameter object
   * @return - the number of rows updated
   * @throws SQLException
<span class="fc" id="L481">   *           - if the update fails</span>
   */
<span class="fc" id="L483">  public int update(SessionScope sessionScope, String id, Object param) throws SQLException {</span>
<span class="fc" id="L484">    int rows = 0;</span>
<span class="fc bfc" id="L485" title="All 2 branches covered."></span>
    MappedStatement ms = getMappedStatement(id);
    Transaction trans = getTransaction(sessionScope);
<span class="fc" id="L488">    boolean autoStart = trans == null;</span>

<span class="fc" id="L490">    try {</span>
      trans = autoStartTransaction(sessionScope, autoStart, trans);
<span class="fc" id="L492"></span>
      StatementScope statementScope = beginStatementScope(sessionScope, ms);
<span class="fc" id="L494">      try {</span>
<span class="fc" id="L495">        rows = ms.executeUpdate(statementScope, trans, param);</span>
      } finally {
<span class="fc" id="L497">        endStatementScope(statementScope);</span>
      }
<span class="fc" id="L499"></span>
<span class="fc" id="L500">      autoCommitTransaction(sessionScope, autoStart);</span>
    } finally {
<span class="fc" id="L502">      autoEndTransaction(sessionScope, autoStart);</span>
    }

    return rows;
  }

  /**
   * Execute a delete statement
   *
   * @param sessionScope
   *          - the session scope
   * @param id
   *          - the statement ID
   * @param param
   *          - the parameter object
   * @return - the number of rows deleted
   * @throws SQLException
<span class="nc" id="L519">   *           - if the delete fails</span>
   */
  public int delete(SessionScope sessionScope, String id, Object param) throws SQLException {
    return update(sessionScope, id, param);
  }

  /**
   * Execute a select for a single object
   *
   * @param sessionScope
   *          - the session scope
   * @param id
   *          - the statement ID
   * @param paramObject
   *          - the parameter object
   * @return - the result of the query
   * @throws SQLException
<span class="fc" id="L536">   *           - if the query fails</span>
   */
  public Object queryForObject(SessionScope sessionScope, String id, Object paramObject) throws SQLException {
    return queryForObject(sessionScope, id, paramObject, null);
  }

  /**
   * Execute a select for a single object
   *
   * @param sessionScope
   *          - the session scope
   * @param id
   *          - the statement ID
   * @param paramObject
   *          - the parameter object
   * @param resultObject
   *          - the result object (if not supplied or null, a new object will be created)
   * @return - the result of the query
   * @throws SQLException
   *           - if the query fails
<span class="fc" id="L556">   */</span>
  public Object queryForObject(SessionScope sessionScope, String id, Object paramObject, Object resultObject)
<span class="fc" id="L558">      throws SQLException {</span>
<span class="fc" id="L559">    Object object = null;</span>
<span class="fc bfc" id="L560" title="All 2 branches covered."></span>
    MappedStatement ms = getMappedStatement(id);
    Transaction trans = getTransaction(sessionScope);
<span class="fc" id="L563">    boolean autoStart = trans == null;</span>

<span class="fc" id="L565">    try {</span>
      trans = autoStartTransaction(sessionScope, autoStart, trans);
<span class="fc" id="L567"></span>
      StatementScope statementScope = beginStatementScope(sessionScope, ms);
<span class="pc" id="L569">      try {</span>
<span class="fc" id="L570">        object = ms.executeQueryForObject(statementScope, trans, paramObject, resultObject);</span>
      } finally {
<span class="fc" id="L572">        endStatementScope(statementScope);</span>
      }
<span class="pc" id="L574"></span>
<span class="fc" id="L575">      autoCommitTransaction(sessionScope, autoStart);</span>
    } finally {
<span class="fc" id="L577">      autoEndTransaction(sessionScope, autoStart);</span>
    }

    return object;
  }

  /**
   * Execute a query for a list
   *
   * @param sessionScope
   *          - the session scope
   * @param id
   *          - the statement ID
   * @param paramObject
   *          - the parameter object
   * @return - the data list
   * @throws SQLException
<span class="fc" id="L594">   *           - if the query fails</span>
   */
  public List queryForList(SessionScope sessionScope, String id, Object paramObject) throws SQLException {
    return queryForList(sessionScope, id, paramObject, SqlExecutor.NO_SKIPPED_RESULTS, SqlExecutor.NO_MAXIMUM_RESULTS);
  }

  /**
   * Execute a query for a list
   *
   * @param sessionScope
   *          - the session scope
   * @param id
   *          - the statement ID
   * @param paramObject
   *          - the parameter object
   * @param skip
   *          - the number of rows to skip
   * @param max
   *          - the maximum number of rows to return
   * @return - the data list
   * @throws SQLException
   *           - if the query fails
<span class="fc" id="L616">   */</span>
  public List queryForList(SessionScope sessionScope, String id, Object paramObject, int skip, int max)
<span class="fc" id="L618">      throws SQLException {</span>
<span class="fc" id="L619">    List list = null;</span>
<span class="fc bfc" id="L620" title="All 2 branches covered."></span>
    MappedStatement ms = getMappedStatement(id);
    Transaction trans = getTransaction(sessionScope);
<span class="fc" id="L623">    boolean autoStart = trans == null;</span>

<span class="fc" id="L625">    try {</span>
      trans = autoStartTransaction(sessionScope, autoStart, trans);
<span class="fc" id="L627"></span>
      StatementScope statementScope = beginStatementScope(sessionScope, ms);
<span class="fc" id="L629">      try {</span>
<span class="fc" id="L630">        list = ms.executeQueryForList(statementScope, trans, paramObject, skip, max);</span>
      } finally {
<span class="fc" id="L632">        endStatementScope(statementScope);</span>
      }
<span class="fc" id="L634"></span>
<span class="fc" id="L635">      autoCommitTransaction(sessionScope, autoStart);</span>
    } finally {
<span class="fc" id="L637">      autoEndTransaction(sessionScope, autoStart);</span>
    }

    return list;
  }

  /**
   * Execute a query with a row handler. The row handler is called once per row in the query results.
   *
   * @param sessionScope
   *          - the session scope
   * @param id
   *          - the statement ID
   * @param paramObject
   *          - the parameter object
   * @param rowHandler
   *          - the row handler
   * @throws SQLException
   *           - if the query fails
   */
<span class="fc" id="L657">  public void queryWithRowHandler(SessionScope sessionScope, String id, Object paramObject, RowHandler rowHandler)</span>
<span class="fc" id="L658">      throws SQLException {</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed."></span>
    MappedStatement ms = getMappedStatement(id);
    Transaction trans = getTransaction(sessionScope);
<span class="fc" id="L662">    boolean autoStart = trans == null;</span>

<span class="fc" id="L664">    try {</span>
      trans = autoStartTransaction(sessionScope, autoStart, trans);
<span class="fc" id="L666"></span>
      StatementScope statementScope = beginStatementScope(sessionScope, ms);
<span class="pc" id="L668">      try {</span>
<span class="fc" id="L669">        ms.executeQueryWithRowHandler(statementScope, trans, paramObject, rowHandler);</span>
      } finally {
<span class="fc" id="L671">        endStatementScope(statementScope);</span>
      }
<span class="pc" id="L673"></span>
<span class="fc" id="L674">      autoCommitTransaction(sessionScope, autoStart);</span>
    } finally {
<span class="fc" id="L676">      autoEndTransaction(sessionScope, autoStart);</span>
    }

  }

  /**
   * Execute a query and return a paginated list
   *
   * @param sessionScope
   *          - the session scope
   * @param id
   *          - the statement ID
   * @param paramObject
   *          - the parameter object
   * @param pageSize
   *          - the page size
   * @return - the data list
   * @throws SQLException
   *           - if the query fails
   * @deprecated All paginated list features have been deprecated
<span class="fc" id="L696">   */</span>
  public PaginatedList queryForPaginatedList(SessionScope sessionScope, String id, Object paramObject, int pageSize)
      throws SQLException {
    return new PaginatedDataList(sessionScope.getSqlMapExecutor(), id, paramObject, pageSize);
  }

  /**
   * Execute a query for a map. The map has the table key as the key, and the results as the map data
   *
   * @param sessionScope
   *          - the session scope
   * @param id
   *          - the statement ID
   * @param paramObject
   *          - the parameter object
   * @param keyProp
   *          - the key property (from the results for the map)
   * @return - the Map
   * @throws SQLException
<span class="fc" id="L715">   *           - if the query fails</span>
   */
  public Map queryForMap(SessionScope sessionScope, String id, Object paramObject, String keyProp) throws SQLException {
    return queryForMap(sessionScope, id, paramObject, keyProp, null);
  }

  /**
   * Execute a query for a map. The map has the table key as the key, and a property from the results as the map data
   *
   * @param sessionScope
   *          - the session scope
   * @param id
   *          - the statement ID
   * @param paramObject
   *          - the parameter object
   * @param keyProp
   *          - the property for the map key
   * @param valueProp
   *          - the property for the map data
   * @return - the Map
   * @throws SQLException
   *           - if the query fails
<span class="fc" id="L737">   */</span>
  public Map queryForMap(SessionScope sessionScope, String id, Object paramObject, String keyProp, String valueProp)
<span class="fc" id="L739">      throws SQLException {</span>
    Map map = new HashMap();
<span class="fc bfc" id="L741" title="All 2 branches covered."></span>
<span class="fc" id="L742">    List list = queryForList(sessionScope, id, paramObject);</span>
<span class="fc" id="L743"></span>
<span class="fc" id="L744">    for (int i = 0, n = list.size(); i &lt; n; i++) {</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">      Object object = list.get(i);</span>
<span class="fc" id="L746">      Object key = PROBE.getObject(object, keyProp);</span>
      Object value = null;
<span class="fc" id="L748">      if (valueProp == null) {</span>
        value = object;
<span class="fc" id="L750">      } else {</span>
        value = PROBE.getObject(object, valueProp);
      }
<span class="fc" id="L753">      map.put(key, value);</span>
    }

    return map;
  }

  // -- Transaction Control Methods
  /**
   * Start a transaction on the session
   *
   * @param sessionScope
   *          - the session
   * @throws SQLException
   *           - if the transaction could not be started
<span class="fc" id="L767">   */</span>
<span class="fc" id="L768">  public void startTransaction(SessionScope sessionScope) throws SQLException {</span>
<span class="fc" id="L769">    try {</span>
<span class="fc" id="L770">      txManager.begin(sessionScope);</span>
<span class="fc" id="L771">    } catch (TransactionException e) {</span>
      throw new NestedSQLException(&quot;Could not start transaction.  Cause: &quot; + e, e);
    }
  }

  /**
   * Start a transaction on the session with the specified isolation level.
   *
   * @param sessionScope
   *          - the session
   * @throws SQLException
   *           - if the transaction could not be started
<span class="nc" id="L783">   */</span>
<span class="nc" id="L784">  public void startTransaction(SessionScope sessionScope, int transactionIsolation) throws SQLException {</span>
<span class="nc" id="L785">    try {</span>
<span class="nc" id="L786">      txManager.begin(sessionScope, transactionIsolation);</span>
<span class="nc" id="L787">    } catch (TransactionException e) {</span>
      throw new NestedSQLException(&quot;Could not start transaction.  Cause: &quot; + e, e);
    }
  }

  /**
   * Commit the transaction on a session
   *
   * @param sessionScope
   *          - the session
   * @throws SQLException
   *           - if the transaction could not be committed
   */
<span class="fc bfc" id="L800" title="All 2 branches covered.">  public void commitTransaction(SessionScope sessionScope) throws SQLException {</span>
<span class="fc" id="L801">    try {</span>
      // Auto batch execution
<span class="fc" id="L803">      if (sessionScope.isInBatch()) {</span>
<span class="fc" id="L804">        executeBatch(sessionScope);</span>
<span class="fc" id="L805">      }</span>
<span class="fc" id="L806">      sqlExecutor.cleanup(sessionScope);</span>
<span class="fc" id="L807">      txManager.commit(sessionScope);</span>
<span class="fc" id="L808">    } catch (TransactionException e) {</span>
      throw new NestedSQLException(&quot;Could not commit transaction.  Cause: &quot; + e, e);
    }
  }

  /**
   * End the transaction on a session
   *
   * @param sessionScope
   *          - the session
   * @throws SQLException
   *           - if the transaction could not be ended
   */
<span class="fc" id="L821">  public void endTransaction(SessionScope sessionScope) throws SQLException {</span>
    try {
<span class="pc" id="L823">      try {</span>
<span class="fc" id="L824">        sqlExecutor.cleanup(sessionScope);</span>
<span class="fc" id="L825">      } finally {</span>
<span class="fc" id="L826">        txManager.end(sessionScope);</span>
<span class="fc" id="L827">      }</span>
<span class="fc" id="L828">    } catch (TransactionException e) {</span>
      throw new NestedSQLException(&quot;Error while ending transaction.  Cause: &quot; + e, e);
    }
  }

  /**
   * Start a batch for a session
   *
   * @param sessionScope
<span class="fc" id="L837">   *          - the session</span>
<span class="fc" id="L838">   */</span>
  public void startBatch(SessionScope sessionScope) {
    sessionScope.setInBatch(true);
  }

  /**
   * Execute a batch for a session
   *
   * @param sessionScope
   *          - the session
   * @return - the number of rows impacted by the batch
   * @throws SQLException
<span class="fc" id="L850">   *           - if the batch fails</span>
<span class="fc" id="L851">   */</span>
  public int executeBatch(SessionScope sessionScope) throws SQLException {
    sessionScope.setInBatch(false);
    return sqlExecutor.executeBatch(sessionScope);
  }

  /**
   * Execute a batch for a session
   *
   * @param sessionScope
   *          - the session
   * @return - a List of BatchResult objects (may be null if no batch has been initiated). There will be one BatchResult
   *         object in the list for each sub-batch executed
   * @throws SQLException
   *           if a database access error occurs, or the drive does not support batch statements
   * @throws BatchException
<span class="fc" id="L867">   *           if the driver throws BatchUpdateException</span>
<span class="fc" id="L868">   */</span>
  public List executeBatchDetailed(SessionScope sessionScope) throws SQLException, BatchException {
    sessionScope.setInBatch(false);
    return sqlExecutor.executeBatchDetailed(sessionScope);
  }

  /**
   * Use a user-provided transaction for a session
   *
   * @param sessionScope
   *          - the session scope
   * @param userConnection
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">   *          - the user supplied connection</span>
<span class="nc" id="L881">   */</span>
  public void setUserProvidedTransaction(SessionScope sessionScope, Connection userConnection) {
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">    if (sessionScope.getTransactionState() == TransactionState.STATE_USER_PROVIDED) {</span>
<span class="fc" id="L884">      sessionScope.recallTransactionState();</span>
<span class="fc" id="L885">    }</span>
<span class="fc" id="L886">    if (userConnection != null) {</span>
<span class="fc" id="L887">      Connection conn = userConnection;</span>
<span class="fc" id="L888">      sessionScope.saveTransactionState();</span>
<span class="nc" id="L889">      sessionScope.setTransaction(new UserProvidedTransaction(conn));</span>
<span class="nc" id="L890">      sessionScope.setTransactionState(TransactionState.STATE_USER_PROVIDED);</span>
<span class="nc" id="L891">    } else {</span>
      sessionScope.setTransaction(null);
<span class="fc" id="L893">      sessionScope.closePreparedStatements();</span>
      sessionScope.cleanup();
    }
  }

  /**
   * Get the DataSource for the session
   *
<span class="fc" id="L901">   * @return - the DataSource</span>
<span class="pc bpc" id="L902" title="1 of 2 branches missed.">   */</span>
<span class="fc" id="L903">  public DataSource getDataSource() {</span>
    DataSource ds = null;
<span class="fc" id="L905">    if (txManager != null) {</span>
      ds = txManager.getConfig().getDataSource();
    }
    return ds;
  }

  /**
   * Getter for the SqlExecutor
   *
<span class="fc" id="L914">   * @return the SqlExecutor</span>
   */
  public SqlExecutor getSqlExecutor() {
    return sqlExecutor;
  }

  /**
   * Get a transaction for the session
   *
   * @param sessionScope
   *          - the session
<span class="fc" id="L925">   * @return - the transaction</span>
   */
  public Transaction getTransaction(SessionScope sessionScope) {
    return sessionScope.getTransaction();
  }

<span class="fc bfc" id="L931" title="All 2 branches covered.">  // -- Protected Methods</span>
<span class="fc" id="L932"></span>
  protected void autoEndTransaction(SessionScope sessionScope, boolean autoStart) throws SQLException {
<span class="fc" id="L934">    if (autoStart) {</span>
      sessionScope.getSqlMapTxMgr().endTransaction();
    }
<span class="fc bfc" id="L937" title="All 2 branches covered.">  }</span>
<span class="fc" id="L938"></span>
  protected void autoCommitTransaction(SessionScope sessionScope, boolean autoStart) throws SQLException {
<span class="fc" id="L940">    if (autoStart) {</span>
      sessionScope.getSqlMapTxMgr().commitTransaction();
    }
  }
<span class="fc" id="L944"></span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">  protected Transaction autoStartTransaction(SessionScope sessionScope, boolean autoStart, Transaction trans)</span>
<span class="fc" id="L946">      throws SQLException {</span>
<span class="fc" id="L947">    Transaction transaction = trans;</span>
    if (autoStart) {
<span class="fc" id="L949">      sessionScope.getSqlMapTxMgr().startTransaction();</span>
      transaction = getTransaction(sessionScope);
    }
    return transaction;
  }
<span class="nc bnc" id="L954" title="All 2 branches missed."></span>
  @Override
  public boolean equals(Object obj) {
    return this == obj;
  }
<span class="fc" id="L959"></span>
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">  @Override</span>
<span class="fc" id="L961">  public int hashCode() {</span>
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">    CacheKey key = new CacheKey();</span>
<span class="fc" id="L963">    if (txManager != null) {</span>
      key.update(txManager);
      if (txManager.getConfig().getDataSource() != null) {
<span class="fc" id="L966">        key.update(txManager.getConfig().getDataSource());</span>
<span class="fc" id="L967">      }</span>
    }
    key.update(System.identityHashCode(this));
    return key.hashCode();
<span class="fc" id="L971">  }</span>
<span class="fc" id="L972"></span>
<span class="fc" id="L973">  protected StatementScope beginStatementScope(SessionScope sessionScope, MappedStatement mappedStatement) {</span>
<span class="fc" id="L974">    StatementScope statementScope = new StatementScope(sessionScope);</span>
    sessionScope.incrementRequestStackDepth();
    mappedStatement.initRequest(statementScope);
    return statementScope;
<span class="fc" id="L978">  }</span>
<span class="fc" id="L979"></span>
  protected void endStatementScope(StatementScope statementScope) {
    statementScope.getSession().decrementRequestStackDepth();
<span class="fc" id="L982">  }</span>

  protected SessionScope beginSessionScope() {
    return new SessionScope();
<span class="fc" id="L986">  }</span>
<span class="fc" id="L987"></span>
  protected void endSessionScope(SessionScope sessionScope) {
    sessionScope.cleanup();
<span class="fc" id="L990">  }</span>

  public ResultObjectFactory getResultObjectFactory() {
    return resultObjectFactory;
<span class="fc" id="L994">  }</span>
<span class="fc" id="L995"></span>
  public void setResultObjectFactory(ResultObjectFactory resultObjectFactory) {
    this.resultObjectFactory = resultObjectFactory;
<span class="fc" id="L998">  }</span>

  public boolean isStatementCacheEnabled() {
    return statementCacheEnabled;
<span class="fc" id="L1002">  }</span>
<span class="fc" id="L1003"></span>
  public void setStatementCacheEnabled(boolean statementCacheEnabled) {
    this.statementCacheEnabled = statementCacheEnabled;
<span class="fc" id="L1006">  }</span>

  public boolean isForceMultipleResultSetSupport() {
    return forceMultipleResultSetSupport;
<span class="fc" id="L1010">  }</span>
<span class="fc" id="L1011"></span>
  public void setForceMultipleResultSetSupport(boolean forceMultipleResultSetSupport) {
    this.forceMultipleResultSetSupport = forceMultipleResultSetSupport;
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>