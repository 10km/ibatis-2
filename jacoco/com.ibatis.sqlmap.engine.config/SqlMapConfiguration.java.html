<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SqlMapConfiguration.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.config</a> &gt; <span class="el_source">SqlMapConfiguration.java</span></div><h1>SqlMapConfiguration.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2004-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.config;

import com.ibatis.common.beans.*;
import com.ibatis.common.resources.*;
import com.ibatis.sqlmap.client.*;
import com.ibatis.sqlmap.client.extensions.*;
import com.ibatis.sqlmap.engine.accessplan.*;
import com.ibatis.sqlmap.engine.cache.*;
import com.ibatis.sqlmap.engine.cache.fifo.*;
import com.ibatis.sqlmap.engine.cache.lru.*;
import com.ibatis.sqlmap.engine.cache.memory.*;
import com.ibatis.sqlmap.engine.datasource.*;
import com.ibatis.sqlmap.engine.impl.*;
import com.ibatis.sqlmap.engine.mapping.result.*;
import com.ibatis.sqlmap.engine.mapping.statement.*;
import com.ibatis.sqlmap.engine.scope.*;
import com.ibatis.sqlmap.engine.transaction.*;
import com.ibatis.sqlmap.engine.transaction.external.*;
import com.ibatis.sqlmap.engine.transaction.jdbc.*;
import com.ibatis.sqlmap.engine.transaction.jta.*;
import com.ibatis.sqlmap.engine.type.*;

<span class="fc" id="L38">import java.util.*;</span>

public class SqlMapConfiguration {
  private static final Probe PROBE = ProbeFactory.getProbe();
  private ErrorContext errorContext;
  private SqlMapExecutorDelegate delegate;
  private TypeHandlerFactory typeHandlerFactory;
<span class="fc" id="L45">  private SqlMapClientImpl client;</span>
<span class="fc" id="L46">  private Integer defaultStatementTimeout;</span>
<span class="fc" id="L47"></span>
<span class="fc" id="L48">  public SqlMapConfiguration() {</span>
<span class="fc" id="L49">    errorContext = new ErrorContext();</span>
<span class="fc" id="L50">    delegate = new SqlMapExecutorDelegate();</span>
<span class="fc" id="L51">    typeHandlerFactory = delegate.getTypeHandlerFactory();</span>
    client = new SqlMapClientImpl(delegate);
    registerDefaultTypeAliases();
<span class="fc" id="L54">  }</span>

  public TypeHandlerFactory getTypeHandlerFactory() {
    return typeHandlerFactory;
<span class="fc" id="L58">  }</span>

  public ErrorContext getErrorContext() {
    return errorContext;
<span class="fc" id="L62">  }</span>

  public SqlMapClientImpl getClient() {
    return client;
<span class="fc" id="L66">  }</span>

  public SqlMapExecutorDelegate getDelegate() {
    return delegate;
<span class="fc" id="L70">  }</span>
<span class="fc" id="L71"></span>
<span class="fc" id="L72">  public void setClassInfoCacheEnabled(boolean classInfoCacheEnabled) {</span>
    errorContext.setActivity(&quot;setting class info cache enabled/disabled&quot;);
    ClassInfo.setCacheEnabled(classInfoCacheEnabled);
<span class="fc" id="L75">  }</span>
<span class="fc" id="L76"></span>
<span class="fc" id="L77">  public void setLazyLoadingEnabled(boolean lazyLoadingEnabled) {</span>
    errorContext.setActivity(&quot;setting lazy loading enabled/disabled&quot;);
    client.getDelegate().setLazyLoadingEnabled(lazyLoadingEnabled);
<span class="fc" id="L80">  }</span>
<span class="fc" id="L81"></span>
<span class="fc" id="L82">  public void setStatementCachingEnabled(boolean statementCachingEnabled) {</span>
    errorContext.setActivity(&quot;setting statement caching enabled/disabled&quot;);
    client.getDelegate().setStatementCacheEnabled(statementCachingEnabled);
<span class="fc" id="L85">  }</span>
<span class="fc" id="L86"></span>
<span class="fc" id="L87">  public void setCacheModelsEnabled(boolean cacheModelsEnabled) {</span>
    errorContext.setActivity(&quot;setting cache models enabled/disabled&quot;);
    client.getDelegate().setCacheModelsEnabled(cacheModelsEnabled);
<span class="fc" id="L90">  }</span>

<span class="pc bpc" id="L92" title="3 of 4 branches missed.">  public void setEnhancementEnabled(boolean enhancementEnabled) {</span>
<span class="nc" id="L93">    errorContext.setActivity(&quot;setting enhancement enabled/disabled&quot;);</span>
<span class="nc" id="L94">    try {</span>
<span class="fc" id="L95">      enhancementEnabled = enhancementEnabled &amp;&amp; Resources.classForName(&quot;net.sf.cglib.proxy.InvocationHandler&quot;) != null;</span>
<span class="fc" id="L96">    } catch (ClassNotFoundException e) {</span>
<span class="fc" id="L97">      enhancementEnabled = false;</span>
<span class="fc" id="L98">    }</span>
    client.getDelegate().setEnhancementEnabled(enhancementEnabled);
    AccessPlanFactory.setBytecodeEnhancementEnabled(enhancementEnabled);
<span class="fc" id="L101">  }</span>
<span class="fc" id="L102"></span>
  public void setUseColumnLabel(boolean useColumnLabel) {
    client.getDelegate().setUseColumnLabel(useColumnLabel);
<span class="fc" id="L105">  }</span>
<span class="fc" id="L106"></span>
  public void setForceMultipleResultSetSupport(boolean forceMultipleResultSetSupport) {
    client.getDelegate().setForceMultipleResultSetSupport(forceMultipleResultSetSupport);
<span class="fc" id="L109">  }</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed."></span>
  public void setDefaultStatementTimeout(Integer defaultTimeout) {
<span class="nc" id="L112">    errorContext.setActivity(&quot;setting default timeout&quot;);</span>
<span class="nc" id="L113">    if (defaultTimeout != null) {</span>
<span class="nc" id="L114">      try {</span>
<span class="nc" id="L115">        defaultStatementTimeout = defaultTimeout;</span>
      } catch (NumberFormatException e) {
<span class="fc" id="L117">        throw new SqlMapException(&quot;Specified defaultStatementTimeout is not a valid integer&quot;);</span>
      }
    }
<span class="fc" id="L120">  }</span>
<span class="fc" id="L121"></span>
  public void setTransactionManager(TransactionManager txManager) {
    delegate.setTxManager(txManager);
<span class="fc" id="L124">  }</span>
<span class="fc" id="L125"></span>
  public void setResultObjectFactory(ResultObjectFactory rof) {
    delegate.setResultObjectFactory(rof);
  }
<span class="fc" id="L129"></span>
<span class="fc" id="L130">  public void newTypeHandler(Class javaType, String jdbcType, Object callback) {</span>
    try {
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">      errorContext.setActivity(&quot;building a building custom type handler&quot;);</span>
<span class="fc" id="L133">      TypeHandlerFactory typeHandlerFactory = client.getDelegate().getTypeHandlerFactory();</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">      TypeHandler typeHandler;</span>
<span class="nc" id="L135">      if (callback instanceof TypeHandlerCallback) {</span>
        typeHandler = new CustomTypeHandler((TypeHandlerCallback) callback);
<span class="nc" id="L137">      } else if (callback instanceof TypeHandler) {</span>
        typeHandler = (TypeHandler) callback;
      } else {
<span class="fc" id="L140">        throw new RuntimeException(&quot;The object '&quot; + callback</span>
            + &quot;' is not a valid implementation of TypeHandler or TypeHandlerCallback&quot;);
<span class="pc bpc" id="L142" title="2 of 4 branches missed.">      }</span>
<span class="fc" id="L143">      errorContext.setMoreInfo(&quot;Check the javaType attribute '&quot; + javaType</span>
          + &quot;' (must be a classname) or the jdbcType '&quot; + jdbcType + &quot;' (must be a JDBC type name).&quot;);
<span class="nc" id="L145">      if (jdbcType != null &amp;&amp; jdbcType.length() &gt; 0) {</span>
        typeHandlerFactory.register(javaType, jdbcType, typeHandler);
<span class="nc" id="L147">      } else {</span>
<span class="nc" id="L148">        typeHandlerFactory.register(javaType, typeHandler);</span>
<span class="fc" id="L149">      }</span>
<span class="fc" id="L150">    } catch (Exception e) {</span>
<span class="fc" id="L151">      throw new SqlMapException(&quot;Error registering occurred.  Cause: &quot; + e, e);</span>
<span class="fc" id="L152">    }</span>
    errorContext.setMoreInfo(null);
    errorContext.setObjectId(null);
<span class="fc" id="L155">  }</span>

  public CacheModelConfig newCacheModelConfig(String id, CacheController controller, boolean readOnly, boolean serialize) {
    return new CacheModelConfig(this, id, controller, readOnly, serialize);
<span class="fc" id="L159">  }</span>

  public ParameterMapConfig newParameterMapConfig(String id, Class parameterClass) {
    return new ParameterMapConfig(this, id, parameterClass);
  }
<span class="fc" id="L164"></span>
  public ResultMapConfig newResultMapConfig(String id, Class resultClass, String groupBy, String extended,
      String xmlName) {
    return new ResultMapConfig(this, id, resultClass, groupBy, extended, xmlName);
  }

  public MappedStatementConfig newMappedStatementConfig(String id, MappedStatement statement, SqlSource processor,
<span class="fc" id="L171">      String parameterMapName, Class parameterClass, String resultMapName, String[] additionalResultMapNames,</span>
      Class resultClass, Class[] additionalResultClasses, String resultSetType, Integer fetchSize,
      boolean allowRemapping, Integer timeout, String cacheModelName, String xmlResultName) {
    return new MappedStatementConfig(this, id, statement, processor, parameterMapName, parameterClass, resultMapName,
        additionalResultMapNames, resultClass, additionalResultClasses, cacheModelName, resultSetType, fetchSize,
        allowRemapping, timeout, defaultStatementTimeout, xmlResultName);
<span class="fc" id="L177">  }</span>
<span class="fc" id="L178"></span>
<span class="fc" id="L179">  public void finalizeSqlMapConfig() {</span>
    wireUpCacheModels();
    bindResultMapDiscriminators();
  }
<span class="fc" id="L183"></span>
  TypeHandler resolveTypeHandler(TypeHandlerFactory typeHandlerFactory, Class clazz, String propertyName,
      Class javaType, String jdbcType) {
    return resolveTypeHandler(typeHandlerFactory, clazz, propertyName, javaType, jdbcType, false);
  }

<span class="pc bpc" id="L189" title="1 of 2 branches missed.">  TypeHandler resolveTypeHandler(TypeHandlerFactory typeHandlerFactory, Class clazz, String propertyName,</span>
      Class javaType, String jdbcType, boolean useSetterToResolve) {
<span class="nc" id="L191">    TypeHandler handler;</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">    if (clazz == null) {</span>
      // Unknown
<span class="fc" id="L194">      handler = typeHandlerFactory.getUnkownTypeHandler();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">    } else if (DomTypeMarker.class.isAssignableFrom(clazz)) {</span>
      // DOM
<span class="fc bfc" id="L197" title="All 2 branches covered.">      handler = typeHandlerFactory.getTypeHandler(String.class, jdbcType);</span>
<span class="fc" id="L198">    } else if (java.util.Map.class.isAssignableFrom(clazz)) {</span>
      // Map
      if (javaType == null) {
        handler = typeHandlerFactory.getUnkownTypeHandler(); // BUG 1012591 -
<span class="fc" id="L202">                                                             // typeHandlerFactory.getTypeHandler(java.lang.Object.class,</span>
                                                             // jdbcType);
<span class="fc bfc" id="L204" title="All 2 branches covered.">      } else {</span>
        handler = typeHandlerFactory.getTypeHandler(javaType, jdbcType);
<span class="fc" id="L206">      }</span>
    } else if (typeHandlerFactory.getTypeHandler(clazz, jdbcType) != null) {
      // Primitive
<span class="fc bfc" id="L209" title="All 2 branches covered.">      handler = typeHandlerFactory.getTypeHandler(clazz, jdbcType);</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">    } else {</span>
<span class="fc" id="L211">      // JavaBean</span>
<span class="fc" id="L212">      if (javaType == null) {</span>
<span class="fc" id="L213">        if (useSetterToResolve) {</span>
<span class="fc" id="L214">          Class type = PROBE.getPropertyTypeForSetter(clazz, propertyName);</span>
<span class="fc" id="L215">          handler = typeHandlerFactory.getTypeHandler(type, jdbcType);</span>
<span class="fc" id="L216">        } else {</span>
          Class type = PROBE.getPropertyTypeForGetter(clazz, propertyName);
<span class="fc" id="L218">          handler = typeHandlerFactory.getTypeHandler(type, jdbcType);</span>
        }
      } else {
<span class="fc" id="L221">        handler = typeHandlerFactory.getTypeHandler(javaType, jdbcType);</span>
      }
    }
    return handler;
  }
<span class="fc" id="L226"></span>
<span class="fc" id="L227">  private void registerDefaultTypeAliases() {</span>
<span class="fc" id="L228">    // TRANSACTION ALIASES</span>
    typeHandlerFactory.putTypeAlias(&quot;JDBC&quot;, JdbcTransactionConfig.class.getName());
    typeHandlerFactory.putTypeAlias(&quot;JTA&quot;, JtaTransactionConfig.class.getName());
<span class="fc" id="L231">    typeHandlerFactory.putTypeAlias(&quot;EXTERNAL&quot;, ExternalTransactionConfig.class.getName());</span>
<span class="fc" id="L232"></span>
<span class="fc" id="L233">    // DATA SOURCE ALIASES</span>
    typeHandlerFactory.putTypeAlias(&quot;SIMPLE&quot;, SimpleDataSourceFactory.class.getName());
    typeHandlerFactory.putTypeAlias(&quot;DBCP&quot;, DbcpDataSourceFactory.class.getName());
<span class="fc" id="L236">    typeHandlerFactory.putTypeAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class.getName());</span>
<span class="fc" id="L237"></span>
<span class="fc" id="L238">    // CACHE ALIASES</span>
    typeHandlerFactory.putTypeAlias(&quot;FIFO&quot;, FifoCacheController.class.getName());
<span class="fc" id="L240">    typeHandlerFactory.putTypeAlias(&quot;LRU&quot;, LruCacheController.class.getName());</span>
    typeHandlerFactory.putTypeAlias(&quot;MEMORY&quot;, MemoryCacheController.class.getName());
    // use a string for OSCache to avoid unnecessary loading of properties upon init
<span class="fc" id="L243">    typeHandlerFactory.putTypeAlias(&quot;OSCACHE&quot;, &quot;com.ibatis.sqlmap.engine.cache.oscache.OSCacheController&quot;);</span>
<span class="fc" id="L244"></span>
<span class="fc" id="L245">    // TYPE ALIASEs</span>
<span class="fc" id="L246">    typeHandlerFactory.putTypeAlias(&quot;dom&quot;, DomTypeMarker.class.getName());</span>
<span class="fc" id="L247">    typeHandlerFactory.putTypeAlias(&quot;domCollection&quot;, DomCollectionTypeMarker.class.getName());</span>
    typeHandlerFactory.putTypeAlias(&quot;xml&quot;, XmlTypeMarker.class.getName());
    typeHandlerFactory.putTypeAlias(&quot;xmlCollection&quot;, XmlCollectionTypeMarker.class.getName());
  }
<span class="fc" id="L251"></span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">  private void wireUpCacheModels() {</span>
<span class="fc" id="L253">    // Wire Up Cache Models</span>
<span class="fc" id="L254">    Iterator cacheNames = client.getDelegate().getCacheModelNames();</span>
<span class="fc" id="L255">    while (cacheNames.hasNext()) {</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">      String cacheName = (String) cacheNames.next();</span>
<span class="fc" id="L257">      CacheModel cacheModel = client.getDelegate().getCacheModel(cacheName);</span>
<span class="fc" id="L258">      Iterator statementNames = cacheModel.getFlushTriggerStatementNames();</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">      while (statementNames.hasNext()) {</span>
<span class="fc" id="L260">        String statementName = (String) statementNames.next();</span>
        MappedStatement statement = client.getDelegate().getMappedStatement(statementName);
<span class="nc" id="L262">        if (statement != null) {</span>
          statement.addExecuteListener(cacheModel);
        } else {
<span class="fc" id="L265">          throw new RuntimeException(&quot;Could not find statement named '&quot; + statementName</span>
<span class="fc" id="L266">              + &quot;' for use as a flush trigger for the cache model named '&quot; + cacheName + &quot;'.&quot;);</span>
<span class="fc" id="L267">        }</span>
      }
    }
  }
<span class="fc" id="L271"></span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">  private void bindResultMapDiscriminators() {</span>
<span class="fc" id="L273">    // Bind discriminators</span>
<span class="fc" id="L274">    Iterator names = delegate.getResultMapNames();</span>
<span class="fc" id="L275">    while (names.hasNext()) {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">      String name = (String) names.next();</span>
<span class="fc" id="L277">      ResultMap rm = delegate.getResultMap(name);</span>
      Discriminator disc = rm.getDiscriminator();
<span class="fc" id="L279">      if (disc != null) {</span>
<span class="fc" id="L280">        disc.bindSubMaps();</span>
      }
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>