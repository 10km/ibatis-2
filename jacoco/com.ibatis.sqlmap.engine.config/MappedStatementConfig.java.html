<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MappedStatementConfig.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.config</a> &gt; <span class="el_source">MappedStatementConfig.java</span></div><h1>MappedStatementConfig.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2004-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.config;

import com.ibatis.common.beans.*;
import com.ibatis.common.resources.*;
import com.ibatis.sqlmap.client.*;
import com.ibatis.sqlmap.engine.cache.*;
import com.ibatis.sqlmap.engine.impl.*;
import com.ibatis.sqlmap.engine.mapping.parameter.*;
import com.ibatis.sqlmap.engine.mapping.result.*;
import com.ibatis.sqlmap.engine.mapping.sql.*;
import com.ibatis.sqlmap.engine.mapping.sql.dynamic.*;
import com.ibatis.sqlmap.engine.mapping.sql.simple.*;
import com.ibatis.sqlmap.engine.mapping.sql.stat.*;
import com.ibatis.sqlmap.engine.mapping.statement.*;
import com.ibatis.sqlmap.engine.scope.*;
import com.ibatis.sqlmap.engine.type.*;

import java.sql.ResultSet;
<span class="fc" id="L34">import java.util.*;</span>
<span class="fc" id="L35"></span>
public class MappedStatementConfig {
  private static final Probe PROBE = ProbeFactory.getProbe();
  private static final InlineParameterMapParser PARAM_PARSER = new InlineParameterMapParser();
  private ErrorContext errorContext;
  private SqlMapClientImpl client;
  private TypeHandlerFactory typeHandlerFactory;
  private MappedStatement mappedStatement;
  private MappedStatement rootStatement;

<span class="fc" id="L45">  MappedStatementConfig(SqlMapConfiguration config, String id, MappedStatement statement, SqlSource processor,</span>
<span class="fc" id="L46">      String parameterMapName, Class parameterClass, String resultMapName, String[] additionalResultMapNames,</span>
<span class="fc" id="L47">      Class resultClass, Class[] additionalResultClasses, String cacheModelName, String resultSetType,</span>
<span class="fc" id="L48">      Integer fetchSize, boolean allowRemapping, Integer timeout, Integer defaultStatementTimeout, String xmlResultName) {</span>
<span class="fc" id="L49">    this.errorContext = config.getErrorContext();</span>
<span class="fc" id="L50">    this.client = config.getClient();</span>
<span class="fc" id="L51">    SqlMapExecutorDelegate delegate = client.getDelegate();</span>
<span class="fc" id="L52">    this.typeHandlerFactory = config.getTypeHandlerFactory();</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">    errorContext.setActivity(&quot;parsing a mapped statement&quot;);</span>
<span class="fc" id="L54">    errorContext.setObjectId(id + &quot; statement&quot;);</span>
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">    errorContext.setMoreInfo(&quot;Check the result map name.&quot;);</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">    if (resultMapName != null) {</span>
<span class="fc" id="L57">      statement.setResultMap(client.getDelegate().getResultMap(resultMapName));</span>
      if (additionalResultMapNames != null) {
        for (int i = 0; i &lt; additionalResultMapNames.length; i++) {
          statement.addResultMap(client.getDelegate().getResultMap(additionalResultMapNames[i]));
<span class="fc" id="L61">        }</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">      }</span>
<span class="fc" id="L63">    }</span>
    errorContext.setMoreInfo(&quot;Check the parameter map name.&quot;);
<span class="fc" id="L65">    if (parameterMapName != null) {</span>
<span class="fc" id="L66">      statement.setParameterMap(client.getDelegate().getParameterMap(parameterMapName));</span>
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">    }</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">    statement.setId(id);</span>
<span class="nc" id="L69">    statement.setResource(errorContext.getResource());</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">    if (resultSetType != null) {</span>
<span class="nc" id="L71">      if (&quot;FORWARD_ONLY&quot;.equals(resultSetType)) {</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">        statement.setResultSetType(new Integer(ResultSet.TYPE_FORWARD_ONLY));</span>
<span class="nc" id="L73">      } else if (&quot;SCROLL_INSENSITIVE&quot;.equals(resultSetType)) {</span>
        statement.setResultSetType(new Integer(ResultSet.TYPE_SCROLL_INSENSITIVE));
      } else if (&quot;SCROLL_SENSITIVE&quot;.equals(resultSetType)) {
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        statement.setResultSetType(new Integer(ResultSet.TYPE_SCROLL_SENSITIVE));</span>
<span class="nc" id="L77">      }</span>
    }
    if (fetchSize != null) {
      statement.setFetchSize(fetchSize);
<span class="fc" id="L81">    }</span>
<span class="fc bfc" id="L82" title="All 2 branches covered."></span>
<span class="fc" id="L83">    // set parameter class either from attribute or from map (make sure to match)</span>
    ParameterMap parameterMap = statement.getParameterMap();
<span class="fc" id="L85">    if (parameterMap == null) {</span>
      statement.setParameterClass(parameterClass);
    } else {
      statement.setParameterClass(parameterMap.getParameterClass());
<span class="fc" id="L89">    }</span>
<span class="fc" id="L90"></span>
<span class="fc" id="L91">    // process SQL statement, including inline parameter maps</span>
    errorContext.setMoreInfo(&quot;Check the SQL statement.&quot;);
    Sql sql = processor.getSql();
<span class="fc" id="L94">    setSqlForStatement(statement, sql);</span>
<span class="fc bfc" id="L95" title="All 4 branches covered."></span>
<span class="fc" id="L96">    // set up either null result map or automatic result mapping</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">    ResultMap resultMap = (ResultMap) statement.getResultMap();</span>
<span class="fc" id="L98">    if (resultMap == null &amp;&amp; resultClass == null) {</span>
<span class="fc" id="L99">      statement.setResultMap(null);</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">    } else if (resultMap == null) {</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">      resultMap = buildAutoResultMap(allowRemapping, statement, resultClass, xmlResultName);</span>
<span class="fc" id="L102">      statement.setResultMap(resultMap);</span>
      if (additionalResultClasses != null) {
        for (int i = 0; i &lt; additionalResultClasses.length; i++) {
          statement.addResultMap(buildAutoResultMap(allowRemapping, statement, additionalResultClasses[i],
              xmlResultName));
        }
<span class="fc" id="L108">      }</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed."></span>
    }
<span class="nc" id="L111">    statement.setTimeout(defaultStatementTimeout);</span>
<span class="nc" id="L112">    if (timeout != null) {</span>
<span class="nc" id="L113">      try {</span>
        statement.setTimeout(timeout);
<span class="nc" id="L115">      } catch (NumberFormatException e) {</span>
        throw new SqlMapException(&quot;Specified timeout value for statement &quot; + statement.getId()
<span class="fc" id="L117">            + &quot; is not a valid integer&quot;);</span>
<span class="fc" id="L118">      }</span>
<span class="fc" id="L119">    }</span>
<span class="pc bpc" id="L120" title="2 of 6 branches missed.">    errorContext.setMoreInfo(null);</span>
<span class="fc" id="L121">    errorContext.setObjectId(null);</span>
<span class="fc" id="L122">    statement.setSqlMapClient(client);</span>
<span class="fc" id="L123">    if (cacheModelName != null &amp;&amp; cacheModelName.length() &gt; 0 &amp;&amp; client.getDelegate().isCacheModelsEnabled()) {</span>
<span class="fc" id="L124">      CacheModel cacheModel = client.getDelegate().getCacheModel(cacheModelName);</span>
      mappedStatement = new CachingStatement(statement, cacheModel);
<span class="fc" id="L126">    } else {</span>
<span class="fc" id="L127">      mappedStatement = statement;</span>
<span class="fc" id="L128">    }</span>
    rootStatement = statement;
    delegate.addMappedStatement(mappedStatement);
  }
<span class="pc bpc" id="L132" title="1 of 2 branches missed."></span>
<span class="fc" id="L133">  public void setSelectKeyStatement(SqlSource processor, String resultClassName, String keyPropName,</span>
<span class="fc" id="L134">      boolean runAfterSQL, String type) {</span>
<span class="fc" id="L135">    if (rootStatement instanceof InsertStatement) {</span>
<span class="fc" id="L136">      InsertStatement insertStatement = ((InsertStatement) rootStatement);</span>
<span class="fc" id="L137">      Class parameterClass = insertStatement.getParameterClass();</span>
<span class="fc" id="L138">      errorContext.setActivity(&quot;parsing a select key&quot;);</span>
      SelectKeyStatement selectKeyStatement = new SelectKeyStatement();
      resultClassName = typeHandlerFactory.resolveAlias(resultClassName);
<span class="fc" id="L141">      Class resultClass = null;</span>
<span class="fc" id="L142"></span>
<span class="fc" id="L143">      // get parameter and result maps</span>
<span class="fc" id="L144">      selectKeyStatement.setSqlMapClient(client);</span>
<span class="fc" id="L145">      selectKeyStatement.setId(insertStatement.getId() + &quot;-SelectKey&quot;);</span>
      selectKeyStatement.setResource(errorContext.getResource());
<span class="fc bfc" id="L147" title="All 2 branches covered.">      selectKeyStatement.setKeyProperty(keyPropName);</span>
<span class="fc" id="L148">      selectKeyStatement.setRunAfterSQL(runAfterSQL);</span>
      // process the type (pre or post) attribute
      if (type != null) {
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        selectKeyStatement.setRunAfterSQL(&quot;post&quot;.equals(type));</span>
<span class="fc" id="L152">      }</span>
<span class="fc" id="L153">      try {</span>
        if (resultClassName != null) {
<span class="nc bnc" id="L155" title="All 4 branches missed.">          errorContext.setMoreInfo(&quot;Check the select key result class.&quot;);</span>
<span class="nc" id="L156">          resultClass = Resources.classForName(resultClassName);</span>
        } else {
          if (keyPropName != null &amp;&amp; parameterClass != null) {
<span class="nc" id="L159">            resultClass = PROBE.getPropertyTypeForSetter(parameterClass, selectKeyStatement.getKeyProperty());</span>
<span class="nc" id="L160">          }</span>
<span class="fc" id="L161">        }</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">      } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L163">        throw new SqlMapException(&quot;Error.  Could not set result class.  Cause: &quot; + e, e);</span>
      }
      if (resultClass == null) {
        resultClass = Object.class;
<span class="fc" id="L167">      }</span>
<span class="fc" id="L168"></span>
<span class="fc" id="L169">      // process SQL statement, including inline parameter maps</span>
      errorContext.setMoreInfo(&quot;Check the select key SQL statement.&quot;);
<span class="fc" id="L171">      Sql sql = processor.getSql();</span>
<span class="fc" id="L172">      setSqlForStatement(selectKeyStatement, sql);</span>
<span class="fc" id="L173">      ResultMap resultMap;</span>
<span class="fc" id="L174">      resultMap = new AutoResultMap(client.getDelegate(), false);</span>
<span class="fc" id="L175">      resultMap.setId(selectKeyStatement.getId() + &quot;-AutoResultMap&quot;);</span>
<span class="fc" id="L176">      resultMap.setResultClass(resultClass);</span>
<span class="fc" id="L177">      resultMap.setResource(selectKeyStatement.getResource());</span>
<span class="fc" id="L178">      selectKeyStatement.setResultMap(resultMap);</span>
<span class="nc" id="L179">      errorContext.setMoreInfo(null);</span>
      insertStatement.setSelectKeyStatement(selectKeyStatement);
    } else {
<span class="fc" id="L182">      throw new SqlMapException(&quot;You cant set a select key statement on statement named &quot; + rootStatement.getId()</span>
          + &quot; because it is not an InsertStatement.&quot;);
    }
<span class="fc bfc" id="L185" title="All 2 branches covered.">  }</span>
<span class="fc" id="L186"></span>
  private void setSqlForStatement(MappedStatement statement, Sql sql) {
<span class="fc" id="L188">    if (sql instanceof DynamicSql) {</span>
      statement.setSql(sql);
<span class="fc" id="L190">    } else {</span>
      applyInlineParameterMap(statement, sql.getSql(null, null));
    }
<span class="fc" id="L193">  }</span>
<span class="fc" id="L194"></span>
<span class="fc" id="L195">  private void applyInlineParameterMap(MappedStatement statement, String sqlStatement) {</span>
<span class="fc" id="L196">    String newSql = sqlStatement;</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">    errorContext.setActivity(&quot;building an inline parameter map&quot;);</span>
    ParameterMap parameterMap = statement.getParameterMap();
<span class="fc" id="L199">    errorContext.setMoreInfo(&quot;Check the inline parameters.&quot;);</span>
<span class="fc" id="L200">    if (parameterMap == null) {</span>
<span class="fc" id="L201">      ParameterMap map;</span>
<span class="fc" id="L202">      map = new ParameterMap(client.getDelegate());</span>
<span class="fc" id="L203">      map.setId(statement.getId() + &quot;-InlineParameterMap&quot;);</span>
<span class="fc" id="L204">      map.setParameterClass(statement.getParameterClass());</span>
<span class="fc" id="L205">      map.setResource(statement.getResource());</span>
<span class="fc" id="L206">      statement.setParameterMap(map);</span>
<span class="fc" id="L207">      SqlText sqlText = PARAM_PARSER.parseInlineParameterMap(client.getDelegate().getTypeHandlerFactory(), newSql,</span>
<span class="fc" id="L208">          statement.getParameterClass());</span>
      newSql = sqlText.getText();
      List mappingList = Arrays.asList(sqlText.getParameterMappings());
<span class="fc bfc" id="L211" title="All 2 branches covered.">      map.setParameterMappingList(mappingList);</span>
<span class="fc" id="L212">    }</span>
    Sql sql;
<span class="fc" id="L214">    if (SimpleDynamicSql.isSimpleDynamicSql(newSql)) {</span>
      sql = new SimpleDynamicSql(client.getDelegate(), newSql);
<span class="fc" id="L216">    } else {</span>
      sql = new StaticSql(newSql);
<span class="fc" id="L218">    }</span>
    statement.setSql(sql);

  }

<span class="fc" id="L223">  private ResultMap buildAutoResultMap(boolean allowRemapping, MappedStatement statement, Class firstResultClass,</span>
<span class="fc" id="L224">      String xmlResultName) {</span>
<span class="fc" id="L225">    ResultMap resultMap;</span>
<span class="fc" id="L226">    resultMap = new AutoResultMap(client.getDelegate(), allowRemapping);</span>
<span class="fc" id="L227">    resultMap.setId(statement.getId() + &quot;-AutoResultMap&quot;);</span>
<span class="fc" id="L228">    resultMap.setResultClass(firstResultClass);</span>
    resultMap.setXmlName(xmlResultName);
    resultMap.setResource(statement.getResource());
    return resultMap;
<span class="nc" id="L232">  }</span>

  public MappedStatement getMappedStatement() {
    return mappedStatement;
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>